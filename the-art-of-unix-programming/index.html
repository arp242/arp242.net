<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>The Art of Unix Programming</title>
	<link rel="shortcut icon" href="/favicon.ico">
	<link rel="canonical" href="https://arp242.net/taoup">
	<style>
		html {
			font: 16px/1.5em 'DejaVu Sans Serif', sans-serif;
			color: #252525;
			background-color: #eee;
			-moz-tab-size: 4;
				tab-size: 4;
		}
		body {
			max-width: 46em;
			padding: 0 4rem;
			margin: 0 auto;
			background-color: #fff;
			box-shadow: 0 0 6px rgba(0, 0, 0, .2);
		}
		@media (max-width: 46rem) {
			body { padding: 0 .5em; }
		}
		a { text-decoration: none; }
		a:hover { text-decoration: underline; }

		h1 { text-align: center; padding: 2em 0 1em 0; }
		h2 { border-top: 2px solid #666; padding-top: 1em; text-align: center; }

		table.border, table.border td, table.border th {
			border: 1px solid #252525;
			border-collapse: collapse;
		}

		.center { text-align: center; }

		.author { text-align: center; }
		.legal { font-size: 12px; }
		.dedication { text-align: center; }

		.toc-fixed {
			background-color: #ffe;
			border-right: 1px solid #aaa;
			box-shadow: 2px 0 6px rgba(0,0,0,.5);

			position: fixed;
			left: 0;
			top: 0;
			overflow-y: scroll;
			height: 100%;
			width: 500px;
			z-index: 10;
			font-size: 16px;
		}
		.toc-fixed h2 { border-top: 0; margin: 0; padding: 0; font-size: 1em; }

		#toc-button { display: none; }
		.toc-fixed #toc-button {
			background-color: #ffe;
			display: block;
			position: fixed;
			top: 0;
			left: 400px;
			font-size: 100px;
			cursor: pointer;
			width: 90px;
			height: 90px;
			line-height: 90px;
			text-align: center;
			vertical-align: middle;
			z-index: 20;
		}
		.toc-fixed #toc-button:hover {
			color: #00f
		}

		.toc-collapsed #toc-button {
			left: 0px;
		}

		.toc-collapsed {
			overflow: hidden;
			width: 90px;
			height: 90px;
		}

		#toc a {
			display: inline-block;
			width: 100%;
			padding-left: 5px;
			margin-left: -5px;
		}

		#toc .active {
			background-color: #ddd;
		}

		/* Don't number subsections. */
		#toc ol[type="a"] {
			list-style-type: none;
			padding-left: .5em;
		}
		/* Preface. */
		#toc ol[type="I"] > li:first-child {
			list-style-type: none;
			margin-left: -1em;
		}
		#toc ol[type="I"] > li:first-child > ol > li {
			margin-top: 0;
			font-weight: normal;
		}

		#toc > ol[type="I"] > li {
			font-weight: bold;
		}
		#toc > ol[type="I"] > li ol {
			font-weight: normal;
			padding-left: 1em;
		}

		#toc > ol[type="I"] > li > ol > li {
			font-weight: bold;

		}
		#toc > ol[type="I"] > li > ol > li ol {
			margin-top: 0;
			font-weight: normal;
		}

		/* TODO: button to show. */
		#toc > ol > li > ol > li > ol > li > ol > li {
			display: none;
		}

		blockquote {
			width: 80%;
			margin: 0 auto;
			position: relative;
			padding: .1em 1em;
			font-style: italic;
			position: relative;
		}
		blockquote:before {
			content: "“";
			position: absolute;
			left: -30px;
			top: 5px;
			color: #ccc;
			font-size: 75px;
		}
		blockquote:after {
			content: "”";
			position: absolute;
			right: -30px;
			bottom: -5px;
			color: #ccc;
			font-size: 75px;
		}
		blockquote p { margin: 0; }
		blockquote span { display: block; text-align: right; }

		pre {
			background-color: #eee;
			padding: .2em .5em;
		}
		code {
			background-color: #eee;
			padding: 0 .2em;
		}

		.footnotes {
			font-style: italic;
			font-size: .9em;
			border-top: 1px solid #bbb;
			border-bottom: 1px solid #bbb;
			position: relative;
		}
		.footnotes > strong {
			position: absolute;
			top: -1em;
			background-color: #fff;
			left: 2em;
			padding: 0 .5em;
		}

		*:target { background-color: #ff0; }

		h1, h2, h3, h4, h5, h6 { position: relative; }
		h2 a {
			color: #3a6ea5;
			opacity: .5;
			font-size: .8em;
			line-height: 1.6em;
			margin-right: .2em;
		}

		h3 a, h4 a, h5, h6 a {
			position: absolute;
			left: -1em;
			color: #3a6ea5;
			opacity: .5;
			font-size: .8em;
			line-height: 1.6em;
		}
	</style>
</head>

<body>

<h1>The Art of Unix Programming</h1>
<p class="author">
	<strong class="author">Eric Steven Raymond</strong><br>
	<a href="http://www.catb.org/~esr/">Thyrsus Enterprises</a>
	&lt;<a href="mailto:esr@thyrsus.com">esr@thyrsus.com</a>&gt;<br>
	Copyright © 2003 Eric S. Raymond
</p>

<p class="author">
This document is formatted by Martin Tournoij &lt;<a href="mailto:martin@arp242.net">martin@arp242.net</a>&gt;, and
	is otherwise unchanged from <a href="http://catb.org/~esr/writings/taoup/html/"> the original</a>.
</p>

<div class="legal">
	<p>This book and its on-line version are distributed under the terms of the Creative Commons
	Attribution-NoDerivs 1.0 license, with the additional proviso that the right to publish it on paper for sale or
	other for-profit use is reserved to Pearson Education, Inc. A reference copy of this license may be found at
	<a href="http://creativecommons.org/licenses/by-nd/1.0/legalcode">
		http://creativecommons.org/licenses/by-nd/1.0/legalcode</a>.
	</p>

	<p>AIX, AS/400, DB/2, OS/2, System/360, MVS, VM/CMS, and IBM PC are trademarks of IBM. Alpha, DEC, VAX, HP-UX,
	PDP, TOPS-10, TOPS-20, VMS, and VT-100 are trademarks of Compaq. Amiga and AmigaOS are trademarks of Amiga, Inc.
	Apple, Macintosh, MacOS, Newton, OpenDoc, and OpenStep are trademarks of Apple Computers, Inc. ClearCase is a
	trademark of Rational Software, Inc. Ethernet is a trademark of 3COM, Inc. Excel, MS-DOS, Microsoft Windows and
	PowerPoint are trademarks of Microsoft, Inc. Java. J2EE, JavaScript, NeWS, and Solaris are trademarks of Sun
	Microsystems. SPARC is a trademark of SPARC international. Informix is a trademark of Informix software. Itanium
	is a trademark of Intel. Linux is a trademark of Linus Torvalds. Netscape is a trademark of AOL. PDF and
	PostScript are trademarks of Adobe, Inc. UNIX is a trademark of The Open Group.</p>

	<p>The photograph of Ken and Dennis in <a href="#historychapter"
		title="Chapter 2. History">Chapter 2</a> appears courtesy of Bell Labs/Lucent
		Technologies.
	</p>

	<p>The epigraph on the Portability chapter is from the Bell System Technical Journal, v57 #6 part 2 (July-Aug.
		1978) pp. 2021-2048 and is reproduced with the permission of Bell Labs/Lucent Technologies.</p>
</div>

<div class="dedication">
	<strong>Dedication</strong>
	<p>To Ken Thompson and Dennis Ritchie, because you inspired me.</p>
</div>

<div id="toc">
	<span id="toc-button" title="Press escape to toggle the TOC">»</span>
	<h2>Table of Contents</h2>
	<ol type="I" start="0">
		<li><a href="#preface">Preface</a><ol type="a">
			<li><a href="#pr01s01">Who Should Read This Book</a></li>
			<li><a href="#pr01s02">How to Use This Book</a></li>
			<li><a href="#pr01s03">Related References</a></li>
			<li><a href="#pr01s04">Conventions Used in This Book</a></li>
			<li><a href="#pr01s05">Our Case Studies</a></li>
			<li><a href="#pr01s06">Author's Acknowledgements</a></li>
		</ol></li>

		<li><a href="#context">Context</a><ol start="1">
			<li><a href="#philosophychapter">Philosophy</a><ol type="a">
				<li><a href="#ch01s01">Culture? What Culture?</a></li>
				<li><a href="#ch01s02">The Durability of Unix</a></li>
				<li><a href="#ch01s03">The Case against Learning Unix Culture</a></li>
				<li><a href="#ch01s04">What Unix Gets Wrong</a></li>
				<li><a href="#ch01s05">What Unix Gets Right</a><ol type="a">
					<li><a href="#id2808846">Open-Source Software</a></li>
					<li><a href="#id2872776">Cross-Platform Portability and Open Standards</a></li>
					<li><a href="#id2872827">The Internet and the World Wide Web</a></li>
					<li><a href="#id2872945">The Open-Source Community</a></li>
					<li><a href="#id2873031">Flexibility All the Way Down</a></li>
					<li><a href="#id2873078">Unix Is Fun to Hack</a></li>
					<li><a href="#id2873180">The Lessons of Unix Can Be Applied Elsewhere</a></li>
				</ol></li>
				<li><a href="#ch01s06">Basics of the Unix Philosophy</a><ol type="a">
					<li><a href="#id2877537">Rule of Modularity: Write simple parts connected by clean interfaces.</a></li>
					<li><a href="#id2877610">Rule of Clarity: Clarity is better than cleverness.</a></li>
					<li><a href="#id2877684">Rule of Composition: Design programs to be connected with other programs.</a></li>
					<li><a href="#id2877777">Rule of Separation: Separate policy from mechanism; separate interfaces from engines.</a></li>
					<li><a href="#id2877917">Rule of Simplicity: Design for simplicity; add complexity only where you must.</a></li>
					<li><a href="#id2878022">Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do.</a></li>
					<li><a href="#id2878054">Rule of Transparency: Design for visibility to make inspection and debugging easier.</a></li>
					<li><a href="#id2878145">Rule of Robustness: Robustness is the child of transparency and simplicity.</a></li>
					<li><a href="#id2878263">Rule of Representation: Fold knowledge into data, so program logic can be stupid and robust.</a></li>
					<li><a href="#id2878339">Rule of Least Surprise: In interface design, always do the least surprising thing.</a></li>
					<li><a href="#id2878450">Rule of Silence: When a program has nothing surprising to say, it should say nothing.</a></li>
					<li><a href="#id2878538">Rule of Repair: Repair what you can — but when you must fail, fail noisily and as soon as possible.</a></li>
					<li><a href="#id2878666">Rule of Economy: Programmer time is expensive; conserve it in preference to machine time.</a></li>
					<li><a href="#id2878742">Rule of Generation: Avoid hand-hacking; write programs to write programs when you can.</a></li>
					<li><a href="#rule_of_optimization">Rule of Optimization: Prototype before polishing. Get it working before you optimize it.</a></li>
					<li><a href="#id2879078">Rule of Diversity: Distrust all claims for one true way.</a></li>
					<li><a href="#id2879112">Rule of Extensibility: Design for the future, because it will be here sooner than you think.</a></li>
				</ol></li>
				<li><a href="#ch01s07">The Unix Philosophy in One Lesson</a></li>
				<li><a href="#ch01s08">Applying the Unix Philosophy</a></li>
				<li><a href="#ch01s09">Attitude Matters Too</a></li>
			</ol></li>

			<li><a href="#historychapter">History</a><ol type="a">
				<li><a href="#ch02s01">Origins and History of Unix, 1969-1995</a><ol type="a">
					<li><a href="#genesis">Genesis: 1969–1971</a></li>
					<li><a href="#id2879627">Exodus: 1971–1980</a></li>
					<li><a href="#id2880014">TCP/IP and the Unix Wars: 1980-1990</a></li>
					<li><a href="#id2886020">Blows against the Empire: 1991-1995</a></li>
					</ol></li>
				<li><a href="#hackers">Origins and History of the Hackers, 1961-1995</a><ol type="a">
					<li><a href="#id2886621">At Play in the Groves of Academe: 1961-1980</a></li>
					<li><a href="#id2886828">Internet Fusion and the Free Software Movement: 1981-1991</a></li>
					<li><a href="#linux_reaction">Linux and the Pragmatist Reaction: 1991-1998</a></li>
				</ol></li>
				<li><a href="#ch02s03">The Open-Source Movement: 1998 and Onward</a></li>
				<li><a href="#ch02s04">The Lessons of Unix History</a></li>
			</ol>

			<li><a href="#contrastchapter">Contrasts</a><ol type="a">
				<li><a href="#ch03s01">The Elements of Operating-System Style</a><ol type="a">
					<li><a href="#id2892028">What Is the Operating System's Unifying Idea?</a></li>
					<li><a href="#id2892085">Multitasking Capability</a></li>
					<li><a href="#id2892171">Cooperating Processes</a></li>
					<li><a href="#id2888136">Internal Boundaries</a></li>
					<li><a href="#id2888217">File Attributes and Record Structures</a></li>
					<li><a href="#id2888298">Binary File Formats</a></li>
					<li><a href="#id2888363">Preferred User Interface Style</a></li>
					<li><a href="#id2888484">Intended Audience</a></li>
					<li><a href="#id2888581">Entry Barriers to Development</a></li>
				</ol></li>
				<li><a href="#ch03s02">Operating-System Comparisons</a><ol type="a">
					<li><a href="#vms">VMS</a></li>
					<li><a href="#mac_os_contrast">MacOS</a></li>
					<li><a href="#os_2">OS/2</a></li>
					<li><a href="#nt_contrast">Windows NT</a></li>
					<li><a href="#beos">BeOS</a></li>
					<li><a href="#mvs">MVS</a></li>
					<li><a href="#id2893777">VM/CMS</a></li>
					<li><a href="#linux">Linux</a></li>
				</ol></li>
				<li><a href="#ch03s03">What Goes Around, Comes Around</a></li>
			</ol></li>
		</ol></li>

		<li><a href="#design">Design</a><ol start="4">
			<li><a href="#modularitychapter">Modularity</a><ol type="a">
				<li><a href="#ch04s01">Encapsulation and Optimal Module Size</a></li>
				<li><a href="#ch04s02">Compactness and Orthogonality</a><ol type="a">
					<li><a href="#compactness">Compactness</a></li>
					<li><a href="#orthogonality">Orthogonality</a></li>
					<li><a href="#spot_rule">The SPOT Rule</a></li>
					<li><a href="#id2895445">Compactness and the Strong Single Center</a></li>
					<li><a href="#id2899405">The Value of Detachment</a></li>
				</ol></li>
				<li><a href="#ch04s03">Software Is a Many-Layered Thing</a><ol type="a">
					<li><a href="#id2899552">Top-Down versus Bottom-Up</a></li>
					<li><a href="#id2899777">Glue Layers</a></li>
					<li><a href="#c_thin_glue">Case Study: C Considered as Thin Glue</a></li>
				</ol></li>
				<li><a href="#ch04s04">Libraries</a><ol type="a">
					<li><a href="#gimp_plugins">Case Study: GIMP Plugins</a></li>
				</ol></li>
				<li><a href="#unix_and_oo">Unix and Object-Oriented Languages</a></li>
				<li><a href="#ch04s06">Coding for Modularity</a></li>
			</ol></li>

			<li><a href="#textualitychapter">Textuality</a><ol type="a">
				<li><a href="#ch05s01">The Importance of Being Textual</a><ol type="a">
					<li><a href="#id2901332">Case Study: Unix Password File Format</a></li>
					<li><a href="#id2901494">Case Study: .newsrc Format</a></li>
					<li><a href="#png">Case Study: The PNG Graphics File Format</a></li>
				</ol></li>
				<li><a href="#ch05s02">Data File Metaformats</a><ol type="a">
					<li><a href="#id2901882">DSV Style</a></li>
					<li><a href="#id2902039">RFC 822 Format</a></li>
					<li><a href="#id2902164">Cookie-Jar Format</a></li>
					<li><a href="#id2906931">Record-Jar Format</a></li>
					<li><a href="#id2907018">XML</a></li>
					<li><a href="#id2907263">Windows INI Format</a></li>
					<li><a href="#id2907428">Unix Textual File Format Conventions</a></li>
					<li><a href="#id2907903">The Pros and Cons of File Compression</a></li>
				</ol></li>
				<li><a href="#ch05s03">Application Protocol Design</a><ol type="a">
					<li><a href="#id2908194">Case Study: SMTP, the Simple Mail Transfer Protocol</a></li>
					<li><a href="#id2908383">Case Study: POP3, the Post Office Protocol</a></li>
					<li><a href="#id2908582">Case Study: IMAP, the Internet Message Access Protocol</a></li>
				</ol></li>
				<li><a href="#ch05s04">Application Protocol Metaformats</a><ol type="a">
					<li><a href="#id2908835">The Classical Internet Application Metaprotocol</a></li>
					<li><a href="#id2908915">HTTP as a Universal Application Protocol</a></li>
					<li><a href="#id2909217">BEEP: Blocks Extensible Exchange Protocol</a></li>
					<li><a href="#id2909294">XML-RPC, SOAP, and Jabber</a></li>
				</ol></li>
			</ol></li>

			<li><a href="#transparencychapter">Transparency</a><ol type="a">
				<li><a href="#ch06s01">Studying Cases</a><ol type="a">
					<li><a href="#audacity">Case Study: audacity</a></li>
					<li><a href="#fetchmail_v">Case Study: fetchmail's -v option</a></li>
					<li><a href="#id2909841">Case Study: GCC</a></li>
					<li><a href="#id2909954">Case Study: kmail</a></li>
					<li><a href="#id2910193">Case Study: SNG</a></li>
					<li><a href="#id2910334">Case Study: The Terminfo Database</a></li>
					<li><a href="#id2914115">Case Study: Freeciv Data Files</a></li>
				</ol></li>
				<li><a href="#ch06s02">Designing for Transparency and Discoverability</a><ol type="a">
					<li><a href="#zen_of_transparency">The Zen of Transparency</a></li>
					<li><a href="#id2914509">Coding for Transparency and Discoverability</a></li>
					<li><a href="#id2914680">Transparency and Avoiding Overprotectiveness</a></li>
					<li><a href="#id2914758">Transparency and Editable Representations</a></li>
					<li><a href="#id2915107">Transparency, Fault Diagnosis, and Fault Recovery</a></li>
				</ol></li>
				<li><a href="#ch06s03">Designing for Maintainability</a></li>
			</ol></li>

			<li><a href="#multiprogramchapter">Multiprogramming</a><ol type="a">
				<li><a href="#ch07s01">Separating Complexity Control from Performance Tuning</a></li>
				<li><a href="#ch07s02">Taxonomy of Unix IPC Methods</a><ol type="a">
					<li><a href="#id2915475">Handing off Tasks to Specialist Programs</a></li>
					<li><a href="#plumbing">Pipes, Redirection, and Filters</a></li>
					<li><a href="#id2921506">Wrappers</a></li>
					<li><a href="#id2921634">Security Wrappers and Bernstein Chaining</a></li>
					<li><a href="#id2922002">Slave Processes</a></li>
					<li><a href="#id2922148">Peer-to-Peer Inter-Process Communication</a></li>
				</ol></li>
				<li><a href="#ch07s03">Problems and Methods to Avoid</a><ol type="a">
					<li><a href="#id2923376">Obsolescent Unix IPC Methods</a></li>
					<li><a href="#id2923675">Remote Procedure Calls</a></li>
					<li><a href="#id2923889">Threads — Threat or Menace?</a></li>
				</ol></li>
				<li><a href="#ch07s04">Process Partitioning at the Design Level</a></li>
			</ol></li>

			<li><a href="#minilanguageschapter">Minilanguages</a><ol type="a">
				<li><a href="#ch08s01">Understanding the Taxonomy of Languages</a></li>
				<li><a href="#ch08s02">Applying Minilanguages</a><ol type="a">
					<li><a href="#id2924747">Case Study: sng</a></li>
					<li><a href="#regexps">Case Study: Regular Expressions</a></li>
					<li><a href="#id2933450">Case Study: Glade</a></li>
					<li><a href="#id2933775">Case Study: m4</a></li>
					<li><a href="#id2934034">Case Study: XSLT</a></li>
					<li><a href="#id2934197">Case Study: The Documenter's Workbench Tools</a></li>
					<li><a href="#fetchmailrc">Case Study: fetchmail Run-Control Syntax</a></li>
					<li><a href="#awk">Case Study: awk</a></li>
					<li><a href="#id2935613">Case Study: PostScript</a></li>
					<li><a href="#id2935779">Case Study: bc and dc</a></li>
					<li><a href="#emacs_lisp_study">Case Study: Emacs Lisp</a></li>
					<li><a href="#javascript">Case Study: JavaScript</a></li>
				</ol></li>
				<li><a href="#ch08s03">Designing Minilanguages</a><ol type="a">
					<li><a href="#id2936413">Choosing the Right Complexity Level</a></li>
					<li><a href="#id2936650">Extending and Embedding Languages</a></li>
					<li><a href="#id2936912">Writing a Custom Grammar</a></li>
					<li><a href="#macroexpansion">Macros — Beware!</a></li>
					<li><a href="#id2937424">Language or Application Protocol?</a></li>
				</ol></li>
			</ol></li>

			<li><a href="#generationchapter">Generation</a><ol type="a">
				<li><a href="#ch09s01">Data-Driven Programming</a><ol type="a">
					<li><a href="#id2939746">Case Study: ascii</a></li>
					<li><a href="#bayes_spam">Case Study: Statistical Spam Filtering</a></li>
					<li><a href="#fetchmailconf">Case Study: Metaclass Hacking in fetchmailconf</a></li>
				</ol></li>
				<li><a href="#ch09s02">Ad-hoc Code Generation</a><ol type="a">
					<li><a href="#id2938615">Case Study: Generating Code for the ascii Displays</a></li>
					<li><a href="#htmlgen">Case Study: Generating HTML Code for a Tabular List</a></li>
				</ol></li>
			</ol></li>

			<li><a href="#configurationchapter">Configuration</a><ol type="a">
				<li><a href="#ch10s01">What Should Be Configurable?</a></li>
				<li><a href="#ch10s02">Where Configurations Live</a></li>
				<li><a href="#ch10s03">Run-Control Files</a><ol type="a">
					<li><a href="#id2942210">Case Study: The .netrc File</a></li>
					<li><a href="#id2942358">Portability to Other Operating Systems</a></li>
				</ol></li>
				<li><a href="#ch10s04">Environment Variables</a><ol type="a">
					<li><a href="#id2942463">System Environment Variables</a></li>
					<li><a href="#id2942749">User Environment Variables</a></li>
					<li><a href="#id2942882">When to Use Environment Variables</a></li>
					<li><a href="#id2947980">Portability to Other Operating Systems</a></li>
				</ol></li>
				<li><a href="#ch10s05">Command-Line Options</a><ol type="a">
					<li><a href="#id2948149">The -a to -z of Command-Line Options</a></li>
					<li><a href="#id2950162">Portability to Other Operating Systems</a></li>
				</ol></li>
				<li><a href="#ch10s06">How to Choose among the Methods</a><ol type="a">
					<li><a href="#fetchmail_environment">Case Study: fetchmail</a></li>
					<li><a href="#id2950578">Case Study: The XFree86 Server</a></li>
				</ol></li>
				<li><a href="#ch10s07">On Breaking These Rules</a></li>
			</ol></li>

			<li><a href="#interfacechapter">Interfaces</a><ol type="a">
				<li><a href="#ch11s01">Applying the Rule of Least Surprise</a></li>
				<li><a href="#ch11s02">History of Interface Design on Unix</a></li>
				<li><a href="#ch11s03">Evaluating Interface Designs</a><ol type="a">
				<li><a href="#ch11s04">Tradeoffs between CLI and Visual Interfaces</a></li>
					<li><a href="#id2951734">Case Study: Two Ways to Write a Calculator Program</a></li>
				</ol></li>
				<li><a href="#ch11s05">Transparency, Expressiveness, and Configurability</a></li>
				<li><a href="#ch11s06">Unix Interface Design Patterns</a><ol type="a">
					<li><a href="#id2957637">The Filter Pattern</a></li>
					<li><a href="#id2957916">The Cantrip Pattern</a></li>
					<li><a href="#id2958032">The Source Pattern</a></li>
					<li><a href="#id2958116">The Sink Pattern</a></li>
					<li><a href="#id2958199">The Compiler Pattern</a></li>
					<li><a href="#id2958336">The ed pattern</a></li>
					<li><a href="#id2958491">The Roguelike Pattern</a></li>
					<li><a href="#id2958899">The ‘Separated Engine and Interface’ Pattern</a></li>
					<li><a href="#id2959821">The CLI Server Pattern</a></li>
					<li><a href="#id2959928">Language-Based Interface Patterns</a></li>
				</ol></li>
				<li><a href="#ch11s07">Applying Unix Interface-Design Patterns</a><ol type="a">
					<li><a href="#id2960228">The Polyvalent-Program Pattern</a></li>
				</ol></li>
				<li><a href="#ch11s08">The Web Browser as a Universal Front End</a></li>
				<li><a href="#ch11s09">Silence Is Golden</a></li>
			</ol></li>

			<li><a href="#optimizationchapter">Optimization</a><ol type="a">
				<li><a href="#ch12s01">Don't Just Do Something, Stand There!</a></li>
				<li><a href="#ch12s02">Measure before Optimizing</a></li>
				<li><a href="#ch12s03">Nonlocality Considered Harmful</a></li>
				<li><a href="#ch12s04">Throughput vs. Latency</a><ol type="a">
					<li><a href="#id2961306">Batching Operations</a></li>
					<li><a href="#id2961372">Overlapping Operations</a></li>
					<li><a href="#binary_caches">Caching Operation Results</a></li>
				</ol></li>
			</ol></li>

			<li><a href="#complexitychapter">Complexity</a><ol type="a">
				<li><a href="#ch13s01">Speaking of Complexity</a><ol type="a">
					<li><a href="#id2964646">The Three Sources of Complexity</a></li>
					<li><a href="#id2964843">Tradeoffs between Interface and Implementation Complexity</a></li>
					<li><a href="#id2961759">Essential, Optional, and Accidental Complexity</a></li>
					<li><a href="#id2961870">Mapping Complexity</a></li>
					<li><a href="#id2963237">When Simplicity Is Not Enough</a></li>
				</ol></li>
				<li><a href="#ch13s02">A Tale of Five Editors</a><ol type="a">
					<li><a href="#id2963445">ed</a></li>
					<li><a href="#vi_complexity">vi</a></li>
					<li><a href="#id2963798">Sam</a></li>
					<li><a href="#emacs_editing">Emacs</a></li>
					<li><a href="#id2967110">Wily</a></li>
				</ol></li>
				<li><a href="#ch13s03">The Right Size for an Editor</a><ol type="a">
					<li><a href="#id2967267">Identifying the Complexity Problems</a></li>
					<li><a href="#id2967642">Compromise Doesn't Work</a></li>
					<li><a href="#id2967765">Is Emacs an Argument against the Unix Tradition?</a></li>
				</ol></li>
				<li><a href="#ch13s04">The Right Size of Software</a></li>
			</ol></li>
		</ol></li>

		<li><a href="#implementation">Implementation</a><ol start="14">
			<li><a href="#languageschapter">Languages</a><ol type="a">
				<li><a href="#ch14s01">Unix's Cornucopia of Languages</a></li>
				<li><a href="#why_not_c">Why Not C?</a></li>
				<li><a href="#ch14s03">Interpreted Languages and Mixed Strategies</a></li>
				<li><a href="#ch14s04">Language Evaluations</a><ol type="a">
					<li><a href="#c_language">C</a></li>
					<li><a href="#cc_language">C++</a></li>
					<li><a href="#sh">Shell</a></li>
					<li><a href="#perl">Perl</a></li>
					<li><a href="#tcl">Tcl</a></li>
					<li><a href="#python_language">Python</a></li>
					<li><a href="#java">Java</a></li>
					<li><a href="#emacs_lisp_language">Emacs Lisp</a></li>
				</ol></li>
				<li><a href="#ch14s05">Trends for the Future</a></li>
				<li><a href="#ch14s06">Choosing an X Toolkit</a></li>
			</ol></li>

			<li><a href="#toolschapter">Tools</a><ol type="a">
				<li><a href="#ch15s01">A Developer-Friendly Operating System</a></li>
				<li><a href="#ch15s02">Choosing an Editor</a><ol type="a">
					<li><a href="#vi_literacy">Useful Things to Know about vi</a></li>
					<li><a href="#id2979540">Useful Things to Know about Emacs</a></li>
					<li><a href="#id2979678">The Antireligious Choice: Using Both</a></li>
				</ol></li>
				<li><a href="#ch15s03">Special-Purpose Code Generators</a><ol type="a">
					<li><a href="#id2979797">yacc and lex</a></li>
					<li><a href="#id2986324">Case Study: Glade</a></li>
				</ol></li>
				<li><a href="#ch15s04">make: Automating Your Recipes</a><ol type="a">
					<li><a href="#id2986550">Basic Theory of make</a></li>
					<li><a href="#id2986902">make in Non-C/C++ Development</a></li>
					<li><a href="#id2987148">Utility Productions</a></li>
					<li><a href="#id2987644">Generating Makefiles</a></li>
				</ol></li>
				<li><a href="#ch15s05">Version-Control Systems</a><ol type="a">
					<li><a href="#id2988357">Why Version Control?</a></li>
					<li><a href="#id2988464">Version Control by Hand</a></li>
					<li><a href="#id2988503">Automated Version Control</a></li>
					<li><a href="#id2988625">Unix Tools for Version Control</a></li>
				</ol></li>
				<li><a href="#ch15s06">Runtime Debugging</a></li>
				<li><a href="#ch15s07">Profiling</a></li>
				<li><a href="#ch15s08">Combining Tools with Emacs</a><ol type="a">
					<li><a href="#id2989559">Emacs and make</a></li>
					<li><a href="#id2989677">Emacs and Runtime Debugging</a></li>
					<li><a href="#id2989781">Emacs and Version Control</a></li>
					<li><a href="#id2989869">Emacs and Profiling</a></li>
					<li><a href="#id2989926">Like an IDE, Only Better</a></li>
				</ol></li>
			</ol></li>

			<li><a href="#reusechapter">Reuse</a><ol type="a">
				<li><a href="#ch16s01">The Tale of J. Random Newbie</a></li>
				<li><a href="#ch16s02">Transparency as the Key to Reuse</a></li>
				<li><a href="#ch16s03">From Reuse to Open Source</a></li>
				<li><a href="#ch16s04">The Best Things in Life Are Open</a></li>
				<li><a href="#ch16s05">Where to Look?</a></li>
				<li><a href="#ch16s06">Issues in Using Open-Source Software</a></li>
				<li><a href="#ch16s07">Licensing Issues</a><ol type="a">
					<li><a href="#id2991059">What Qualifies as Open Source</a></li>
					<li><a href="#id2993547">Standard Open-Source Licenses</a></li>
					<li><a href="#id2993874">When You Need a Lawyer</a></li>
				</ol></li>
			</ol></li>
		</ol></li>

		<li><a href="#community">Community</a><ol start="17">
			<li><a href="#portabilitychapter">Portability</a><ol type="a">
				<li><a href="#c_evolution">Evolution of C</a><ol type="a">
					<li><a href="#id2998213">Early History of C</a></li>
					<li><a href="#id2994334">C Standards</a></li>
				</ol></li>
				<li><a href="#ch17s02">Unix Standards</a><ol type="a">
					<li><a href="#id2994594">Standards and the Unix Wars</a></li>
					<li><a href="#id2999310">The Ghost at the Victory Banquet</a></li>
					<li><a href="#id2999366">Unix Standards in the Open-Source World</a></li>
				</ol></li>
				<li><a href="#ietf_process">IETF and the RFC Standards Process</a></li>
				<li><a href="#ch17s04">Specifications as DNA, Code as RNA</a></li>
				<li><a href="#ch17s05">Programming for Portability</a><ol type="a">
					<li><a href="#id3000303">Portability and Choice of Language</a></li>
					<li><a href="#id3000882">Avoiding System Dependencies</a></li>
					<li><a href="#id3000984">Tools for Portability</a></li>
				</ol></li>
				<li><a href="#ch17s06">Internationalization</a></li>
				<li><a href="#ch17s07">Portability, Open Standards, and Open Source</a></li>
			</ol></li>

			<li><a href="#documentationchapter">Documentation</a><ol type="a">
				<li><a href="#ch18s01">Documentation Concepts</a></li>
				<li><a href="#ch18s02">The Unix Style</a><ol type="a">
					<li><a href="#id3001392">The Large-Document Bias</a></li>
					<li><a href="#id3001522">Cultural Style</a></li>
				</ol></li>
				<li><a href="#ch18s03">The Zoo of Unix Documentation Formats</a><ol type="a">
					<li><a href="#id3001604">troff and the Documenter's Workbench Tools</a></li>
					<li><a href="#id3001898">TeX</a></li>
					<li><a href="#id3002206">Texinfo</a></li>
					<li><a href="#id3002268">POD</a></li>
					<li><a href="#id3002291">HTML</a></li>
					<li><a href="#id3002310">DocBook</a></li>
				</ol></li>
				<li><a href="#ch18s04">The Present Chaos and a Possible Way Out</a></li>
				<li><a href="#ch18s05">DocBook</a><ol type="a">
					<li><a href="#id3006015">Document Type Definitions</a></li>
					<li><a href="#id3006182">Other DTDs</a></li>
					<li><a href="#db_toolchain">The DocBook Toolchain</a></li>
					<li><a href="#id3006742">Migration Tools</a></li>
					<li><a href="#id3007022">Editing Tools</a></li>
					<li><a href="#id3007143">Related Standards and Practices</a></li>
					<li><a href="#id3007192">SGML</a></li>
					<li><a href="#id3007297">XML-DocBook References</a></li>
				</ol></li>
				<li><a href="#ch18s06">Best Practices for Writing Unix Documentation</a></li>
			</ol></li>

			<li><a href="#opensourcechapter">Open Source</a><ol type="a">
				<li><a href="#ch19s01">Unix and Open Source</a></li>
				<li><a href="#ch19s02">Best Practices for Working with Open-Source Developers</a><ol type="a">
					<li><a href="#patching">Good Patching Practice</a></li>
					<li><a href="#naming">Good Project- and Archive-Naming Practice</a></li>
					<li><a href="#develpractice">Good Development Practice</a></li>
					<li><a href="#distpractice">Good Distribution-Making Practice</a></li>
					<li><a href="#communication">Good Communication Practice</a></li>
				</ol></li>
				<li><a href="#ch19s03">The Logic of Licenses: How to Pick One</a></li>
				<li><a href="#ch19s04">Why You Should Use a Standard License</a></li>
				<li><a href="#ch19s05">Varieties of Open-Source Licensing</a><ol type="a">
					<li><a href="#id3014860">MIT or X Consortium License</a></li>
					<li><a href="#id3014890">BSD Classic License</a></li>
					<li><a href="#id3014963">Artistic License</a></li>
					<li><a href="#id3015011">General Public License</a></li>
					<li><a href="#id3015063">Mozilla Public License</a></li>
				</ol></li>
			</ol></li>

			<li><a href="#futurechapter">Futures</a><ol type="a">
				<li><a href="#ch20s01">Essence and Accident in Unix Tradition</a></li>
				<li><a href="#plan9">Plan 9: The Way the Future Was</a></li>
				<li><a href="#ch20s03">Problems in the Design of Unix</a><ol type="a">
					<li><a href="#id3015538">A Unix File Is Just a Big Bag of Bytes</a></li>
					<li><a href="#id3015724">Unix Support for GUIs Is Weak</a></li>
					<li><a href="#id3015838">File Deletion Is Forever</a></li>
					<li><a href="#id3015895">Unix Assumes a Static File System</a></li>
					<li><a href="#id3015943">The Design of Job Control Was Badly Botched</a></li>
					<li><a href="#id3016077">The Unix API Doesn't Use Exceptions</a></li>
					<li><a href="#id3016155">ioctl2 and fcntl2 Are an Embarrassment</a></li>
					<li><a href="#id3019078">The Unix Security Model May Be Too Primitive</a></li>
					<li><a href="#id3019113">Unix Has Too Many Different Kinds of Names</a></li>
					<li><a href="#id3019140">File Systems Might Be Considered Harmful</a></li>
					<li><a href="#id3019193">Towards a Global Internet Address Space</a></li>
				</ol></li>
				<li><a href="#ch20s04">Problems in the Environment of Unix</a></li>
				<li><a href="#ch20s05">Problems in the Culture of Unix</a></li>
				<li><a href="#ch20s06">Reasons to Believe</a>
			</ol></li>
		</ol></li>

		<li>Appendix<ol type="A">
			<li><a href="#apa">Glossary of Abbreviations</a></li>
			<li><a href="#apb">References</a></li>
			<li><a href="#apc">Contributors</a></li>
			<li><a href="#revhistory">Revision History</a></li>
			<li><a href="#unix_koans">Rootless Root</a><ol type="a">
				<li><a href="#introduction">Editor's Introduction</a></li>
				<li><a href="#ten-thousand">Master Foo and the Ten Thousand Lines</a></li>
				<li><a href="#script-kiddie">Master Foo and the Script Kiddie</a></li>
				<li><a href="#two_paths">Master Foo Discourses on the Two Paths</a></li>
				<li><a href="#methodology-consultant">Master Foo and the Methodologist</a></li>
				<li><a href="#gui-programmer">Master Foo Discourses on the Graphical User Interface</a></li>
				<li><a href="#zealot">Master Foo and the Unix Zealot</a></li>
				<li><a href="#unix-nature">Master Foo Discourses on the Unix-Nature</a></li>
				<li><a href="#end-user">Master Foo and the End User</a></li>
			</ol></li>
		</ol></li>
	</ol>
</div>


<!-- FILE: preface.html -->
 <div class="preface">
  <h3 id="preface"><a href="#preface">§</a>Preface</h3>
  <blockquote class="epigraph">
   <p>
    Unix is not so much an operating system as an oral history.
   </p>
   <span>
    – Neal Stephenson
   </span>
  </blockquote>
  <p>
   There is a vast difference between knowledge and expertise.
Knowledge lets you deduce the right thing to do; expertise makes the
right thing a reflex, hardly requiring conscious thought at
all.
  </p>
  <p>
   This book has a lot of knowledge in it, but it is mainly about
expertise. It is going to try to teach you the things about Unix
development that Unix experts know, but aren't aware that they
know. It is therefore less about technicalia and more about
   <em>shared culture</em>
   than most Unix books — both
explicit and implicit culture, both conscious and unconscious
traditions.  It is not a ‘how-to’ book, it is a
‘why-to’ book.
  </p>
  <p>
   The why-to has great practical importance, because far too much
software is poorly designed.  Much of it suffers from bloat, is
exceedingly hard to maintain, and is too difficult to port to new
platforms or extend in ways the original programmers didn't
anticipate.  These problems are symptoms of bad design.  We hope that
readers of this book will learn something of what Unix has to teach
about good design.
  </p>
  <p>
   This book is divided into four parts: Context, Design, Tools,
and Community.  The first part (Context) is philosophy and history, to
help provide foundation and motivation for what follows.  The second
part (Design) unfolds the principles of the Unix philosophy into more
specific advice about design and implementation.  The third part
(Tools) focuses on the software Unix provides for helping you solve
problems.  The fourth part (Community) is about the human-to-human
transactions and agreements that make the Unix culture so effective at
what it does.
  </p>
  <p>
   Because this is a book about shared culture, I never planned to
write it alone.  You will notice that the text includes guest
appearances by prominent Unix developers, the shapers of the Unix
tradition.  The book went through an extended public review process
during which I invited these luminaries to comment on and argue with
the text.  Rather than submerging the results of that review process
in the final version, these guests were encouraged to speak with their
own voices, amplifying and developing and even disagreeing with the
main line of the text.
  </p>
  <p>
   In this book, when I use the editorial ‘we’ it is
not to pretend omniscience but to reflect the fact that it attempts to
articulate the expertise of an entire community.
  </p>
  <p>
   Because this book is aimed at transmitting culture, it includes
much more in the way of history and folklore and asides than is normal
for a technical book. Enjoy; these things, too, are part of your
education as a Unix programmer.  No single one of the historical
details is vital, but the gestalt of them all is important.  We think
it makes a more interesting story this way.  More
importantly, understanding where Unix came from and how it got the
way it is will help you develop an intuitive feel for the Unix
style.
  </p>
  <p>
   For the same reason, we refuse to write as if history is over.
You will find an unusually large number of references to the time of
writing in this book.  We do not wish to pretend that current practice
reflects some sort of timeless and perfectly logical outcome of
preordained destiny. References to time of writing are meant as an
alert to the reader two or three or five years hence that the
associated statements of fact may have become dated and should be
double-checked.
  </p>
  <p>
   Other things this book is not is neither a C tutorial, nor a
guide to the Unix commands and API. It is not a reference for
   <em>sed</em> or <em>yacc</em> or
Perl or Python. It's not a network programming primer, nor an
exhaustive guide to the mysteries of X.  It's not a tour of Unix's
internals and architecture, either. Other books cover these specifics
better, and this book points you at them as appropriate.
  </p>
  <p>
   Beyond all these technical specifics, the Unix culture has an
unwritten engineering tradition that has developed over literally
millions of man-years<sup><a href="#ftn.id2871746" id="id2871746">[1]</a></sup>
   of skilled effort. This
book is written in the belief that understanding that tradition, and
adding its design patterns to your toolkit, will help you become a
better programmer and designer.
  </p>
  <p>
   Cultures consist of people, and the traditional way to learn
Unix culture is from other people and through the folklore, by
osmosis.  This book is not a substitute for person-to-person
acculturation, but it can help accelerate the process by allowing you
to tap the experience of others.
  </p>
 </div>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2871746" id="ftn.id2871746">[1]</a></sup>
  The three and a half decades
between 1969 and 2003 is a long time.  Going by the historical
trend curve in number of Unix sites during that period, probably
somewhere upwards of fifty million man-years have been plowed into
Unix development worldwide.
</p>
</div>


<!-- FILE: pr01s01.html -->
<h3 id="pr01s01"><a href="#pr01s01">§</a>Who Should Read This Book</h3>
<p>
  You should read this book if you are an experienced Unix
programmer who is often in the position of either educating novice
programmers or debating partisans of other operating systems, and you
find it hard to articulate the benefits of the Unix approach.
</p>
<p>
  You should read this book if you are a C, C++, or Java
programmer with experience on other operating systems and you are
about to start a Unix-based project.
</p>
<p>
  You should read this book if you are a Unix user with
novice-level up to middle-level skills in the operating system, but
little development experience, and want to learn how to design
software effectively under Unix.
</p>
<p>
  You should read this book if you are a non-Unix programmer who
has figured out that the Unix tradition might have something to
teach you. We believe you're right, and that the Unix philosophy can
be exported to other operating systems. So we will pay more
attention to non-Unix environments (especially Microsoft operating
systems) than is usual in a Unix book; and when tools and case
studies are portable, we say so.
</p>
<p>
  You should read this book if you are an application architect
considering platforms or implementation strategies for a major
general-market or vertical application.  It will help you
understand the strengths of Unix as a development platform, and
of the Unix tradition of open source as a development method.
</p>
<p>
  You should <em>not</em> read this book if what you
are looking for is the details of C coding or how to use the Unix
kernel API.  There are many good books on these topics;
  <em>Advanced Programming in the Unix Environment</em> <sup><a href="#Stevens92" title="[Stevens92]">[Stevens92]</a></sup>
  is classic among explorations of the Unix
API, and
  <em>The Practice of Programming</em> <sup><a href="#Kernighan-Pike99" title="[Kernighan-Pike99]">[Kernighan-Pike99]</a></sup>
  is recommended reading for all C programmers (indeed for all programmers in any language).
</p>



<!-- FILE: pr01s02.html -->
<h3 id="pr01s02"><a href="#pr01s02">§</a>How to Use This Book</h3>
<p>
  This book is both practical and philosophical. Some parts are
aphoristic and general, others will examine specific case studies in
Unix development. We will precede or follow general principles and
aphorisms with examples that illustrate them: examples drawn not from
toy demonstration programs but rather from real working code that is
in use every day.
</p>
<p>
  We have deliberately avoided filling the book with lots of code
or specification-file examples, even though in many places this
might have made it easier to write (and in some places perhaps
easier to read!). Most books about programming give too many
low-level details and examples, but fail at giving the reader a
high-level feel for what is really going on. In this book, we
prefer to err in the opposite direction.
</p>
<p>
  Therefore, while you will often be invited to read code and
specification files, relatively few are actually included in the book.
Instead, we point you at examples on the Web.
</p>
<p>
  Absorbing these examples will help solidify the principles you
learn into semi-instinctive working knowledge. Ideally, you should
read this book near the console of a running Unix system, with a Web
browser handy. Any Unix will do, but the software case studies are
more likely to be preinstalled and immediately available for
inspection on a Linux system. The pointers in the book are invitations
to browse and experiment. Introduction of these pointers is paced so
that wandering off to explore for a while won't break up exposition
that has to be continuous.
</p>
<p>
  Note: While we have made every effort to cite URLs that should
remain stable and usable, there is no way we can guarantee this. If
you find that a cited link has gone stale, use common sense and do
a phrase search with your favorite Web search engine. Where possible
we suggest ways to do this near the URLs we cite.
</p>
<p>
  Most abbreviations used in this book are expanded at first use.
For convenience, we have also provided a glossary in an appendix.
</p>
<p>
  References are usually by author name.  Numbered footnotes are
for URLs that would intrude on the text or that we suspect might be
perishable; also for asides, war stories, and jokes.<sup><a href="#ftn.id2807786" id="id2807786">[2]</a></sup>
</p>
<p>
  To make this book more accessible to less technical readers, we
invited some non-programmers to read it and identify terms that seemed
both obscure and necessary to the flow of exposition.  We also use
footnotes for definitions of elementary terms that an experienced
programmer is unlikely to need.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2807786" id="ftn.id2807786">[2]</a></sup>
  This particular footnote is dedicated to Terry Pratchett, whose
use of footnotes is quite...inspiring.
</p>
</div>


<!-- FILE: pr01s03.html -->
<h3 id="pr01s03"><a href="#pr01s03">§</a>Related References</h3>
<p>
  Some famous papers and a few books by Unix's early developers
have mined this territory before. Kernighan and Pike's
  <em>The Unix Programming Environment</em> <sup><a href="#Kernighan-Pike84" title="[Kernighan-Pike84]">[Kernighan-Pike84]</a></sup> stands out
among these and is rightly considered a classic. But today it shows
its age a bit; it doesn't cover the Internet, and the World Wide Web
or the new wave of interpreted languages like Perl, Tcl, and
Python.
</p>
<p>
  About halfway into the composition of this book, we learned of
Mike Gancarz's
  <em>The Unix Philosophy</em> <sup><a href="#Gancarz" title="[Gancarz]">[Gancarz]</a></sup>.  This book is excellent within its
range, but did not attempt to cover the full spectrum of topics we
felt needed to be addressed.  Nevertheless we are grateful to the
author for the reminder that the very simplest Unix design patterns
have been the most persistent and successful ones.
</p>
<p>
  <em>The Pragmatic Programmer</em> <sup><a href="#Hunt-Thomas" title="[Hunt-Thomas]">[Hunt-Thomas]</a></sup> is a witty and wise
disquisition on good design practice pitched at a slightly
different level of the software-design craft (more about coding, less
about higher-level partitioning of problems) than this book. The
authors' philosophy is an outgrowth of Unix experience, and it is an
excellent complement to this book.
</p>
<p>
  <em>The Practice of Programming</em> <sup><a href="#Kernighan-Pike99" title="[Kernighan-Pike99]">[Kernighan-Pike99]</a></sup> covers some of
the same ground as
  <em>The Pragmatic Programmer</em> from a position deep within the Unix tradition.
</p>
<p>
  Finally (and with admitted intent to provoke) we recommend
  <em>Zen Flesh, Zen Bones</em> <sup><a href="#Reps-Senzaki" title="[Reps-Senzaki]">[Reps-Senzaki]</a></sup>, an important collection of
Zen Buddhist primary sources.  References to Zen are scattered throughout
this book.  They are included because Zen provides a vocabulary for
addressing some ideas that turn out to be very important for software
design but are otherwise very difficult to hold in the mind.  Readers
with religious attachments are invited to consider Zen not as a
religion but as a therapeutic form of mental discipline — which,
in its purest non-theistic forms, is exactly what Zen is.
</p>



<!-- FILE: pr01s04.html -->
<h3 id="pr01s04"><a href="#pr01s04">§</a>Conventions Used in This Book</h3>
<p>
  The term “UNIX” is technically and legally a
trademark of The Open Group, and should formally be used only for
operating systems which are certified to have passed The Open Group's
elaborate standards-conformance tests. In this book we use
“Unix” in the looser sense widely current among
programmers, to refer to any operating system (whether formally
Unix-branded or not) that is either genetically descended from Bell
Labs's ancestral Unix code or written in close imitation of its
descendants. In particular, Linux (from which we draw most of our
examples) is a Unix under this definition.
</p>
<p>
  This book employs the Unix manual page convention of tagging
Unix facilities with a following manual section in parentheses,
usually on first introduction when we want to emphasize that this is a
Unix command.  Thus, for example, read “munger(1)” as
“the ‘munger’ program, which will be documented in
section 1 (user tools) of the Unix manual pages, if it's present on
your system”. Section 2 is C system calls, section 3 is C
library calls, section 5 is file formats and protocols, section 8 is
system administration tools. Other sections vary among Unixes but
are not cited in this book.  For more, type
  <code>man 1 man</code> at your Unix shell prompt (older System V Unixes may
require <code>man -s 1 man </code>).
</p>
<p>
  Sometimes we mention a Unix application (such as
  <em>Emacs</em>), without a manual-section suffix and
capitalized.  This is a clue that the name actually represents a
well-established family of Unix programs with essentially the same
function, and we are discussing generic properties of all of them.
  <em>Emacs</em>, for example, includes
  <em>xemacs</em>.
</p>
<p>
  At various points later in this book we refer to
‘old school’ and ‘new school’ methods.  As
with rap music, new-school starts about 1990.  In this context, it's
associated with the rise of scripting
languages, GUIs, open-source Unixes, and the
Web.  Old-school refers to the pre-1990 (and especially pre-1985)
world of expensive (shared) computers, proprietary Unixes, scripting
in shell, and C everywhere.  This difference is worth pointing out
because cheaper and less memory-constrained machines have wrought some
significant changes on the Unix programming style.
</p>



<!-- FILE: pr01s05.html -->
<h3 id="pr01s05"><a href="#pr01s05">§</a>Our Case Studies</h3>
<p>
  A lot of books on programming rely on toy examples constructed
specifically to prove a point. This one won't. Our case studies
will be real, pre-existing pieces of software that are in
production use every day. Here are some of the major ones:
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term"><em>cdrtools</em> / <em>xcdroast</em></span>
   </dt>
   <dd>
    <p>
     These two separate projects are usually used together.
The <em>cdrtools</em> package is a set of CLI tools for writing CD-ROMs; Web search for “cdrtools”.
The <em>xcdroast</em> application is a GUI front end for cdrtools; see the
     <a href="http://www.xcdroast.org/">
      xcdroast project site</a>.
    </p>
   </dd>
   <dt>
    <span class="term">
     <em>fetchmail</em> </span>
   </dt>
   <dd>
    <p>
     The
     <em>fetchmail</em> program
retrieves mail from remote-mail servers using the POP3 or IMAP
post-office protocols. See the
     <a href="http://www.catb.org/~esr/fetchmail">
      fetchmail home page</a>
     (or search for
“fetchmail” on the Web).
    </p>
   </dd>
   <dt>
    <span class="term">
     <em>GIMP</em> </span>
   </dt>
   <dd>
    <p>
     The
     <em>GIMP</em> (GNU Image
Manipulation Program) is a full-featured paint, draw, and
image-manipulation program that can edit a huge variety of graphical
formats in sophisticated ways. Sources are available from the
     <a href="http://www.gimp.org/">
      GIMP home page</a>
     (or search for
"GIMP" on the Web).
    </p>
   </dd>
   <dt>
    <span class="term">
     <em>mutt</em> </span>
   </dt>
   <dd>
    <p>
     The
     <em>mutt</em> mail user agent is the current
best-of-breed among text-based Unix electronic mail agents, with notably good
support for MIME
     (Multipurpose Internet Mail Extensions) and the use of privacy aids
such as PGP (Pretty Good Privacy) and GPG (GNU Privacy Guard).  Source
code and executable binaries are available at the
     <a href="http://www.mutt.org">
      Mutt project site</a>.
    </p>
   </dd>
   <dt>
    <span class="term">
     <em>xmlto</em> </span>
   </dt>
   <dd>
    <p>
     The
     <em>xmlto</em> command renders
DocBook and other XML documents in various output formats, including
HTML and text and PostScript.  For sources and documentation, see the
     <a href="http://cyberelk.net/tim/xmlto/">
      xmlto project site</a>.
    </p>
   </dd>
  </dl>
 </div>
<p>
  To minimize the amount of code the user needs to read to
understand the examples, we have tried to choose case studies that can
be used more than once, ideally to illustrate several different design
principles and practices.  For this same reason, many of the examples
are from my projects.  No claim that these are the best possible ones
is implied, merely that I find them sufficiently familiar to be useful
for multiple expository purposes.
</p>



<!-- FILE: pr01s06.html -->
<h3 id="pr01s06"><a href="#pr01s06">§</a>Author's Acknowledgements</h3>
<p>
  The guest contributors (Ken Arnold, Steven M. Bellovin, Stuart
Feldman, Jim Gettys, Steve Johnson, Brian Kernighan, David Korn, Mike
Lesk, Doug McIlroy, Marshall Kirk McKusick, Keith Packard, Henry
Spencer, and Ken Thompson) added a great deal of value to this
book. Doug McIlroy, in particular, went far beyond the call of duty in
the thoroughness of his critique and the depth of his contributions,
displaying the same care and dedication to excellence which he brought
to managing the original Unix research group thirty years ago.
</p>
<p>
  Special thanks go to Rob Landley and to my wife Catherine
Raymond, both of whom delivered intensive line-by-line critiques of
manuscript drafts.  Rob's insightful and attentive commentary actually
inspired more than one entire chapter in the final manuscript, and he
had a lot to do with its present organization and range; if he had
written all the text he pushed me to improve, I would have to call him
a co-author. Cathy was my test audience representing non-technical
readers; to the extent this book is accessible to people who aren't
already programmers, that's largely her doing.
</p>
<p>
  This book benefited from discussions with many other people over
the five years it took me to write it. Mark M. Miller helped me
achieve enlightenment about threads. John Cowan supplied some insights
about interface design patterns and drafted the case studies of
  <em>wily</em> and VM/CMS, and Jef Raskin showed me
where the Rule of Least Surprise comes from. The UIUC System
Architecture Group contributed useful feedback on early chapters. The
sections on
  <em>What Unix Gets Wrong</em> and
  <em>Flexibility in Depth</em> were directly inspired by
their review. Russell J. Nelson contributed the material on Bernstein
chaining in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">Chapter 7</a>.
Jay Maynard contributed most of the material in the MVS case study in
  <a href="#contrastchapter" title="Chapter 3. Contrasts">
   Chapter 3</a>.  Les Hatton provided many helpful
comments on the <em>Languages</em> chapter and motivated
the portion of <a href="#modularitychapter" title="Chapter 4. Modularity">Chapter 4</a> on <em>Optimal Module Size</em>.
  David A. Wheeler contributed many perceptive criticisms and some case-study material, especially in the Design part.
  Russ Cox helped develop the survey of Plan 9. Dennis Ritchie corrected me on some historical points about C.
</p>
<p>
  Hundreds of Unix programmers, far too many to list here,
contributed advice and comments during the book's public review period
between January and June of 2003.  As always, I found the process of
open peer review over the Web both intensely challenging and intensely
rewarding.  Also as always, responsibility for any errors in the
resulting work remains my own.
</p>
<p>
  The expository style and some of the concerns of this book have
been influenced by the design patterns
  movement; indeed, I flirted with the
idea of titling the book
  <em>Unix Design Patterns</em>. I didn't, because I disagree with some of the
implicit central dogmas of the movement and don't feel the need to use
all its formal apparatus or accept its cultural baggage. Nevertheless,
my approach has certainly been influenced by Christopher Alexander's
work<sup><a href="#ftn.id2808454" id="id2808454">[3]</a></sup>
  (especially
  <em>The Timeless Way of Building</em> and
  <em>A Pattern Language</em>), and I owe the Gang of Four and other
members of their school a large debt of gratitude for showing me how
it is possible to use Alexander's insights to talk about software
design at a high level without merely uttering vague and useless
generalities. Interested readers should see
  <em>Design Patterns: Elements of Reusable Object-Oriented Software</em><sup><a href="#GangOfFour" title="[GangOfFour]">[GangOfFour]</a></sup> for an introduction to design
patterns.
</p>
<p>
  The title of this book is, of course, a reference to Donald
Knuth's
  <em>The Art of Computer Programming</em>.  While not
specifically associated with the Unix tradition, Knuth has been an
influence on us all.
</p>
<p>
  Editors with vision and imagination aren't as common as they
should be. Mark Taub is one; he saw merit in a stalled project and
skillfully nudged me into finishing it. Copy editors with a good ear
for prose style and enough ability to improve writing that isn't like
theirs are even less common, but Mary Lou Nohr makes that grade. Jerry
Votta seized on my concept for the cover and made it look better than I
had imagined.  The whole crew at Addison-Wesley gets high marks for
making the editorial and production process as painless as possible,
and for cheerfully accommodating my control-freak tendencies not just
over the text but deep into the details of the book's visual design,
art, and marketing.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2808454" id="ftn.id2808454">[3]</a></sup>
  An appreciation of Alexander's work, with links to
on-line versions of significant portions, may be found at
  <a href="http://www.math.utsa.edu/sphere/salingar/Chris.text.html">
   Some Notes on Christopher Alexander</a>.
</p>
</div>


<!-- FILE: context.html -->
<h2 id="context"><a href="#context">§</a>Context</h2>


<!-- FILE: philosophychapter.html -->
<h3 id="philosophychapter"><a href="#philosophychapter">§</a>Chapter 1. Philosophy</h3>
 <blockquote class="epigraph">
  <p>Those who do not understand Unix are condemned to reinvent it, poorly.</p>
  <span>– Henry Spencer, Usenet signature, November 1987</span>
 </blockquote>


<!-- FILE: ch01s01.html -->
<h3 id="ch01s01"><a href="#ch01s01">§</a>Culture? What Culture?</h3>
<p>
  This is a book about Unix programming, but in it we're going to
toss around the words ‘culture’, ‘art’, and
‘philosophy’ a lot. If you are not a programmer, or you
are a programmer who has had little contact with the Unix world, this
may seem strange. But Unix has a culture; it has a distinctive art of
programming; and it carries with it a powerful design
philosophy. Understanding these traditions will help you build better
software, even if you're developing for a non-Unix platform.
</p>
<p>
  Every branch of engineering and design has technical cultures.
In most kinds of engineering, the unwritten traditions of the field
are parts of a working practitioner's education as important as (and,
as experience grows, often more important than) the official handbooks
and textbooks. Senior engineers develop huge bodies of implicit
knowledge, which they pass to their juniors by (as
Zen
  Buddhists put it)
“a special transmission, outside the scriptures”.
</p>
<p>
  Software engineering is generally an exception to this rule;
technology has changed so rapidly, software environments have come and
gone so quickly, that technical cultures have been weak and
ephemeral. There are, however, exceptions to this exception. A very
few software technologies have proved durable enough to evolve strong
technical cultures, distinctive arts, and an associated design
philosophy transmitted across generations of engineers.
</p>
<p>
  The Unix culture is one of these. The Internet culture is
another — or, in the twenty-first century, arguably the same
one. The two have grown increasingly difficult to separate since the
early 1980s, and in this book we won't try particularly hard.
</p>



<!-- FILE: ch01s02.html -->
<h3 id="ch01s02"><a href="#ch01s02">§</a>The Durability of Unix</h3>
<p>
  Unix was born in 1969 and has been in continuous production use
ever since. That's several geologic eras by computer-industry
standards — older than the PC or workstations or microprocessors
or even video display terminals, and contemporaneous with the first
semiconductor memories. Of all production timesharing systems today,
only IBM's VM/CMS can claim to have existed longer, and Unix machines 
have provided hundreds of thousands of times more service hours;
indeed, Unix has probably supported more computing than all other
timesharing systems put together.
</p>
<p>
  Unix has found use on a wider variety of machines than any other
operating system can claim. From supercomputers to handhelds and
embedded networking hardware, through workstations and servers and PCs
and minicomputers, Unix has probably seen more architectures and more
odd hardware than any three other operating systems combined.
</p>
<p>
  Unix has supported a mind-bogglingly wide spectrum of uses. No
other operating system has shone simultaneously as a research vehicle,
a friendly host for technical custom applications, a platform for
commercial-off-the-shelf business software, and a vital component
technology of the Internet.
</p>
<p>
  Confident predictions that Unix would wither away, or be crowded
out by other operating systems, have been made yearly since its
infancy. And yet Unix, in its present-day avatars as
Linux
  and BSD and Solaris and MacOS X and half a dozen other variants,
seems stronger than ever today.
</p>
 <blockquote>
  <p>
   Robert Metcalf [the inventor of Ethernet] says that if something
comes along to replace Ethernet, it will be called
“Ethernet”, so therefore Ethernet will never
die.<sup><a href="#ftn.id2876928" id="id2876928">[4]</a></sup>
   Unix has already undergone
several such transformations.
  </p>
  <span>
   – Ken Thompson
  </span>
 </blockquote>
<p>
  At least one of Unix's central technologies — the C
language — has been widely naturalized elsewhere. Indeed it is
now hard to imagine doing software engineering without
C
  as a ubiquitous
common language of systems programming.  Unix also introduced both the
now-ubiquitous tree-shaped file namespace with directory nodes and
the pipeline for connecting programs.
</p>
<p>
  Unix's durability and adaptability have been nothing short of
astonishing. Other technologies have come and gone like mayflies.
Machines have increased a thousandfold in power, languages have
mutated, industry practice has gone through multiple revolutions —
and Unix hangs in there, still producing, still paying the bills,
and still commanding loyalty from many of the best and brightest
software technologists on the planet.
</p>
<p>
  One of the many consequences of the exponential
power-versus-time curve in computing, and the corresponding pace of
software development, is that 50% of what one knows becomes obsolete
over every 18 months.  Unix does not abolish this phenomenon, but does
do a good job of containing it.  There's a bedrock of unchanging
basics — languages, system calls, and tool invocations —
that one can actually keep using for years, even decades.  Elsewhere
it is impossible to predict what will be stable; even entire operating
systems cycle out of use.  Under Unix, there is a fairly sharp
distinction between transient knowledge and lasting knowledge, and one
can know ahead of time (with about 90% certainty) which category
something is likely to fall in when one learns it.  Thus the loyalty
Unix commands.
</p>
<p>
  Much of Unix's stability and success has to be attributed to its
inherent strengths, to design decisions Ken
Thompson,
Dennis Ritchie, Brian
Kernighan, Doug McIlroy, Rob Pike
  and other early Unix developers made back at
the beginning; decisions that have been proven sound over and
over. But just as much is due to the design philosophy, art of
programming, and technical culture that grew up around Unix in the
early days. This tradition has continuously and successfully
propagated itself in symbiosis with Unix ever since.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2876928" id="ftn.id2876928">[4]</a></sup>
  In fact, Ethernet has already been replaced by a
different technology with the same name — twice.  Once when coax
was replaced with twisted pair, and a second time when gigabit
Ethernet came in.
</p>
</div>


<!-- FILE: ch01s03.html -->
<h3 id="ch01s03"><a href="#ch01s03">§</a>The Case against Learning Unix Culture</h3>
<p>
  Unix's durability and its technical culture are certainly of
interest to people who already like Unix, and perhaps to historians of
technology. But Unix's original application as a general-purpose
timesharing system for mid-sized and larger computers is rapidly
receding into the mists of history, killed off by personal
workstations. And there is certainly room for doubt that it will ever
achieve success in the mainstream business-desktop market now
dominated by
Microsoft.
</p>
<p>
  Outsiders have frequently dismissed Unix as an academic toy or a
hacker's sandbox.  One well-known polemic, the
  <em>Unix Hater's Handbook</em><sup><a href="#Garfinkel" title="[Garfinkel]">[Garfinkel]</a></sup>, follows an
antagonistic line nearly as old as Unix itself in writing its devotees
off as a cult religion of freaks and losers. Certainly the colossal
and repeated blunders of
AT&amp;T,
Sun, Novell,
and other commercial vendors and standards consortia in mispositioning
and mismarketing Unix have become legendary.
</p>
<p>
  Even from within the Unix world, Unix has seemed to be teetering
on the brink of universality for so long as to raise the suspicion
that it will never actually get there. A skeptical outside observer's
conclusion might be that Unix is too useful to die but too awkward to
break out of the back room; a perpetual niche operating system.
</p>
<p>
  What confounds the skeptics' case is, more than anything else,
the rise of Linux
  and other open-source Unixes (such as the
modern BSD variants).  Unix's culture proved too vital to be smothered
even by a decade of vendor mismanagement.  Today the Unix community
itself has taken control of the technology and marketing, and is
rapidly and visibly solving Unix's problems (in ways we'll examine in
more detail in
  <a href="#futurechapter" title="Chapter 20. Futures">
   Chapter 20</a>).
</p>



<!-- FILE: ch01s04.html -->
<h3 id="ch01s04"><a href="#ch01s04">§</a>What Unix Gets Wrong</h3>
<p>
  For a design that dates from 1969, it is remarkably difficult
to identify design choices in Unix that are unequivocally wrong.
There are several popular candidates, but each is still a subject of
spirited debate not merely among Unix fans but across the wider
community of people who think about and design operating
systems.
</p>
<p>
  Unix files have no structure above byte level. File deletion is
irrevocable.  The Unix security model is arguably too primitive.  Job
control is botched.  There are too many different kinds of names for
things.  Having a file system at all may have been the wrong choice.
We will discuss these technical issues in
  <a href="#futurechapter" title="Chapter 20. Futures">Chapter 20</a>.
</p>
<p>
  But perhaps the most enduring objections to Unix are consequences of
a feature of its philosophy first made explicit by the designers of
the X windowing system. X strives to provide “mechanism,
not policy”, supporting an extremely general set of graphics
operations and deferring decisions about toolkits and interface
look-and-feel (the policy) up to application level. Unix's other
system-level services display similar tendencies; final choices about
behavior are pushed as far toward the user as possible. Unix users
can choose among multiple shells. Unix programs normally provide many
behavior options and sport elaborate preference facilities.
</p>
<p>
  This tendency reflects Unix's heritage as an operating system
designed primarily for technical users, and a consequent belief that
users know better than operating-system designers what their own needs
are.
</p>
 <blockquote>
  <p>
   This tenet was firmly established at Bell Labs by Dick
Hamming<sup><a href="#ftn.id2808745" id="id2808745">[5]</a></sup>
   who insisted in
the 1950s when computers were rare and expensive, that open-shop
computing, where customers wrote their own programs, was imperative,
because “it is better to solve the right problem the wrong way
than the wrong problem the right way”.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  But the cost of the mechanism-not-policy approach is that when
the user <em>can</em> set policy, the user <em>must</em>
  set policy. Nontechnical end-users
frequently find Unix's profusion of options and interface styles
overwhelming and retreat to systems that at least pretend to offer
them simplicity.
</p>
<p>
  In the short term, Unix's laissez-faire approach may lose it a
good many nontechnical users. In the long term, however, it may turn
out that this ‘mistake’ confers a critical advantage
— because policy tends to have a short lifetime, mechanism a
long one. Today's fashion in interface look-and-feel too often becomes
tomorrow's evolutionary dead end (as people using obsolete X toolkits
will tell you with some feeling!). So the flip side of the flip side
is that the “mechanism, not policy” philosophy may enable
Unix to renew its relevance long after competitors more tied to one
set of policy or interface choices have faded from
view.<sup><a href="#ftn.id2808799" id="id2808799">[6]</a></sup>
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2808745" id="ftn.id2808745">[5]</a></sup>
  Yes, the Hamming of ‘Hamming distance’
and ‘Hamming code’.
</p>

<p><sup><a href="#id2808799" id="ftn.id2808799">[6]</a></sup>
  Jim Gettys, one of the architects of X (and a
contributor to this book), has meditated in depth on how X's
laissez-faire style might be productively carried forward in
  <em>The Two-Edged Sword</em> <sup><a href="#Gettys" title="[Gettys]">[Gettys]</a></sup>.  This essay is well worth reading,
both for its specific proposals and for its expression of the Unix
mindset.
</p>
</div>


<!-- FILE: ch01s05.html -->
<h3 id="ch01s05"><a href="#ch01s05">§</a>What Unix Gets Right</h3>
<p>
  The explosive recent growth of Linux, and the increasing importance
of the Internet, give us good reasons to suppose that the skeptics'
case is wrong. But even supposing the skeptical assessment is true,
Unix culture is worth learning because there are some things that Unix
and its surrounding culture clearly do better than any
competitors.
</p>
<h4 id="id2808846"><a href="#id2808846">§</a>Open-Source Software</h4>
<p>
  Though the term “open
source”
  and the Open Source Definition were not invented until 1998,
peer-review-intensive development of freely shared source code was a key
feature of the Unix culture from its beginnings.
</p>
<p>
  For its first ten years
AT&amp;T's
  original
Unix, and its primary variant Berkeley Unix, were normally distributed
with source code.  This enabled most of the other good things that
follow here.
</p>
<h4 id="id2872776"><a href="#id2872776">§</a>Cross-Platform Portability and Open Standards</h4>
<p>
  Unix is still the only operating system that can present a
consistent, documented application programming interface (API) across
a heterogeneous mix of computers, vendors, and special-purpose
hardware. It is the only operating system that can scale from embedded
chips and handhelds, up through desktop machines, through servers, and
all the way to special-purpose number-crunching behemoths and database
back ends.
</p>
<p>
  The Unix API is the closest thing to a hardware-independent
standard for writing truly portable software that exists. It is no
accident that what the IEEE originally called the
  <em>Portable Operating System Standard</em>
  quickly got a suffix added to
its acronym and became
POSIX.  A
Unix-equivalent API was the only credible model for such a
standard.
</p>
<p>
  Binary-only applications for other operating systems die with
their birth environments, but Unix sources are forever. Forever, at
least, given a Unix technical culture that polishes and maintains
them across decades.
</p>
<h4 id="id2872827"><a href="#id2872827">§</a>The Internet and the World Wide Web</h4>
<p>
  The Defense Department's contract for the first production
TCP/IP
  stack went to a
Unix development group because the Unix in question was largely open
source.  Besides
TCP/IP, Unix has
become the one indispensable core technology of the Internet Service
Provider industry. Ever since the demise of the TOPS family of operating
systems
  in the
mid-1980s, most Internet server machines (and effectively all above
the PC level) have relied on Unix.
</p>
<p>
  Not even
Microsoft's
  awesome
marketing clout has been able to dent Unix's lock on the
Internet. While the
TCP/IP
  standards (on
which the Internet is based) evolved under
TOPS-10
  and
are theoretically separable from Unix, attempts to make them work on
other operating systems have been bedeviled by incompatibilities,
instabilities, and bugs. The theory and specifications are available
to anyone, but the engineering tradition to make them into a solid and
working reality exists only in the Unix world.<sup><a href="#ftn.id2872907" id="id2872907">[7]</a></sup>
</p>
<p>
  The Internet technical culture
  and the Unix culture began to
merge in the early 1980s, and are now inseparably symbiotic.  The
design of the World Wide Web, the modern face of the Internet, owes as
much to Unix as it does to the ancestral ARPANET.  In particular, the
concept of the Uniform Resource Locator (URL) so central to the Web is
a generalization of the Unix idea of one uniform file namespace
everywhere. To function effectively as an Internet expert, an
understanding of Unix and its culture are indispensable.
</p>
<h4 id="id2872945"><a href="#id2872945">§</a>The Open-Source Community</h4>
<p>
  The community that originally formed around the early Unix
source distributions never went away — after the great Internet
explosion of the early 1990s, it recruited an entire new generation of
eager hackers
  on home
machines.
</p>
<p>
  Today, that community is a powerful support group for all kinds
of software development.  High-quality open-source development tools
abound in the Unix world (we'll examine many in this
book). Open-source Unix applications are usually equal to, and are
often superior to, their proprietary equivalents <sup><a href="#Fuzz" title="[Fuzz]">[Fuzz]</a></sup>. Entire Unix operating systems, with complete
toolkits and basic applications suites, are available for free over
the Internet. Why code from scratch when you can adapt, reuse,
recycle, and save yourself 90% of the work?
</p>
<p>
  This tradition of code-sharing depends heavily on hard-won
expertise about how to make programs cooperative and reusable. And
not by abstract theory, but through a lot of engineering practice
— unobvious design rules that allow programs to function not just
as isolated one-shot solutions but as synergistic parts of a
toolkit.  A major purpose of this book is to elucidate those rules.
</p>
<p>
  Today, a burgeoning open-source movement is bringing new
vitality, new technical approaches, and an entire generation of bright
young programmers into the Unix tradition. Open-source projects
including the Linux
  operating system and symbionts such as
Apache
  and Mozilla
have brought the Unix tradition an unprecedented level of mainstream
visibility and success. The open-source movement seems on the verge of
winning its bid to define the computing infrastructure of tomorrow
— and the core of that infrastructure will be Unix machines
running on the Internet.
</p>
<h4 id="id2873031"><a href="#id2873031">§</a>Flexibility All the Way Down</h4>
<p>
  Many operating systems touted as more ‘modern’ or
‘user friendly’ than Unix achieve their surface glossiness by
locking users and developers into one interface policy, and offer
an application-programming interface that for all its elaborateness
is rather narrow and rigid. On such systems, tasks the designers
have anticipated are very easy — but tasks they have not
anticipated are often impossible or at best extremely painful.
</p>
<p>
  Unix, on the other hand, has flexibility in depth. The many ways
Unix provides to glue together programs mean that components of its
basic toolkit can be combined to produce useful effects that the
designers of the individual toolkit parts never anticipated.
</p>
<p>
  Unix's support of multiple styles of program interface (often
seen as a weakness because it increases the perceived complexity of
the system to end users) also contributes to flexibility; no
program that wants to be a simple piece of data plumbing is forced
to carry the complexity overhead of an elaborate GUI.
</p>
<p>
  Unix tradition lays heavy emphasis on keeping programming
interfaces relatively small, clean, and orthogonal — another trait
that produces flexibility in depth. Throughout a Unix system, easy
things are easy and hard things are at least possible.
</p>
<h4 id="id2873078"><a href="#id2873078">§</a>Unix Is Fun to Hack</h4>
<p>
  People who pontificate about Unix's technical superiority often
don't mention what may ultimately be its most important strength,
the one that underlies all its successes. Unix is fun to hack.
</p>
<p>
  Unix boosters seem almost ashamed to acknowledge this sometimes,
as though admitting they're having fun might damage their
legitimacy somehow. But it's true; Unix is fun to play with and
develop for, and always has been.
</p>
<p>
  There are not many operating systems that anyone has ever
described as ‘fun’. Indeed, the friction and labor of
development under most other environments has been aptly compared to
kicking a dead whale down the beach.<sup><a href="#ftn.id2873107" id="id2873107">[8]</a></sup>
  The kindest
adjectives one normally hears are on the order of
“tolerable” or “not too painful”. In the Unix
world, by contrast, the operating system rewards effort rather than
frustrating it.  People programming under Unix usually come to see
it not as an adversary to be clubbed into doing one's bidding by main
effort but rather as an actual positive help.
</p>
<p>
  This has real economic significance. The fun factor started a
virtuous circle early in Unix's history. People liked Unix, so they
built more programs for it that made it nicer to use. Today people
build entire, production-quality open-source Unix systems as a
hobby. To understand how remarkable this is, ask yourself when you
last heard of anybody cloning OS/360 or VAX VMS
  or Microsoft
Windows
  for fun.
</p>
<p>
  The ‘fun’ factor is not trivial from a design point
of view, either. The kind of people who become programmers and
developers have ‘fun’ when the effort they have to put out
to do a task challenges them, but is just within their
capabilities. ‘Fun’ is therefore a sign of peak
efficiency. Painful development environments waste labor and
creativity; they extract huge hidden costs in time, money, and
opportunity.
</p>
<p>
  If Unix were a failure in every other way, the Unix engineering
culture would be worth studying for the ways it keeps the fun
in development — because that fun is a sign that it makes
developers efficient, effective, and productive.
</p>
<h4 id="id2873180"><a href="#id2873180">§</a>The Lessons of Unix Can Be Applied Elsewhere</h4>
<p>
  Unix programmers have accumulated decades of experience
while pioneering operating-system features we now take for granted.
Even non-Unix programmers can benefit from studying that Unix
experience. Because Unix makes it relatively easy to apply good design
principles and development methods, it is an excellent place to
learn them.
</p>
<p>
  Other operating systems generally make good practice rather
more difficult, but even so some of the Unix culture's lessons can
transfer. Much Unix code (including all its filters, its major
scripting languages, and many of its code generators) will
port directly to any operating system supporting ANSI
C
  (for the
excellent reason that C
  itself was a Unix invention and the
ANSI C library embodies a substantial chunk of Unix's
services!).
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2872907" id="ftn.id2872907">[7]</a></sup>
  Other
operating systems have generally copied or cloned Unix TCP/IP
implementations. It is their loss that they have not generally adopted
the robust tradition of peer review that goes with it, exemplified by
documents like RFC 1025 (
  <em>TCP and IP Bake Off</em>).
</p>

<p><sup><a href="#id2873107" id="ftn.id2873107">[8]</a></sup>
  This was originally
said of the IBM MVS TSO facility by Stephen C. Johnson, perhaps better
known as the author of
  <em>yacc</em>.
</p>
</div>


<!-- FILE: ch01s06.html -->
<h3 id="ch01s06"><a href="#ch01s06">§</a>Basics of the Unix Philosophy</h3>
<p>
  The ‘Unix philosophy’ originated with Ken
Thompson's
  early meditations on how to design a small but capable operating
system with a clean service interface. It grew as the Unix culture
learned things about how to get maximum leverage out of Thompson's
design.  It absorbed lessons from many sources along the way.
</p>
<p>
  The Unix philosophy is not a formal design method. It wasn't
handed down from the high fastnesses of theoretical computer
science as a way to produce theoretically perfect software. Nor is
it that perennial executive's mirage, some way to magically extract
innovative but reliable software on too short a deadline from
unmotivated, badly managed, and underpaid programmers.
</p>
<p>
  The Unix philosophy (like successful folk traditions in other
engineering disciplines) is bottom-up, not top-down. It is pragmatic
and grounded in experience. It is not to be found in official methods
and standards, but rather in the implicit half-reflexive knowledge, the
  <em>expertise</em>
  that the Unix culture transmits. It
encourages a sense of proportion and skepticism — and shows both
by having a sense of (often subversive) humor.
</p>
<p>
  Doug McIlroy,
  the inventor of
Unix pipes
  and one of the
founders of the Unix tradition, had this to say at the time <sup><a href="#McIlroy78" title="[McIlroy78]">[McIlroy78]</a></sup>:
</p>
 <blockquote>
  <p>
   (i) Make each program do one thing well. To do a new job, build
afresh rather than complicate old programs by adding new
features.
  </p>
  <p>
   (ii) Expect the output of every program to become the input to
another, as yet unknown, program. Don't clutter output with
extraneous information. Avoid stringently columnar or binary input
formats. Don't insist on interactive input.
  </p>
  <p>
   (iii) Design and build software, even operating systems, to be
tried early, ideally within weeks. Don't hesitate to throw away the
clumsy parts and rebuild them.
  </p>
  <p>
   (iv) Use tools in preference to unskilled help to lighten a
programming task, even if you have to detour to build the tools and
expect to throw some of them out after you've finished using
them.
  </p>
 </blockquote>
<p>
  He later summarized it this way (quoted in
  <em>A Quarter Century of Unix</em><sup><a href="#Salus" title="[Salus]">[Salus]</a></sup>):
</p>
 <blockquote>
  <p>
   This is the Unix philosophy: Write programs that do one
thing and do it well. Write programs to work together. Write
programs to handle text streams, because that is a universal
interface.
  </p>
 </blockquote>
<p>
  Rob Pike, who
became one of the great masters of C, offers a slightly different angle
in
  <em>Notes on C Programming</em> <sup><a href="#Pike" title="[Pike]">[Pike]</a></sup>:
</p>
 <blockquote>
  <p>
   Rule 1. You can't tell where a program is going to spend its
time. Bottlenecks occur in surprising places, so don't try to second
guess and put in a speed hack until you've proven that's where the
bottleneck
is.
  </p>
  <p>
   Rule 2. Measure. Don't tune for speed until you've measured, and
even then don't unless one part of the code overwhelms the
rest.
  </p>
  <p>
   Rule 3. Fancy algorithms are slow when
   <code>n</code> is small, and
   <code>n</code> is usually small. Fancy algorithms have big
constants. Until you know that
   <code>n</code> is
frequently going to be big, don't get fancy. (Even if
   <code>n</code> does get big, use Rule 2 first.)
  </p>
  <p>
   Rule 4. Fancy algorithms are buggier than simple ones, and
they're much harder to implement. Use simple algorithms as well as
simple data structures.
  </p>
  <p id="rule5">
   Rule 5. Data dominates. If you've chosen the right data
structures and organized things well, the algorithms will almost
always be self-evident. Data structures, not algorithms, are central
to programming.<sup><a href="#ftn.id2873492" id="id2873492">[9]</a></sup>
  </p>
  <p>
   Rule 6. There is no Rule 6.
  </p>
 </blockquote>
<p>
  Ken Thompson, the man who designed and implemented the
first Unix, reinforced Pike's rule 4 with a gnomic maxim worthy of a
Zen
  patriarch:
</p>
 <blockquote>
  <p>
   When in doubt, use brute force.
  </p>
 </blockquote>
<p>
  More of the Unix philosophy was implied not by what these elders
said but by what they did and the example Unix itself set. Looking
at the whole, we can abstract the following ideas:
</p>
 <div class="orderedlist">
  <ol id="rules">
   <li>Rule of Modularity: Write simple parts connected by clean interfaces.</li>
   <li>
     Rule of Clarity: Clarity is better than cleverness.
   </li>
   <li>Rule of Composition: Design programs to be connected to other programs.</li>
   <li>Rule of Separation: Separate policy from mechanism; separate interfaces from engines.</li>
   <li>Rule of Simplicity: Design for simplicity; add complexity only where you must.</li>
   <li>Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do.</li>
   <li> Rule of Transparency: Design for visibility to make inspection and debugging easier.</li>
   <li>Rule of Robustness: Robustness is the child of transparency and simplicity.</li>
   <li>Rule of Representation: Fold knowledge into data so program logic can be stupid and robust.</li>
   <li>Rule of Least Surprise: In interface design, always do the least surprising thing.</li>
   <li>Rule of Silence: When a program has nothing surprising to say, it should say nothing.</li>
   <li>Rule of Repair: When you must fail, fail noisily and as soon as possible.</li>
   <li>Rule of Economy: Programmer time is expensive; conserve it in preference to machine time.</li>
   <li>Rule of Generation: Avoid hand-hacking; write programs to write programs when you can.</li>
   <li>Rule of Optimization: Prototype before polishing. Get it working before you optimize it.</li>
   <li>Rule of Diversity: Distrust all claims for “one true way”.</li>
   <li>Rule of Extensibility: Design for the future, because it will be here sooner than you think.</li>
  </ol>
 </div>
<p>
  If you're new to Unix, these principles are worth some
meditation. Software-engineering texts recommend most of them; but
most other operating systems lack the right tools and traditions to
turn them into practice, so most programmers can't apply them with
any consistency. They come to accept blunt tools, bad designs,
overwork, and bloated code as normal — and then wonder what Unix
fans are so annoyed about.
</p>
<h4 id="id2877537"><a href="#id2877537">§</a>Rule of Modularity: Write simple parts connected by clean interfaces.</h4>
<p>
  As Brian Kernighan once observed, “Controlling complexity
is the essence of computer programming” <sup><a href="#Kernighan-Plauger" title="[Kernighan-Plauger]">[Kernighan-Plauger]</a></sup>. Debugging dominates
development time, and getting a working system out the door is
usually less a result of brilliant design than it is of managing not
to trip over your own feet too many times.
</p>
<p>
  Assemblers, compilers, flowcharting, procedural programming,
structured programming, “artificial intelligence”,
fourth-generation languages, object
orientation, and software-development
methodologies without number have been touted and sold as a cure for
this problem. All have failed as cures, if only because they
‘succeeded’ by escalating the normal level of program
complexity to the point where (once again) human brains could barely
cope. As Fred Brooks
  famously observed <sup><a href="#Brooks" title="[Brooks]">[Brooks]</a></sup>, there is no silver bullet.
</p>
<p>
  The only way to write complex software that won't fall on its
face is to hold its global complexity down — to build it out of
simple parts connected by well-defined interfaces, so that most
problems are local and you can have some hope of upgrading
a part without breaking the whole.
</p>
<h4 id="id2877610"><a href="#id2877610">§</a>Rule of Clarity: Clarity is better than cleverness.</h4>
<p>
  Because maintenance is so important and so expensive, write
programs as if the most important communication they do is not to the
computer that executes them but to the human beings who will read and
maintain the source code in the future (including yourself).
</p>
<p>
  In the Unix tradition, the implications of this advice go beyond
just commenting your code.  Good Unix practice also embraces choosing
your algorithms and implementations for future maintainability.  Buying a
small increase in performance with a large increase in the complexity 
and obscurity of your technique is a bad trade — not merely because
complex code is more likely to harbor bugs, but also because complex
code will be harder to read for future maintainers.
</p>
<p>
  Code that is graceful and clear, on the other hand, is less
likely to break — and more likely to be instantly comprehended
by the next person to have to change it.  This is important,
especially when that next person might be yourself some years down the
road.
</p>
 <blockquote>
  <p>
   Never struggle to decipher subtle code three times.  Once might
be a one-shot fluke, but if you find yourself having to figure it out
a second time — because the first was too long ago and you've
forgotten details — it is time to comment the code so that the
third time will be relatively painless.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<h4 id="id2877684"><a href="#id2877684">§</a>Rule of Composition: Design programs to be connected with other programs.</h4>
<p>
  It's hard to avoid programming overcomplicated monoliths if none
of your programs can talk to each other.
</p>
<p>
  Unix tradition strongly encourages writing programs that
read and write simple, textual, stream-oriented, device-independent
formats.  Under classic Unix, as many programs as possible are written
as simple
  <em>filters</em>, which take a simple text
stream on input and process it into another simple text stream on
output.
</p>
<p>
  Despite popular mythology, this practice is favored not because
Unix programmers hate graphical user interfaces. It's because if you
don't write programs that accept and emit simple text streams, it's
much more difficult to hook the programs together.
</p>
<p>
  Text streams are to Unix tools as messages are to objects in an
object-oriented setting. The simplicity of the text-stream interface
enforces the encapsulation of the tools.  More elaborate forms of
inter-process communication, such as remote procedure calls, show a
tendency to involve programs with each others' internals too
much.
</p>
<p>
  To make programs composable, make them independent.  A program
on one end of a text stream should care as little as possible about
the program on the other end.  It should be made easy to replace one
end with a completely different implementation without disturbing the
other.
</p>
<p>
  GUIs can be a very good thing. Complex binary data formats are
sometimes unavoidable by any reasonable means. But before writing a
GUI, it's wise to ask if the tricky interactive parts of your
program can be segregated into one piece and the workhorse
algorithms into another, with a simple command stream or
application protocol connecting the two. Before devising a tricky
binary format to pass data around, it's worth experimenting to see
if you can make a simple textual format work and accept a little
parsing overhead in return for being able to hack the data stream
with general-purpose tools.
</p>
<p>
  When a serialized, protocol-like interface is not natural for the
application, proper Unix design is to at least organize as many of the
application primitives as possible into a library with a well-defined
API.  This opens up the possibility that the application can be called
by linkage, or that multiple interfaces can be glued on it for different tasks.
</p>
<p>
  (We discuss these issues in detail in <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">Chapter 7</a>.)
</p>
<h4 id="id2877777"><a href="#id2877777">§</a>Rule of Separation: Separate policy from mechanism; separate interfaces from engines.</h4>
<p>
  In our discussion of what Unix gets wrong, we observed that the
designers of X
  made a basic decision to implement
“mechanism, not policy”
  —to make X a generic
graphics engine and leave decisions about user-interface style to
toolkits and other levels of the system.  We justified this by
pointing out that policy and mechanism tend to mutate on different
timescales, with policy changing much faster than mechanism. Fashions
in the look and feel of GUI toolkits may come and go, but raster
operations and compositing are forever.
</p>
<p>
  Thus, hardwiring policy and mechanism together has two bad
effects: It makes policy rigid and harder to change in response to user
requirements, and it means that trying to change policy has a strong
tendency to destabilize the mechanisms.
</p>
<p>
  On the other hand, by separating the two we make it possible to
experiment with new policy without breaking mechanisms.  We also make
it much easier to write good tests for the mechanism (policy,
because it ages so quickly, often does not justify the investment).
</p>
<p>
  This design rule has wide application outside the GUI
context.  In general, it implies that we should look for ways to
separate interfaces from engines.
</p>
<p>
  One way to effect that separation is, for example, to write
your application as a library of C
  service routines that are driven by an
embedded scripting language, with the application flow of control
written in the scripting language rather than C. A classic example of
this pattern is the
  <em>Emacs</em> editor, which uses
an embedded Lisp
  interpreter to control editing
primitives written in C.  We discuss this style of design in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">Chapter 11</a>.
</p>
<p>
  Another way is to separate your application into cooperating front-end and back-end processes communicating through a
  specialized application protocol over sockets; we discuss this kind of design in
  <a href="#textualitychapter" title="Chapter 5. Textuality">Chapter 5</a>
  and
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">Chapter 7</a>.  The front end implements policy; the
back end, mechanism.  The global complexity of the pair will often be
far lower than that of a single-process monolith implementing the same
functions, reducing your vulnerability to bugs and lowering life-cycle
costs.
</p>
<h4 id="id2877917"><a href="#id2877917">§</a>Rule of Simplicity: Design for simplicity; add complexity only where you must.</h4>
<p>
  Many pressures tend to make programs more complicated (and
therefore more expensive and buggy). One such pressure is technical
machismo. Programmers are bright people who are (often justly) proud
of their ability to handle complexity and juggle abstractions. Often
they compete with their peers to see who can build the most intricate
and beautiful complexities. Just as often, their ability to design
outstrips their ability to implement and debug, and the result is
expensive failure.
</p>
 <blockquote>
  <p>
   The notion of “intricate and beautiful complexities” is
almost an oxymoron.  Unix programmers vie with each other
for “simple and beautiful” honors — a point that's
implicit in these rules, but is well worth making overt.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  Even more often (at least in the commercial software world)
excessive complexity comes from project requirements that are based on
the marketing fad of the month rather than the reality of what
customers want or software can actually deliver. Many a good design
has been smothered under marketing's pile of “checklist
features” — features that, often, no customer will ever
use. And a vicious circle operates; the competition thinks it has to
compete with chrome by adding more chrome. Pretty soon, massive bloat
is the industry standard and everyone is using huge, buggy programs
not even their developers can love.
</p>
<p>
  Either way, everybody loses in the end.
</p>
<p>
  The only way to avoid these traps is to encourage a software
culture that knows that small is beautiful, that actively resists
bloat and complexity: an engineering tradition that puts a high
value on simple solutions, that looks for ways to break program systems up
into small cooperating pieces, and that reflexively fights attempts to
gussy up programs with a lot of chrome (or, even worse, to design
programs
  <em>around</em> the chrome).
</p>
<p>
  That would be a culture a lot like Unix's.
</p>
<h4 id="id2878022"><a href="#id2878022">§</a>Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do.</h4>
<p>
  ‘Big’ here has the sense both of large in volume of
code and of internal complexity.  Allowing programs to get large
hurts maintainability.  Because people are reluctant to throw
away the visible product of lots of work, large programs invite
overinvestment in approaches that are failed or suboptimal.
</p>
<p>
  (We'll examine the issue of the right size of software in more
detail in
  <a href="#complexitychapter" title="Chapter 13. Complexity">Chapter 13</a>.)
</p>
<h4 id="id2878054"><a href="#id2878054">§</a>Rule of Transparency: Design for visibility to make inspection and debugging easier.</h4>
<p>
  Because debugging often occupies three-quarters or more of
development time, work done early to ease debugging can be a very
good investment. A particularly effective way to ease debugging is to
design for
  <em>transparency</em> and
  <em>discoverability</em>.
</p>
<p>
  A software system is
  <em>transparent</em>
  when you
can look at it and immediately understand what it is doing and how. It
is
  <em>discoverable</em>
  when it has facilities for
monitoring and display of internal state so that your program not only
functions well but can be
  <em>seen</em>
  to function
well.
</p>
<p>
  Designing for these qualities will have implications throughout
a project. At minimum, it implies that debugging options should not be
minimal afterthoughts. Rather, they should be designed in from the
beginning — from the point of view that the program should be
able to both demonstrate its own correctness and communicate to future
developers the original developer's mental model of the problem it
solves.
</p>
<p>
  For a program to demonstrate its own correctness, it needs to be
using input and output formats sufficiently simple so that the proper
relationship between valid input and correct output is easy to
check.
</p>
<p>
  The objective of designing for transparency and discoverability
should also encourage simple interfaces that can easily be manipulated
by other programs — in particular, test and monitoring harnesses
and debugging scripts.
</p>
<h4 id="id2878145"><a href="#id2878145">§</a>Rule of Robustness: Robustness is the child of transparency and simplicity.</h4>
<p>
  Software is said to be
  <em>robust</em> when
it performs well under unexpected conditions which stress the designer's
assumptions, as well as under normal conditions.
</p>
<p>
  Most software is fragile and buggy because most programs are too
complicated for a human brain to understand all at once. When you
can't reason correctly about the guts of a program, you can't be sure
it's correct, and you can't fix it if it's broken.
</p>
<p>
  It follows that the way to make robust programs is to make their
internals easy for human beings to reason about. There are two main
ways to do that:
transparency
  and
simplicity.
</p>
 <blockquote>
  <p>
   For robustness, designing in tolerance for unusual or extremely
bulky inputs is also important.  Bearing in mind the Rule of
Composition helps; input generated by other programs is notorious for
stress-testing software (e.g., the original Unix C compiler reportedly
needed small upgrades to cope well with Yacc output).  The forms
involved often seem useless to humans.  For example, accepting empty
lists/strings/etc., even in places where a human would seldom or never
supply an empty string, avoids having to special-case such situations when
generating the input mechanically.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  One very important tactic for being robust under odd inputs is
to avoid having special cases in your code.  Bugs often lurk in the
code for handling special cases, and in the interactions among parts
of the code intended to handle different special cases.
</p>
<p>
  We observed above that software is
  <em>transparent</em> when you can look at it and
immediately see what is going on. It is
  <em>simple</em>
  when what is going on is uncomplicated enough for a human brain to
reason about all the potential cases without strain.  The more
your programs have both of these qualities, the more robust they will
be.
</p>
<p>
  Modularity (simple parts, clean interfaces) is a way to organize
programs to make them simpler. There are other ways to fight for
simplicity. Here's another one.
</p>
<h4 id="id2878263"><a href="#id2878263">§</a>Rule of Representation: Fold knowledge into data, so program logic can be stupid and robust.</h4>
<p>
  Even the simplest procedural logic is hard for humans to verify,
but quite complex data structures are fairly easy to model and reason
about. To see this, compare the expressiveness and explanatory power
of a diagram of (say) a fifty-node pointer tree with a flowchart of a
fifty-line program.  Or, compare an array initializer expressing a conversion
table with an equivalent switch statement. The difference in
transparency
  and
clarity is dramatic. See Rob Pike's
  <a href="#rule5">Rule 5</a>.
</p>
<p>
  Data is more tractable than program logic. It follows that where
you see a choice between complexity in data structures and
complexity in code, choose the former. More: in evolving a design,
you should actively seek ways to shift complexity from code to
data.
</p>
<p>
  The Unix community did not originate this insight, but a lot of
Unix code displays its influence.  The
C
  language's facility at
manipulating pointers, in particular, has encouraged the use of
dynamically-modified reference structures at all levels of coding from
the kernel upward. Simple pointer chases in such structures frequently
do duties that implementations in other languages would instead have
to embody in more elaborate procedures.
</p>
<p>
  (We also cover these techniques in
  <a href="#generationchapter" title="Chapter 9. Generation">Chapter 9</a>.)
</p>
<h4 id="id2878339"><a href="#id2878339">§</a>Rule of Least Surprise: In interface design, always do the least surprising thing.</h4>
<p>
  (This is also widely known as the Principle of Least
Astonishment.)
</p>
<p>
  The easiest programs to use are those that demand the least new
learning from the user — or, to put it another way, the easiest
programs to use are those that most effectively connect to the user's
pre-existing knowledge.
</p>
<p>
  Therefore, avoid gratuitous novelty and excessive cleverness in
interface design.  If you're writing a calculator program,
‘+’ should always mean addition! When designing an
interface, model it on the interfaces of functionally similar or
analogous programs with which your users are likely to be
familiar.
</p>
<p>
  Pay attention to your expected audience.  They may be end
users, they may be other programmers, or they may be system
administrators.  What is least surprising can differ among these
groups.
</p>
<p>
  Pay attention to tradition. The Unix world has rather well-developed
conventions about things like the format of configuration and
run-control files, command-line switches, and the like. These
traditions exist for a good reason: to tame the learning curve.
Learn and use them.
</p>
<p>
  (We'll cover many of these traditions in
  <a href="#textualitychapter" title="Chapter 5. Textuality">Chapter 5</a>
  and
  <a href="#configurationchapter" title="Chapter 10. Configuration">Chapter 10</a>.)
</p>
 <blockquote>
  <p>
   The flip side of the Rule of Least Surprise is to avoid
making things superficially similar but really a little bit different.
This is extremely treacherous because the seeming familiarity raises false
expectations.  It's often better to make things distinctly different than
to make them
   <em>almost</em>
   the same.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<h4 id="id2878450"><a href="#id2878450">§</a>Rule of Silence: When a program has nothing surprising to say, it should say nothing.</h4>
<p>
  One of Unix's oldest and most persistent design rules is that when a
program has nothing interesting or surprising to say, it should
  <em>shut up</em>.  Well-behaved Unix programs do their jobs
unobtrusively, with a minimum of fuss and bother.  Silence is
golden.
</p>
<p>
  This “silence is golden” rule evolved originally
because Unix predates video displays.  On the slow printing terminals
of 1969, each line of unnecessary output was a serious drain on the
user's time.  That constraint is gone, but excellent reasons for
terseness remain.
</p>
 <blockquote>
  <p>
   I think that the terseness of Unix programs is a central feature
of the style.  When your program's output becomes another's input, it 
should be easy to pick out the needed bits.  And for people it is
a human-factors necessity — important information should not
be mixed in with verbosity about internal program behavior.  If all
displayed information is important, important information is easy to
find.
  </p>
  <span>
   – Ken Arnold
  </span>
 </blockquote>
<p>
  Well-designed programs treat the user's attention and
concentration as a precious and limited resource, only to be claimed
when necessary.
</p>
<p>
  (We'll discuss the Rule of Silence and the reasons for it in
more detail at the end of
  <a href="#interfacechapter" title="Chapter 11. Interfaces">Chapter 11</a>.)
</p>
<h4 id="id2878538"><a href="#id2878538">§</a>Rule of Repair: Repair what you can — but when you must fail, fail noisily and as soon as possible.</h4>
<p>
  Software should be
transparent
  in the way that it fails, as well
as in normal operation.  It's best when software can cope with
unexpected conditions by adapting to them, but the worst kinds of bugs
are those in which the repair doesn't succeed and the problem quietly
causes corruption that doesn't show up until much later.
</p>
<p>
  Therefore, write your software to cope with incorrect inputs and
its own execution errors as gracefully as possible.  But when it
cannot, make it fail in a way that makes diagnosis of the problem as
easy as possible.
</p>
<p>
  Consider also Postel's Prescription:<sup><a href="#ftn.id2878578" id="id2878578">[10]</a></sup>
  “Be liberal in what you accept, and conservative in what you
send”. Postel was speaking of network service programs, but the
underlying idea is more general.  Well-designed programs cooperate
with other programs by making as much sense as they can from
ill-formed inputs; they either fail noisily or pass strictly clean and
correct data to the next program in the chain.
</p>
<p>
  However, heed also this warning:
</p>
 <blockquote>
  <p>
   The original HTML documents recommended “be generous in
what you accept”, and it has bedeviled us ever since because
each browser accepts a different superset of the specifications.  It
is the
   <em>specifications</em>
   that should be generous,
not their interpretation.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  McIlroy adjures us to
  <em>design</em>
  for
generosity rather than compensating for inadequate standards with 
permissive implementations.  Otherwise, as he rightly points
out, it's all too easy to end up in tag soup.
</p>
<h4 id="id2878666"><a href="#id2878666">§</a>Rule of Economy: Programmer time is expensive; conserve it in preference to machine time.</h4>
<p>
  In the early minicomputer days of Unix, this was still a fairly
radical idea (machines were a great deal slower and more expensive
then). Nowadays, with every development shop and most users (apart
from the few modeling nuclear explosions or doing 3D movie
animation) awash in cheap machine cycles, it may seem too obvious
to need saying.
</p>
<p>
  Somehow, though, practice doesn't seem to have quite caught up
with reality. If we took this maxim really seriously throughout
software development, most applications would be written in
higher-level languages like Perl, Tcl, Python, Java,
Lisp and even shell — languages that ease the programmer's burden by
doing their own memory management (see <sup><a href="#Ravenbrook" title="[Ravenbrook]">[Ravenbrook]</a></sup>).
</p>
<p>
  And indeed this is happening within the Unix world, though
outside it most applications shops still seem stuck with the
old-school Unix strategy of coding in C (or C++). Later in this book
we'll discuss this strategy and its tradeoffs in detail.
</p>
<p>
  One other obvious way to conserve programmer time is to teach
machines how to do more of the low-level work of programming. This
leads to...
</p>
<h4 id="id2878742"><a href="#id2878742">§</a>Rule of Generation: Avoid hand-hacking; write programs to write programs when you can.</h4>
<p>
  Human beings are notoriously bad at sweating the details.
Accordingly, any kind of hand-hacking of programs is a rich source of
delays and errors. The simpler and more abstracted your program
specification can be, the more likely it is that the human designer
will have gotten it right. Generated code (at
  <em>every</em>
  level) is almost always cheaper and more
reliable than hand-hacked.
</p>
<p>
  We all know this is true (it's why we have compilers and
interpreters, after all) but we often don't think about the
implications. High-level-language code that's repetitive and
mind-numbing for humans to write is just as productive a target for a
code generator as machine code. It pays to use code generators when
they can raise the level of abstraction — that is, when the
specification language for the generator is simpler than the generated
code, and the code doesn't have to be hand-hacked afterwards.
</p>
<p>
  In the Unix tradition, code generators are heavily used to
automate error-prone detail work. Parser/lexer generators are the
classic examples; makefile generators and GUI interface builders are
newer ones.
</p>
<p>
  (We cover these techniques in
  <a href="#generationchapter" title="Chapter 9. Generation">Chapter 9</a>.)
</p>
<h4 id="rule_of_optimization"><a href="#rule_of_optimization">§</a>
  Rule of Optimization:
Prototype before polishing. Get it working before you optimize
it.
 </h4>
<p>
  The most basic argument for prototyping first is Kernighan &amp;
Plauger's;
  “90% of the functionality delivered now
is better than 100% of it delivered never”. Prototyping first
may help keep you from investing far too much time for marginal
gains.
</p>
<p>
  For slightly different reasons, Donald
Knuth
  (author of
  <em>The Art Of Computer Programming</em>, one
of the field's few true classics) popularized the observation that
“Premature optimization is the root of all
evil”.<sup><a href="#ftn.id2878872" id="id2878872">[11]</a></sup>
  And he was right.
</p>
<p>
  Rushing to optimize before the bottlenecks are known may be the
only error to have ruined more designs than feature creep. From
tortured code to incomprehensible data layouts, the results of
obsessing about speed or memory or disk usage at the expense of
transparency and simplicity are everywhere. They spawn innumerable
bugs and cost millions of man-hours — often, just to get marginal
gains in the use of some resource much less expensive than
debugging time.
</p>
<p>
  Disturbingly often, premature local optimization actually
hinders global optimization (and hence reduces overall performance).
A prematurely optimized portion of a design frequently interferes with
changes that would have much higher payoffs across the whole design,
so you end up with both inferior performance and excessively complex
code.
</p>
<p>
  In the Unix world there is a long-established and very explicit
tradition (exemplified by Rob Pike's
  comments above and Ken
Thompson's
  maxim about brute force) that says:
  <em>
   Prototype, then
polish. Get it working before you optimize it
</em>. Or: Make it
work first, then make it work fast. ‘Extreme programming' guru
Kent Beck,
operating in a different culture, has usefully amplified this to:
“Make it run, then make it right, then make it
fast”.
</p>
<p>
  The thrust of all these quotes is the same: get your design
right with an un-optimized, slow, memory-intensive implementation
before you try to tune. Then, tune systematically, looking for the
places where you can buy big performance wins with the smallest
possible increases in local complexity.
</p>
 <blockquote>
  <p>
   Prototyping is important for system design as well as
optimization — it is much easier to judge whether a prototype
does what you want than it is to read a long specification.  I
remember one development manager at Bellcore who fought against the
“requirements” culture years before anybody talked about
“rapid prototyping” or “agile development”. He
wouldn't issue long specifications; he'd lash together some combination of
shell scripts and awk code that did roughly what was needed, tell the
customers to send him some clerks for a few days, and then have the
customers come in and look at their clerks using the prototype and
tell him whether or not they liked it.  If they did, he would say
“you can have it industrial strength so-many-months from now at
such-and-such cost”.  His estimates tended to be accurate, but
he lost out in the culture to managers who believed that requirements 
writers should be in control of everything.
  </p>
  <span>
   – Mike Lesk
  </span>
 </blockquote>
<p>
  Using prototyping to learn which features you don't have to
implement helps optimization for performance; you don't have to
optimize what you don't write. The most powerful optimization tool in
existence may be the delete key.
</p>
 <blockquote>
  <p>One of my most productive days was throwing away 1000 lines of code.</p>
  <span>– Ken Thompson</span>
 </blockquote>
<p>
  (We'll go into a bit more depth about related ideas in
  <a href="#optimizationchapter" title="Chapter 12. Optimization">Chapter 12</a>.)
</p>
<h4 id="id2879078"><a href="#id2879078">§</a>Rule of Diversity: Distrust all claims for “one true way”.</h4>
<p>
  Even the best software tools tend to be limited by the
imaginations of their designers. Nobody is smart enough to optimize
for everything, nor to anticipate all the uses to which their software
might be put. Designing rigid, closed software that won't talk
to the rest of the world is an unhealthy form of arrogance.
</p>
<p>
  Therefore, the Unix tradition includes a healthy
mistrust of “one true way” approaches to software design or
implementation. It embraces multiple languages, open extensible
systems, and customization hooks everywhere.
</p>
<h4 id="id2879112"><a href="#id2879112">§</a>Rule of Extensibility: Design for the future, because it will be here sooner than you think.</h4>
<p>
  If it is unwise to trust other people's claims for “one
true way”, it's even more foolish to believe them about your
own designs.  Never assume you have the final answer.  Therefore,
leave room for your data formats and code to grow; otherwise, you
will often find that you are locked into unwise early choices because
you cannot change them while maintaining backward compatibility.
</p>
<p>
  When you design protocols or file formats, make them sufficiently
self-describing to be extensible.  Always,
  <em>always</em>
  either include a version number, or compose the format from
self-contained, self-describing clauses in such a way that new clauses
can be readily added and old ones dropped without confusing 
format-reading code.  Unix experience tells us that the marginal
extra overhead of making data layouts self-describing is paid back 
a thousandfold by the ability to evolve them forward without 
breaking things.
</p>
<p>
  When you design code, organize it so future developers
will be able to plug new functions into the architecture without
having to scrap and rebuild the
architecture.
This rule is not a license to add features you don't yet need; it's
advice to write your code so that adding features later when you
  <em>do</em>
  need them is easy.
Make the joints flexible, and put “If you ever need
to...” comments in your code.  You owe this grace to people who
will use and maintain your code after you.
</p>
<p>
  You'll be there in the future too, maintaining code you may have
half forgotten under the press of more recent projects.  When you
design for the future, the sanity you save may be your own.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2873492" id="ftn.id2873492">[9]</a></sup>
  Pike's original adds “(See
Brooks p. 102.)” here. The reference is to an early edition of
  <em>The Mythical Man-Month</em> <sup><a href="#Brooks" title="[Brooks]">[Brooks]</a></sup>; the quote is “Show me your
flow charts and conceal your tables and I shall continue to be
mystified, show me your tables and I won't usually need your flow
charts; they'll be obvious”.
</p>

<p><sup><a href="#id2878578" id="ftn.id2878578">[10]</a></sup>
  Jonathan
Postel was the first editor of the Internet RFC series of standards,
and one of the principal architects of the Internet. A tribute
  <a href="http://www.postel.org/postel.html">
   page</a>
  is maintained
by the Postel Center for Experimental Networking.
</p>
</div>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2878872" id="ftn.id2878872">[11]</a></sup>
  In full: “We should forget about
small efficiencies, say about 97% of the time: premature optimization
is the root of all evil”. Knuth himself attributes the remark
to C. A. R. Hoare.
</p>
</div>


<!-- FILE: ch01s07.html -->
<h3 id="ch01s07"><a href="#ch01s07">§</a>The Unix Philosophy in One Lesson</h3>
<p>
  All the philosophy really boils down to one iron law, the
hallowed ‘KISS
  principle’ of master engineers everywhere:
</p>
 <div class="center">
  <img alt="KISS: Keep It Simple Stupid" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAADbCAAAAADxbT/RAAAAAnRSTlMA/1uRIrUAAAACYktHRAD/h4/MvwAAAAlwSFlzAAAA+gAAAPoAxzgVegAAER1JREFUeNrtnTsOvbgVximSNgpVUqQYIUVKNQ3NSCkyBcVsACnlv4jQ1GlcpWcLbIEtsAW2wBbYws01D+MnGPv4XK7lr7pPf8Y/MLaxj7OXWUNLkp6qfjKDy7SfTh35Nc+SHq0//Ey6yRbq1Jafzm+Srcp2soA6VJ/OZ9I9VcMF1DEh/UJV4wnUufl09pLc1MwmqGNqG32t8lEPtft0xpJ81Omgkk/nKslPRIWabqdfr0aGmq7TCEREqP2n85MEoZ6Hmtq9cWhrA69Q07hgJCoPqOmGGo3IDnVOlW80yucNarpQIxJZoU6fzkcSpKYFqulCLSpC+lfSA9UTUhUGbGSBqr2j5mTy904KqYnoyVGog+6bOiH9Ak21jt3whqqrfYm/YRKG9PCyl6ZubvzdknCkeQ5TvDJN27f6dE6T7KWZfzRlmqH8wd8qCUuaJlGfkXShfrfUS/WHBmrnb5SEJ3UW0i/Zv5TPZn+jJDzNCsC/ZH9XPvt0LpPuSQH4x+ynBPXL9We1qfRLgvrl+ilBjU8qwey3BPXL9UOFShLULxdJUONTghqhEtQIlaBGqAQ1QiWoESpBjVAJaoRKUCNUghqhEtQIlaBGqAQ1QiWoESpBjVAJaoRKUCNUgipr6kldVVVNulH5rqmAFiuENUlQBU1EWPJXEaHMZ5iyCG7iAdUiunN17iT5WmbZKqq003raQbNkt+CKnEBARTBJUJn0q7BpkW9R6ZcocJ4LAFFMPKCS6iIsWlXxRdu97yFmHkVV2S/DGoaOnKDNqzuJ7erPYkcVNSErDr/yRjHxvadOfaPNZt0a8jWpqeeNprVwrbnL7xhfiV+AXZJ2GIZ3W0bj0PqUNooJRENpVn9/GvSjlU7PznlN3azUFKVrtJGZu/AbLpFROWc9gl+gmFBBtH7lP1wEiIDL/igzdU7pOD3k82KWwth4ZBjFhAqkSyNG/sgvLj2egku9y0lqdThHBTqqRc0JOQm3b/c+JIrJIhCo4j+uIrkcv6x9VzOLVXntn0x98b1HeaOYrAKBKob+6Gx/7B/HR4xZ4dq8mFjdZ6pkhqN2zJ9ssgkEqli2F81PVs8ARJIY7xgbddSLxixxgcqfbLIJZphQ+PV5ndpeHtsdCcaOt9QjblRh/tFR4G4uKCa7AkA9/SXLN0zEl3vZvCqCs0Yny7hbfYBiopqhQN27ljlQhFkIqEfb/TRTeyAbt/JGMdmFDHVn6tmVuW9sFndfPq/0yPWV9lkTOREkqA0wUwiorXUCpXt5o5gwoUIFZwoBtbFOYL3cnDpiKCZMmFDhmUJArewTWA7AaWAAxYQJEWoAphBQuVHXq+bJ0i9xGmBGMWHCgxqCKQRULoHLIana1QbFhAkL6v7YCZYpMNTLSq8HgBrOhAkJ6gzdl7E1vpfE5UAO7W66HAKKCRMO1DEQU2iol41OWjYuAwMoJkICwaHuo1/gTCGgCtMnrsqSVo0ug2EoJkwYUIdgTIG7NNcP+Gkz1mVgAMWECQHqPp4ZgCkEVPFwy4sCr93KG8XE4BYCakimEFClzT3CbAKBYsIUHOo+QBaEKQRUOeL81WX0XBOm0FDDMgV59CbPmXeeZ/pxk11hobKZroGYgkBVNufJA+ythGKyKyhUNts6FFMQqJrFOQG2K0Qx2RQS6hicKQxUzT5avhOSP2SyKSBUNuEmHFMYqC/dSjTw6wjFZFU4qAMCUyCos27j5wL4podisioYVLbhWEimQFD5GbecgDd3RjFZFAoqDlMoqC/N9qJLUYB2J1FMqAJBZXNywjIFg6rZyXDNvudK0Q+YvEJBPeZZfQtUfiWLoAJohjKeSRio/OLaL6l+3xp1DRmqCvAIUEyCrKURF3h/Q0Np0WwMIwF410MxCQBVXrR/+fjQQ5BQlcgFhyCrRwSTAFAVBXwkAQv1GANT5L0+GtMEA2pAqsBQ3+VhiokDOUwQ2gQFajiq4FDN0asgx/QCmwSBmjdyCs7hGO4YA6U5mNoygFVwWJMQUMtR7Wb7x3e4NgZLtTd0PEArnIAmAaA2NFdIVMNAfTdR9Xc92O5ZMJPwA/pBqYaCqovjBk81lEm4R28KVZgoD9fGQBq1d70c+MlNEJOAD8kxqAaEaqgeoRvyIUxCTmdBoBoU6mvSDRNAN+QDmASdeKZQBX/OHxaqPvI0+KkJbhJ2iqhM9Ymr3s6leVgGP5YNbRJ4MndoqsGh6kZq4dvxwCahZ+gHphoeqiZUtGeQufAmwdfSyFQL0MoLAeprVgZqA8zsBDXBW/W2C7RPgAFVnV1f+CcZ1ARxfWoIqjhQlcoxxGxdQBOMleQBqeJAfc1S8zTIzHo4E5SYDzJVuOajJ9TKNriCtBLm1qJhFBNBONFZglH1hEqsi058QnwrIBmKieyIADUYVU+odBKYXddhulki2CaCsCKeyVSB7kqehTDYn1+1sxWKiSC02ITyzMhHhFtfLg27q6h1tkIxEYQecBKWqm8hZNZX0eBuhWLCCz80LChV30JY+oZWI5dCfJV7bRgUE16IUJXeNcAwsC/UZRjHrm3KO93rbaCY8MKMzC2vpQYY3PeFuh6rVTdSKKLnmaiGOFCVtdT+VH2hri0Tq4eXvNO9ETwUE164u10oD+J8Bwx9oW4tE4vZI3wb5uZWbCgmvJD3pZHT9h0G9oW6d/ev60b+fLw5dIJiwgt7WzC5sXROdWwJOa2FbI2NCe2XxeWNgG+7GzqdnzXh9LG93iyobpNiz9Zt2hmfJFRcZ2MR39loHmnCCQSquOOl5a6Ml9XMwd/co7UyPkuIPZq+KHC+UKZHmhjScYbqtn/qBVX+8aLpxLQyPk3oONjTAp+4NMgzTbR+HlDFq+9ipEgN0qenyt9fTFM7rLZYPk2IO9iTAufHTcqHmkBDFQcAr5ptyuJV/T+Em6/hvLTaDP00IaETYaxjuCwbemGfNwGGKs3DuOp8agJ/aVbaihe0YXRFHKLS9+zOExKbA/oIKfwlZGjBPsAEGKr8h6vxLdVSUyuJR6AfB7V6SHuRkJhCrilxfgmTqVfyBBNQqGoMmXOqU6aRUitZnJbqagXdXfUiIXk9d94I9dpE+B8Yg6Q/wQQO6tzpVlgWrfmh8GCIONNIf7mi1TcWiVwnpMt+9e7fv9WTRqTRmG8sDzABgdoRUhlDAmV51UhDH+/fE1IXxn9kdcf/nmcm3KZpOmbjkrSDeNUbE+IKoCGN+VA2nfb4H2ACArXKLkVu/p7/i7FTZpUO53zeuyPs41l77bNCPA8z9wCTb4BqHD65C/V8HEaYFjZ3hgBHZXf15OHzJiBQg2taT+rKe5HDWUKjdNbPPZHryIrYPPf9uMmhJ0N9H0NPepB1gycJve/QyjcDbS9Q1e879NeYHG6PhprkpAQ1QiWoESpBjVAJaoRKUCNUghqhEtQIlaBGqAQ1QiWoESpBjVAJaoRKUCNUghqhEtQIlaBGqAQ1QiWoESpBjVAJaoRKUCNUghqhEtQIlaBGqKihjpVbqNIxyMYHdvmbO/8dAsNB3VeLFHTJM6mWpT155R4PlmWrMKyhnttl6VRB+mZbjFQ4BIObuya3P2LV846U/E1LclvSlXPQs5BX6rLEvN3e9O8DaB0T2jTUfIKyxjxrRnqVZWzpfO6Q93lo7f+l8bwjJX9TX7OP7EPvKwpa/dL/zszIP2bozCcof1fsyxffJb0V8Fg4xVe1PmKd5x1p8jczc4rBcb1fcKh7/kG27uMS7KXiIAfudwn7ulgXnsaz97ojf8WVuh8zyHaMR4JTLhVdwWWTIEHVeio5czQf3AseByoQUw5qKVdcGbe6evbbDNP6iLWepd/2LDxU15C/KFA7IKYH1EYJOZPz8Ydqr8Xn1kes82yu40hZmrtH0ceA2smhgea2pGFUZv3bvsleMyne/YTZkCDbbJT7iq6bV4IxzV25p1mvreeaQqAvytFodyQs5UyW6slyVu/Z4zOqWLH80VKqaNeIM8+dt5tHgNrJ8czGolvCKW1nufB2ILSdv8V0U+KgHZlRroc1BCcfhGgNmLEwzOlZT8g8vV3muelo4S8xa7R2R0tAzKgi1fPI2chuPc2WC9mK5W/JbEXD2w1leXxUOV/y4aG2CtP15J62XY/Ft+PSU6MXR5er9c8J1C2mHdcXnpaoU7TAaEuyrMb1R83yYlw7vFq7oyUgZFQjxZPLGcvq1ktRrFj+Xktkwm4jyYq7eS7URom1V2xVTrkevvR2KYOllGjzb1ATNEGlvT6q4vjPzP183QWHhtDrt0+ql8Fu/5ecM41UTxUqe6VY8Z3SvWt9/I0473cRHOpyKvNUu72EyBLWVnrLl0atRHs9hfq+Xa1hhgj/e/OL/GWw2z5Rc6aRztMEVbXaP5iOZvTxt+65UJdbCl991WLKtWLEDDulMM+h0iJekqmUJo/Ni046q2q7IlA9r6HuVvsH7bGd1vG3wbncERpKlCp3W5VGb9XBXGY4KtZXUN//WRoitZyUzQtml+3tVsuxatnzGurILNYPquNAvwSqRFXCodLRlIaU4MsMdYvK2JmK8+TFS4Fq3VARPa+hviSouQ7qy3kHP5TBh4Xq9tkoxQ0Eh7q4Se1YF6jjnVEEwfM+1EwL1XkHP5xhQnrMDfuwFH9Tqv8yfWeGSriqsrjFUrVjJX5xqZg8raAK99TsGLvnitt5ZAoH6tLlbtiHbHxp7uS3/GFNmWaA1wC159piuRvUScKh5kySyfMa6m61f1Ac8Sg9ipsJ6SkNR7XiOir1IL/lD6u/0U8dxY5MaSrOkxe91E9VcybJ5HkNdbfiarJG/rGH0J6n5jvV7mhT0AFZ6S1/WM2dEaWjU0AHGNpLhOqLRroTKznrcumpmsGTQR12giar/YOBRdo+xiNejhOsAkOd+f8uqS7DpMtF+y6Nvio1b4/RnzHLJ2OCOT1DZu76KdjQen3cDLUIZ+UTyW7/Ss5ZnknBk7Wee87eH+UdnepSFpynaMUyUW1doqVGm/ZzwXUnUrQ5SuseF2XP7cCy9telt8uR5h0dIS1GXYJr4Nwmy8e54qDTQdPmXcRjfWxzQ4fj+v3FsBbndmZNGVfZinbsx3LO6Eth4yadJ8vZvjdFM9PHL63OiuVvsarH11QuhV/vZOCms/wOA3WfTVjSmqarCi4xOmcur9lJL72lR1qoT7zEJKYqy4XHI6Tr141AimYriqFZRvDqbnuRDRMb02uXnzadajdt/yJqzohcFqonnzOaakYr7KruZs2Rsfxth0ethldWbjuFTIXzbEKVYPYL2D3VTciGd+zmqbD+7VuDtO+GjRVEIPLfEtQ7dgPQrIaw+ocK9acE1aSxcmy64B7ZX1WoPyeoBvV+TNGOTAH4p+yfCapeA/Fj+jmof9N0aa63vQfUjAsV0Q7LSt3L9FcNVNemtcuBLwtmPBfdPNIOz0rdeIxknfKZ68iGg/Y9v5AWEyLaoVnNyg6kb6Sj8hnmpZrkK80OgWP2Uknj3lWTfKTZHTx/ZS/NpoFAyyaSgmvUXJL1G6p6U80y58dASagysMvWJ1yKqnSxPl6jfm/Z+SXPxT1Ukv/95wdJeqR+/Pu/vxs2x65fFOqQJUWkYYFqudN00leIPs9elt19OiNJcBo2qKa7atL3aZkbs0Cdcv/Ukp6gdYrb+iCh808u6QlaxxfY1NSkCLQvi9g6sqkFHIH22fAstETpn2bSZ8UWkLKH84nqt4tbFMxGEufUsflq1dzyfW6AmPinnPQp8VMshLlRfeqvfqlyYV6DOOFtDymT9FXKpdms8izGKfVYv06NvCJHnZo6takd/EXal82dQ124Vqka/gLlVatdNmeeRD4MXTsMeHOAk6w1D0PbDeY1yv8HFBcVunK60PsAAAA8dEVYdGNvbW1lbnQAIEltYWdlIGdlbmVyYXRlZCBieSBHTlUgR2hvc3RzY3JpcHQgKGRldmljZT1wbm1yYXcpCvqLFvMAAAAASUVORK5CYII="/>
 </div>
<p>
  Unix gives you an excellent base for applying the KISS principle.
The remainder of this book will help you learn how.
</p>



<!-- FILE: ch01s08.html -->
<h3 id="ch01s08"><a href="#ch01s08">§</a>Applying the Unix Philosophy</h3>
<p>
  These philosophical principles aren't just vague generalities.
In the Unix world they come straight from experience and lead to
specific prescriptions, some of which we've already developed
above. Here's a by no means exhaustive list:
</p>
 <div>
  <ul>
   <li>
    <p>
     Everything that can be a source- and
destination-independent filter
     <em>should</em>
     be
one.
    </p>
   </li>
   <li>
    <p>
     Data streams should if at all possible be textual (so they can
be viewed and filtered with standard tools).
    </p>
   </li>
   <li>
    <p>
     Database layouts and application protocols should if
at all possible be textual (human-readable and
human-editable).
    </p>
   </li>
   <li>
    <p>
     Complex front ends (user interfaces) should be cleanly
separated from complex back ends.
    </p>
   </li>
   <li>
    <p>
     Whenever possible, prototype in an interpreted language before
coding C.
    </p>
   </li>
   <li>
    <p>
     Mixing languages is better than writing everything in
one, if and only if using only that one is likely to overcomplicate
the program.
    </p>
   </li>
   <li>
    <p>
     Be generous in what you accept, rigorous in what you
emit.
    </p>
   </li>
   <li>
    <p>
     When filtering, never throw away information you don't
need to.
    </p>
   </li>
   <li>
    <p>
     Small is beautiful.  Write programs that do as little
as is consistent with getting the job done.
    </p>
   </li>
  </ul>
 </div>
<p>
  We'll see the Unix design rules, and the prescriptions that
derive from them, applied over and over again in the remainder of this
book.  Unsurprisingly, they tend to converge with the very best
practices from software engineering in other
traditions.<sup><a href="#ftn.id2879339" id="id2879339">[12]</a></sup>
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2879339" id="ftn.id2879339">[12]</a></sup>
  One notable example is Butler Lampson's
  <em>Hints for Computer System Design</em> <sup><a href="#Lampson" title="[Lampson]">[Lampson]</a></sup>, which I discovered late in the preparation of
this book.  It not only expresses a number of Unix dicta in forms that
were clearly discovered independently, but uses many of the same tag
lines to illustrate them.
</p>
</div>


<!-- FILE: ch01s09.html -->
<h3 id="ch01s09"><a href="#ch01s09">§</a>Attitude Matters Too</h3>
<p>
  When you see the right thing, do it — this may look like
more work in the short term, but it's the path of least effort in the
long run. If you don't know what the right thing is, do the minimum
necessary to get the job done, at least until you figure out what the
right thing is.
</p>
<p>
  To do the Unix philosophy right, you have to be loyal to
excellence. You have to believe that software design is a craft worth
all the intelligence, creativity, and passion you can
muster. Otherwise you won't look past the easy, stereotyped ways of
approaching design and implementation; you'll rush into coding when
you should be thinking. You'll carelessly complicate when you should
be relentlessly simplifying — and then you'll wonder why your
code bloats and debugging is so hard.
</p>
<p>
  To do the Unix philosophy right, you have to value your own time
enough never to waste it. If someone has already solved a problem
once, don't let pride or politics suck you into solving it a
second time rather than re-using. And never work harder than you
have to; work smarter instead, and save the extra effort for when
you need it. Lean on your tools and automate everything you
can.
</p>
<p>
  Software design and implementation should be a joyous art, a
kind of high-level play. If this attitude seems preposterous or
vaguely embarrassing to you, stop and think; ask yourself what
you've forgotten. Why do you design software instead of doing
something else to make money or pass the time? You must have
thought software was worthy of your passion once....
</p>
<p>
  To do the Unix philosophy right, you need to have (or recover)
that attitude. You need to
  <em>care</em>. You need to
  <em>play</em>. You need to be willing to
  <em>explore</em>.
</p>
<p>
  We hope you'll bring this attitude to the rest of this book. Or,
at least, that this book will help you rediscover it.
</p>



<!-- FILE: historychapter.html -->
<h3 id="historychapter"><a href="#historychapter">§</a>Chapter 2. History</h3>
 <blockquote class="epigraph">
  <p>
   Those who cannot remember the past are condemned to repeat it.
  </p>
  <span>
   – George Santayana
The Life of Reason (1905)
  </span>
 </blockquote>
<p>
  The past informs practice.  Unix has a long and colorful history,
much of which is still live as folklore, assumptions, and (too often)
battle scars in the collective memory of Unix programmers.  In this
chapter we'll survey the history of Unix, with an eye to explaining
why, in 2003, today's Unix culture looks the way it does.
</p>



<!-- FILE: ch02s01.html -->
<h3 id="ch02s01"><a href="#ch02s01">§</a>Origins and History of Unix, 1969-1995</h3>
<p>
  A notorious ‘second-system effect‘ often afflicts
the successors of small experimental prototypes.  The urge to add
everything that was left out the first time around all too frequently
leads to huge and overcomplicated design.  Less well known, because
less common, is the ‘third-system effect’; sometimes,
after the second system has collapsed of its own weight, there is a
chance to go back to simplicity and get it really right.
</p>
<p>
  The original Unix was a third system.  Its grandfather was the
small and simple Compatible Time-Sharing System
(CTSS), either the first
or second timesharing system ever deployed (depending on some
definitional questions we are going to determinedly ignore).  Its
father was the pioneering
Multics
  project, an
attempt to create a feature-packed ‘information utility’
that would gracefully support interactive timesharing of mainframe
computers by large communities of users. Multics, alas, did
collapse of its own weight.  But Unix was born from that collapse.
</p>
<h4 id="genesis"><a href="#genesis">§</a>Genesis: 1969–1971</h4>
<p>
  Unix was born in 1969 out of the mind of a computer scientist at
Bell Laboratories, Ken Thompson.  Thompson had been a
researcher on the Multics project, an experience which spoiled him for
the primitive batch computing that was the rule almost everywhere
else.  But the concept of timesharing was still a novel one in the late
1960s; the first speculations on it had been uttered barely ten years
earlier by computer scientist John McCarthy (also the inventor of the
Lisp
  language),
the first actual deployment had been in 1962, seven years earlier, and
timesharing operating systems were still experimental and
temperamental beasts.
</p>
<p>
  Computer hardware was at that time more primitive than even
people who were there to see it can now easily recall.  The most
powerful machines of the day had less computing power and internal
memory than a typical cellphone of today.<sup><a href="#ftn.id2881371" id="id2881371">[13]</a></sup>
  Video display terminals were in their infancy and would not be widely
deployed for another six years.  The standard interactive device on
the earliest timesharing systems was the ASR-33 teletype — a
slow, noisy device that printed upper-case-only on big rolls of yellow
paper.  The ASR-33 was the natural parent of the Unix tradition of
terse commands and sparse responses.
</p>
<p>
  When Bell Labs withdrew from the Multics research consortium,
Ken Thompson was left with some Multics-inspired ideas about how to
build a file system.  He was also left without a machine on which to
play a game he had written called Space Travel, a science-fiction
simulation that involved navigating a rocket through the solar
system. Unix began its life on a scavenged
PDP-7
  minicomputer<sup><a href="#ftn.id2881412" id="id2881412">[14]</a></sup>
  like the one shown in Figure 2.1, as a platform for the Space Travel game and a testbed for Thompson's ideas about
  operating system design.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 2.1. The PDP-7.
   </b>
  </p>
  <div class="center">
   <img alt="The PDP-7." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  The full origin story is told in <sup><a href="#Ritchie79" title="[Ritchie79]">[Ritchie79]</a></sup> from the point of view of
Thompson's first collaborator, Dennis Ritchie, the man who would
become known as the co-inventor of Unix and the inventor of the
C
  language.
Dennis Ritchie, Doug McIlroy, and a few colleagues had become used to
interactive computing under
Multics
  and did not
want to lose that capability.  Thompson's PDP-7 operating system
offered them a lifeline.
</p>
<p>
  Ritchie observes: “What we wanted to preserve was not just
a good environment in which to do programming, but a system around
which a fellowship could form. We knew from experience that the
essence of communal computing, as supplied by remote-access,
time-shared machines, is not just to type programs into a terminal
instead of a keypunch, but to encourage close communication”.
The theme of computers being viewed not merely as logic devices but as
the nuclei of communities was in the air; 1969 was also the year the
ARPANET (the direct ancestor of today's Internet) was invented. The theme
of “fellowship” would resonate all through Unix's
subsequent history.
</p>
<p>
  Thompson and Ritchie's Space Travel implementation attracted
notice.  At first, the PDP-7's software had to be cross-compiled on a
GE mainframe.  The utility programs that Thompson and Ritchie wrote to
support hosting game development on the PDP-7 itself became the core
of Unix — though the name did not attach itself until 1970.  The
original spelling was “UNICS” (UNiplexed Information
and Computing Service), which Ritchie later described as “a
somewhat treacherous pun on Multics”, which stood for
MULTiplexed Information and Computing
Service.
</p>
<p>
  Even at its earliest stages, PDP-7 Unix bore a strong
resemblance to today's Unixes and provided a rather more
pleasant programming environment than was available anywhere else in
those days of card-fed batch mainframes.  Unix was very close to being
the first system under which a programmer could sit down directly at a
machine and compose programs on the fly, exploring possibilities and
testing while composing.  All through its lifetime Unix has had a pattern
of growing more capabilities by attracting highly skilled volunteer
efforts from programmers impatient with the limitations of other
operating systems.  This pattern was set early, within Bell Labs
itself.
</p>
<p>
  The Unix tradition of lightweight development and informal
methods also began at its beginning.  Where Multics had been a large
project with thousands of pages of technical specifications written
before the hardware arrived, the first running Unix code was
brainstormed by three people and implemented by Ken
Thompson
  in two
days — on an obsolete machine that had been designed to be a
graphics terminal for a ‘real’ computer.
</p>
<p>
  Unix's first real job, in 1971, was to support what would now be
called word processing for the Bell Labs patent department; the first
Unix application was the ancestor of the
nroff(1)
text formatter.  This project justified the purchase of a
PDP-11, a much
more capable minicomputer.  Management remained blissfully unaware
that the word-processing system that Thompson and colleagues were
building was incubating an operating system.  Operating systems were
not in the Bell Labs plan —
AT&amp;T
  had joined
the Multics consortium precisely to avoid doing an operating
system on its own.  Nevertheless, the completed system was a rousing
success.  It established Unix as a permanent and valued part of the
computing ecology at Bell Labs, and began another theme in Unix's
history — a close association with document-formatting,
typesetting, and communications tools.  The 1972 manual claimed 10
installations.
</p>
<p>
  Later, Doug McIlroy
  would write of this period <sup><a href="#McIlroy91" title="[McIlroy91]">[McIlroy91]</a></sup>: “Peer pressure and simple pride in
workmanship caused gobs of code to be rewritten or discarded as better
or more basic ideas emerged. Professional rivalry and protection of
turf were practically unknown: so many good things were happening that
nobody needed to be proprietary about innovations”. But it
would take another quarter century for all the implications of that
observation to come home.
</p>
<h4 id="id2879627"><a href="#id2879627">§</a>Exodus: 1971–1980</h4>
<p>
  The original Unix operating system was written in assembler, and
the applications in a mix of assembler and an interpreted language
called B, which had the virtue that it was small enough to run on the
PDP-7.  But B
was not powerful enough for systems programming, so Dennis Ritchie
added data types and structures to it.  The resulting C
language
  evolved
from B beginning in 1971; in 1973 Thompson and Ritchie finally
succeeded in rewriting Unix in their new language.  This was quite an
audacious move; at the time, system programming was done in assembler
in order to extract maximum performance from the hardware, and the
very concept of a portable operating system was barely a gleam in
anyone's eye. As late as 1979, Ritchie
  could write: “It seems certain that
much of the success of Unix follows from the readability,
modifiability, and portability of its software that in turn follows
from its expression in high-level languages”, in the knowledge
that this was a point that still needed making.
</p>
 <div class="center">
  <img alt src="data:image/png;base64,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"/>
  <p><strong>Ken (seated) and Dennis (standing) at a PDP-11 in 1972.</strong></p>
 </div>
<p>
  A 1974 paper in
  <em>Communications of the ACM</em> <sup><a href="#Ritchie-Thompson" title="[Ritchie-Thompson]">[Ritchie-Thompson]</a></sup> gave Unix its first public
exposure.  In that paper, its authors described the unprecedentedly
simple design of Unix, and reported over 600 Unix installations. All
were on machines underpowered even by the standards of that day, but
(as Ritchie and Thompson wrote) “constraint has encouraged not
only economy, but also a certain elegance of design”.
</p>
<p>
  After the CACM paper, research labs and universities all over
the world clamored for the chance to try out Unix themselves.  Under a
1958 consent decree in settlement of an antitrust case, AT&amp;T
  (the parent organization of Bell Labs) had
been forbidden from entering the computer business.  Unix could not,
therefore, be turned into a product; indeed, under the terms of
the consent decree, Bell Labs was required to license its nontelephone
technology to anyone who asked.  Ken
Thompson
  quietly began answering requests by shipping out tapes and disk packs
— each, according to legend, with a note signed “love,
ken”.
</p>
<p>
  This was years before personal computers. Not only was the
hardware needed to run Unix too expensive to be within an individual's
reach, but nobody imagined that would change in the foreseeable
future.  So Unix machines were only available by the grace of big
organizations with big budgets: corporations, universities,
government agencies. But use of these minicomputers was less regulated
than the even-bigger mainframes, and Unix development rapidly took on
a countercultural air.  It was the early 1970s; the pioneering Unix
programmers were shaggy hippies and hippie-wannabes.  They delighted
in playing with an operating system that not only offered them
fascinating challenges at the leading edge of computer science, but also
subverted all the technical assumptions and business practices that
went with Big Computing.  Card punches, COBOL, business suits, and
batch IBM
  mainframes were
the despised old wave; Unix
hackers
  reveled in
the sense that they were simultaneously building the future and
flipping a finger at the system.
</p>
<p>
  The excitement of those days is captured in this quote from
Douglas Comer: “Many universities contributed to UNIX. At the
University of Toronto, the department acquired a 200-dot-per-inch
printer/plotter and built software that used the printer to simulate a
phototypesetter. At Yale University, students and computer scientists
modified the UNIX shell. At Purdue University, the Electrical
Engineering Department made major improvements in performance,
producing a version of UNIX that supported a larger number of
users. Purdue also developed one of the first UNIX computer
networks. At the University of California at Berkeley, students
developed a new shell and dozens of smaller utilities. By the late
1970s, when Bell Labs released Version 7 UNIX, it was clear that the
system solved the computing problems of many departments, and that it
incorporated many of the ideas that had arisen in universities. The
end result was a strengthened system. A tide of ideas had started a
new cycle, flowing from academia to an industrial laboratory, back to
academia, and finally moving on to a growing number of commercial
sites” <sup><a href="#Comer" title="[Comer]">[Comer]</a></sup>.
</p>
<p>
  The first Unix of which it can be said that essentially all of
it would be recognizable to a modern Unix programmer was the Version 7
release in 1979.<sup><a href="#ftn.id2879903" id="id2879903">[15]</a></sup>
  The first Unix user group had formed the previous year. By this time
Unix was in use for operations support all through the Bell System<sup><a href="#Hauben" title="[Hauben]">[Hauben]</a></sup>, and had spread to universities as far away
as Australia, where John Lions's 1976 notes <sup><a href="#Lions" title="[Lions]">[Lions]</a></sup> on
the Version 6 source code became the first serious documentation of
the Unix kernel internals.  Many senior Unix hackers still treasure a
copy.
</p>
 <blockquote>
  <p>
   The Lions book was a samizdat publishing sensation.  Because
of copyright infringement or some such it couldn't be published in the
U.S., so copies of copies seeped everywhere.  I still have my copy,
which was at least 6th generation.  Back then you couldn't be a kernel
hacker without a Lions.
  </p>
  <span>
   – Ken Arnold
  </span>
 </blockquote>
<p>
  The beginnings of a Unix industry were coalescing as well.  The
first Unix company (the Santa Cruz Operation, SCO) began operations in
1978, and the first commercial C
  compiler (Whitesmiths) sold that same
year.  By 1980 an obscure software company in Seattle was also getting
into the Unix game, shipping a port of the
AT&amp;T
  version for microcomputers called XENIX.
But Microsoft's
  affection for Unix as a product was not to last very long (though Unix
would continue to be used for most internal development work at the
company until after 1990).
</p>
<h4 id="id2880014"><a href="#id2880014">§</a>TCP/IP and the Unix Wars: 1980-1990</h4>
<p>
  The Berkeley
  campus of the University of California emerged early as the single
most important academic hot-spot in Unix development.  Unix research
had begun there in 1974, and was given a substantial impetus when Ken
Thompson
  taught
at the University during a 1975-76 sabbatical. The first BSD
release
  had been in
1977 from a lab run by a then-unknown grad student named Bill
Joy.  By 1980
Berkeley was the hub of a sub-network of universities actively
contributing to their variant of Unix.  Ideas and code from Berkeley
Unix (including the
vi(1)
editor)
  were feeding back
from Berkeley to Bell Labs.
</p>
<p>
  Then, in 1980, the Defense Advanced Research Projects Agency
needed a team to implement its brand-new
TCP/IP
  protocol stack
on the VAX under Unix.  The PDP-10s
  that
powered the ARPANET at that time were aging, and indications that DEC
might be forced to cancel the 10 in order to support the VAX were
already in the air.  DARPA considered contracting DEC to implement
TCP/IP, but rejected
that idea because they were concerned that DEC might not be responsive
to requests for changes in their proprietary
VAX/VMS
  operating system <sup><a href="#Libes-Ressler" title="[Libes-Ressler]">[Libes-Ressler]</a></sup>. Instead, DARPA
chose Berkeley Unix as a platform — explicitly because its
source code was available and unencumbered <sup><a href="#Leonard" title="[Leonard]">[Leonard]</a></sup>.
</p>
<p>
  Berkeley's
  Computer Science Research Group was in the right place at the right
time with the strongest development tools; the result became arguably
the most critical turning point in Unix's history since its
invention.
</p>
<p>
  Until the TCP/IP
  implementation was released with Berkeley
  4.2 in 1983, Unix
had had only the weakest networking support.  Early experiments with
Ethernet were unsatisfactory.  An ugly but serviceable facility called
UUCP (Unix to Unix Copy Program) had been developed at Bell Labs for
distributing software over conventional telephone lines via modem.<sup><a href="#ftn.id2880193" id="id2880193">[16]</a></sup>
  UUCP could forward Unix mail
between widely separated machines, and (after Usenet was invented in
1981) supported
Usenet, a distributed
bulletin-board facility that allowed users to broadcast text messages
to anywhere that had phone lines and Unix systems.
</p>
<p>
  Still, the few Unix users aware of the bright lights of the
ARPANET felt like they were stuck in a backwater.  No FTP, no telnet,
only the most restricted remote job execution, and painfully slow
links.  Before TCP/IP,
the Internet and Unix cultures did not mix.  Dennis
Ritchie's
  vision of computers as a way to “encourage close
communication” was one of collegial communities clustered
around individual timesharing machines or in the same computing
center; it didn't extend to the continent-wide distributed
‘network nation’ that ARPA users had started to form in
the mid-1970s.  Early ARPANETters, for their part, considered Unix a
crude makeshift limping along on risibly weak hardware.
</p>
<p>
  After TCP/IP,
everything changed. The ARPANET and Unix cultures began to merge at
the edges, a development that would eventually save both from
destruction.  But there would be hell to pay first as the result of
two unrelated disasters; the rise of
Microsoft
  and the
AT&amp;T
  divestiture.
</p>
<p>
  In 1981, Microsoft made its historic deal with
IBM
  over the new IBM
PC. Bill Gates bought QDOS (Quick and Dirty Operating System), a clone
of CP/M that its programmer Tim Paterson had thrown together in six
weeks, from Paterson's employer Seattle Computer Products. Gates,
concealing the IBM deal from Paterson and SCP, bought the rights for
$50,000.  He then talked IBM into allowing Microsoft to market MS-DOS
separately from the PC hardware.  Over the next decade, leveraging
code he didn't write made Bill Gates a multibillionaire, and
business tactics even sharper than the original deal gained Microsoft
a monopoly lock on desktop computing.  XENIX as a product was rapidly
deep-sixed, and eventually sold to SCO.
</p>
<p>
  It was not apparent at the time how successful
(or how destructive)
Microsoft
  was going
to be.  Since the IBM PC-1 didn't have the hardware capacity to run
Unix, Unix people barely noticed it at all (though, ironically enough,
DOS 2.0 eclipsed CP/M largely because Microsoft's co-founder Paul Allen
merged in Unix features including subdirectories and
pipes).  There were
things that seemed much more interesting going on — like the
1982 launching of Sun Microsystems.
</p>
<p>
  Sun Microsystems
  founders Bill
Joy, Andreas
Bechtolsheim, and Vinod Khosla set out to build a dream Unix machine
with built-in networking capability.  They combined hardware designed
at Stanford with the Unix developed at Berkeley to produce a smashing
success, and founded the workstation industry.  At the time, nobody
much minded watching source-code access to one branch of the Unix tree
gradually dry up as Sun began to behave less like a freewheeling
startup and more like a conventional
firm. Berkeley
  was
still distributing BSD
  with source code. Officially, System
III
  source
licenses cost $40,000 each; but Bell Labs was turning a blind eye to
the number of bootleg Bell Labs Unix tapes in circulation, the
universities were still swapping code with Bell Labs, and it looked
like Sun's
  commercialization of Unix might just be the best thing to happen to it
yet.
</p>
<p>
  1982 was also the year that C
  first showed signs of establishing
itself outside the Unix world as the systems-programming language of
choice.  It would only take about five years for
C
  to drive machine
assemblers almost completely out of use.  By the early 1990s C and
C++
  would dominate not
only systems but application programming; by the late 1990s all other
conventional compiled languages would be effectively obsolete.
</p>
<p>
  When DEC canceled development on the
PDP-10's
  successor
machine (Jupiter) in 1983, VAXes running Unix began to take over as
the dominant Internet machines, a position they would hold until being
displaced by Sun workstations.  By 1985, about 25% of all VAXes
would be running Unix despite DEC's stiff opposition.  But the
longest-term effect of the Jupiter cancellation was a less obvious
one; the death of the MIT AI Lab's PDP-10-centered hacker culture
motivated a programmer named Richard
Stallman
  to begin writing GNU, a complete free clone of Unix.
</p>
<p>
  By 1983 there were no fewer than six Unix-workalike
operating systems for the IBM-PC: uNETix, Venix, Coherent, QNX, Idris,
and the port hosted on the Sritek PC daughtercard.  There was still no
port of Unix in either the
System V
  or
BSD
  versions;
both groups considered the 8086 microprocessor woefully
underpowered and wouldn't go near it.  None of the Unix-workalikes
were significant as commercial successes, but they indicated a
significant demand for Unix on cheap hardware that the major vendors
were not supplying.  No individual could afford to meet it, either,
not with the $40,000 price-tag on a source-code license.
</p>
<p>
  Sun
  was already a success (with imitators!) when, in 1983, the
U.S. Department of Justice won its second antitrust case against
AT&amp;T
  and broke
up the Bell System.  This relieved AT&amp;T from the 1958 consent
decree that had prevented them from turning Unix into a product.
AT&amp;T promptly rushed to commercialize Unix System V—a move
that nearly killed Unix.
</p>
 <blockquote>
  <p>
   So true.  But their marketing did spread Unix internationally.
  </p>
  <span>
   – Ken Thompson
  </span>
 </blockquote>
<p>
  Most Unix boosters thought that the
divestiture
  was great news. We thought we saw in
the post-divestiture AT&amp;T, Sun Microsystems, and Sun's smaller imitators the
nucleus of a healthy Unix industry — one that, using inexpensive
68000-based workstations, would challenge and eventually break the
oppressive monopoly that then loomed over the computer industry
— IBM's.
</p>
<p>
  What none of us realized at the time was that the productization
of Unix would destroy the free exchanges of source code that had nurtured
so much of the system's early vitality.  Knowing no other model than
secrecy for collecting profits from software and no other model than
centralized control for developing a commercial product, AT&amp;T
clamped down hard on source-code distribution.  Bootleg Unix tapes became
far less interesting in the knowledge that the threat of lawsuit might
come with them.  Contributions from universities began to dry up.
</p>
<p>
  To make matters worse, the big new players in the Unix market
promptly committed major strategic blunders.  One was to seek
advantage by product differentiation — a tactic which resulted
in the interfaces of different Unixes diverging.  This threw away
cross-platform compatibility and fragmented the Unix market.
</p>
<p>
  The other, subtler error was to behave as if personal computers
and Microsoft
  were
irrelevant to Unix's prospects.  Sun
Microsystems
  failed to see that commoditized PCs would inevitably become an attack
on its workstation market from below.
AT&amp;T, fixated on
minicomputers and mainframes, tried several different strategies to
become a major player in computers, and badly botched all of them.  A
dozen small companies formed to support Unix on PCs; all were
underfunded, focused on selling to developers and engineers, and never
aimed at the business and home market that Microsoft was
targeting.
</p>
<p>
  In fact, for years after divestiture the Unix community was
preoccupied with the first phase of the Unix
wars
  — an
internal dispute, the rivalry between System
V Unix
  and BSD
Unix. The dispute
had several levels, some technical (sockets vs. streams,
BSD
  tty vs. System V
termio) and some cultural.  The divide was roughly between
longhairs and shorthairs; programmers and technical people tended to
line up with Berkeley and BSD, more business-oriented types with AT&amp;T
and System V.
The longhairs, repeating a theme from Unix's early days ten years
before, liked to see themselves as rebels against a corporate empire;
one of the small companies put out a poster showing an X-wing-like
space fighter marked “BSD” speeding away from a huge
AT&amp;T ‘death star’ logo left broken and in flames. Thus
we fiddled while Rome burned.
</p>
<p>
  But something else happened in the year of the
AT&amp;T divestiture that would have more long-term importance for
Unix.  A programmer/linguist named Larry Wall quietly invented the
patch(1)
utility.  The
  <em>patch</em> program, a simple tool
that applies changebars generated by
diff(1)
to a base file, meant that Unix developers could cooperate by passing
around patch sets — incremental changes to code — rather
than entire code files.  This was important not only because patches
are less bulky than full files, but because patches would often apply
cleanly even if much of the base file had changed since the
patch-sender fetched his copy.  With this tool, streams of development
on a common source-code base could diverge, run in parallel, and
re-converge.  The
  <em>patch</em> program did more
than any other single tool to enable collaborative development over
the Internet — a method that would revitalize Unix after
1990.
</p>
<p>
  In 1985 Intel shipped the first 386 chip, capable of addressing 4
gigabytes of memory with a flat address space.  The clumsy segment
addressing of the 8086 and 286 became immediately obsolete.  This was
big news, because it meant that for the first time, a microprocessor in
the dominant Intel family had the capability to run Unix without
painful compromises.  The handwriting was on the wall for
Sun
  and the
other workstation makers.  They failed to see it.
</p>
<p>
  1985 was also the year that Richard
Stallman
  issued the GNU manifesto <sup><a href="#Stallman" title="[Stallman]">[Stallman]</a></sup> and launched the
Free Software Foundation.  Very few people took him or his
GNU
  project
seriously, a judgment that turned out to be seriously mistaken.  In
an unrelated development of the same year, the originators of the X
window system released it as source code without royalties,
restrictions, or license code.  As a direct result of this decision,
it became a safe neutral area for collaboration between Unix vendors,
and defeated proprietary contenders to become Unix's graphics
engine.
</p>
<p>
  Serious standardization efforts aimed at reconciling the System
V
  and
Berkeley
  APIs also
began in 1983 with the /usr/group standard. This was followed in 1985
by the POSIX
  standards, an
effort backed by the IEEE.  These described the intersection set of
the BSD
  and SVR3
(System V Release 3)
  calls, with the superior Berkeley signal
handling and job control but with SVR3 terminal control.  All later
Unix standards would incorporate POSIX at their core, and later Unixes
would adhere to it closely. The only major addition to the modern Unix
kernel API to come afterwards was BSD sockets.
</p>
<p>
  In 1986 Larry Wall, previously the inventor of
patch(1),
began work on Perl, which would become the first and most
widely used of the open-source scripting languages. In early 1987 the
first version of the GNU C compiler
  appeared, and by the end of 1987 the
core of the GNU toolset was falling into place
  : editor, compiler, debugger, and
other basic development tools.  Meanwhile, the X windowing
system
  was
beginning to show up on relatively inexpensive workstations. Together,
these would provide the armature for the open-source Unix developments
of the 1990s.
</p>
<p>
  1986 was also the year that PC technology broke free of IBM's
grip.  IBM, still trying
to preserve a price-vs.-power curve across its product line that would
favor its high-margin mainframe business, rejected the 386 for most of
its new line of PS/2 computers in favor of the weaker 286.  The PS/2
series, designed around a proprietary bus architecture to lock out
clonemakers, became a colossally expensive failure.<sup><a href="#ftn.id2885728" id="id2885728">[17]</a></sup>
  Compaq, the most aggressive of the
clonemakers, trumped IBM's move by releasing the first 386 machine.
Even with a clock speed of a mere 16 MHz, the 386 made a tolerable Unix
machine.  It was the first PC of which that could be said.
</p>
<p>
  It was beginning to be possible to imagine that
Stallman's
  GNU project
  might mate with 386 machines to produce
Unix workstations almost an order of magnitude less costly than anyone
was offering.  Curiously, no one seems to have actually got this far
in their thinking.  Most Unix programmers, coming from the
minicomputer and workstation worlds, continued to disdain cheap 80x86
machines in favor of more elegant 68000-based designs.  And, though a
lot of programmers contributed to the GNU
project, among
Unix people it tended to be considered a quixotic gesture that was
unlikely to have near-term practical consequences.
</p>
<p>
  The Unix community had never lost its rebel streak.  But in
retrospect, we were nearly as blind to the future bearing down on us
as IBM
  or
AT&amp;T.  Not even
Richard Stallman, who had declared a moral crusade against
proprietary software a few years before, really understood how badly
the productization of Unix had damaged the community around it; his
concerns were with more abstract and long-term issues.  The rest of us
kept hoping that some clever variation on the corporate formula would
solve the problems of fragmentation, wretched marketing, and strategic
drift, and redeem Unix's pre-divestiture
promise.  But worse was still to
come.
</p>
<p>
  1988 was the year Ken Olsen (CEO of DEC) famously described Unix
as “snake oil”.  DEC had been shipping its own variant of
Unix on PDP-11s
  since
1982, but really wanted the business to go to its proprietary
VMS
  operating system.  DEC and the minicomputer industry were in deep
trouble, swamped by waves of powerful low-cost machines coming out of
Sun Microsystems
  and the rest of the workstation
vendors. Most of those workstations ran Unix.
</p>
<p>
  But the Unix industry's own problems were growing more severe.
In 1988 AT&amp;T took a 20% stake in Sun Microsystems.  These two
companies, the leaders in the Unix market, were beginning to wake up
to the threat posed by PCs, IBM, and Microsoft, and to realize that
the preceding five years of bloodletting had gained them little.  The
AT&amp;T/Sun alliance and the development of technical standards around
POSIX
  eventually healed
the breach between the System V
  and BSD Unix
  lines.  But the second phase of the Unix
wars
  began when the
second-tier vendors (IBM,
DEC, Hewlett-Packard, and others) formed the Open Software Foundation
and lined up against the AT&amp;T/Sun axis (represented by Unix
International).  More rounds of Unix fighting Unix ensued.
</p>
<p>
  Meanwhile,
Microsoft
  was
making billions in the home and small-business markets that the
warring Unix factions had never found the will to address. The 1990
release of Windows 3.0 — the first successful graphical
operating system from Redmond — cemented Microsoft's dominance,
and created the conditions that would allow them to flatten and
monopolize the market for desktop applications in the 1990s.
</p>
<p>
  The years from 1989 to 1993 were the darkest in Unix's history.
It appeared then that all the Unix community's dreams had failed.
Internecine warfare had reduced the proprietary Unix industry to a
squabbling shambles that never summoned either the determination or
the capability to challenge Microsoft.  The elegant Motorola chips
favored by most Unix programmers had lost out to Intel's ugly but
inexpensive processors.  The GNU project
  failed to produce the free Unix kernel
it had been promising since 1985, and after years of excuses
its credibility was beginning to wear thin.  PC technology was being
relentlessly corporatized.  The pioneering Unix
hackers
  of the 1970s
were hitting middle age and slowing down.  Hardware was getting
cheaper, but Unix was still too expensive.  We were belatedly becoming
aware that the old monopoly of
IBM
  had yielded to a
newer monopoly of
Microsoft, and
Microsoft's mal-engineered software was rising around us like a tide
of sewage.
</p>
<h4 id="id2886020"><a href="#id2886020">§</a>Blows against the Empire: 1991-1995</h4>
<p>
  The first glimmer of light in the darkness was the 1990 effort
by William Jolitz to port BSD
  onto a 386 box, publicized by a series of
magazine articles beginning in 1991.  The 386BSD port was possible because,
partly influenced by Stallman,
Berkeley
  hacker
Keith Bostic
  had begun an effort to clean AT&amp;T proprietary code out of the BSD
sources in 1988.  But the 386BSD project took a severe blow when, near
the end of 1991, Jolitz walked away from it and destroyed his own
work.  There are conflicting explanations, but a common thread in all
is that Jolitz wanted his code to be released as unencumbered source
and was upset when the corporate sponsors of the project opted for a
more proprietary licensing model.
</p>
<p>
  In August 1991 Linus Torvalds, then an unknown university student from
Finland, announced the Linux
  project.  Torvalds is on record that one
of his main motivations was the high cost of Sun's
  Unix at his university.  Torvalds
has also said that he would have joined the BSD
  effort had he known of it, rather than
founding his own.  But 386BSD was not shipped until early 1992, some
months after the first Linux release.
</p>
<p>
  The importance of both these projects became clear only in
retrospect. At the time, they attracted little notice even within the
Internet hacker culture — let alone in the wider Unix community,
which was still fixated on more capable machines than PCs, and on
trying to reconcile the special properties of Unix with the
conventional proprietary model of a software business.
</p>
<p>
  It would take another two years and the great Internet explosion
of 1993–1994 before the true importance of
Linux
  and the
open-source
  BSD
  distributions
became evident to the rest of the Unix world.  Unfortunately for the
BSDers, an AT&amp;T
  lawsuit against BSDI (the startup company that had backed the Jolitz
port) consumed much of that time and motivated some key
Berkeley
  developers
to switch to Linux.
</p>
 <blockquote>
  <p>
   Code copying and theft of trade secrets was alleged. The actual
infringing code was not identified for nearly two years. The lawsuit
could have dragged on for much longer but for the fact that Novell
bought USL from AT&amp;T and sought a settlement. In the end, three files
were removed from the 18,000 that made up the distribution, and a
number of minor changes were made to other files. In addition, the
University agreed to add USL copyrights to about 70 files, with the
stipulation that those files continued to be freely redistributed.
  </p>
  <span>
   – Marshall Kirk McKusick
  </span>
 </blockquote>
<p>
  The settlement set an important precedent by freeing an entire working Unix from proprietary control, but its effects
  on BSD itself were dire.  Matters were not helped when, in 1992–1994, the Computer Science Research Group at Berkeley
  shut down; afterwards, factional warfare within the BSD community split it into three competing development efforts.
  As a result, the BSD lineage lagged behind Linux at a crucial time and lost to it the lead position in the Unix
  community.
</p>
<p>
  The Linux
  and BSD
  development efforts were native to the
Internet in a way previous Unixes had not been.  They relied on
distributed development and Larry Wall's
patch(1)
tool, and recruited developers via email and through
Usenet
  newsgroups.
Accordingly, they got a tremendous boost when Internet Service
Provider businesses began to proliferate in 1993, enabled by changes
in telecomm technology and the privatization of the Internet backbone
that are outside the scope of this history.  The demand for cheap
Internet was created by something else: the 1991 invention of
the World Wide Web.  The Web was the “killer app” of the
Internet, the graphical user interface technology that made it
irresistible to a huge population of nontechnical end users.
</p>
<p>
  The mass-marketing of the Internet both increased the pool of
potential developers and lowered the transaction costs of distributed
development.  The results were reflected in efforts like XFree86,
which used the Internet-centric model to build a more effective
development organization than that of the official X
Consortium.  The
first XFree86 in 1992 gave Linux
  and the BSDs
  the graphical-user-interface engine they
had been missing.  Over the next decade XFree86 would lead in X
development, and an increasing portion of the X Consortium's activity
would come to consist of funneling innovations originated in the
XFree86 community back to the Consortium's industrial sponsors.
</p>
<p>
  By late 1993, Linux
  had both Internet capability and
X. The entire
GNU toolkit had been hosted on it from the beginning, providing
high-quality development tools.  Beyond GNU tools,
Linux
  acted as a basin of attraction,
collecting and concentrating twenty years of open-source software that
had previously been scattered across a dozen different proprietary
Unix platforms.  Though the Linux kernel was still officially in beta
(at 0.99 level), it was remarkably crash-free.  The breadth and
quality of the software in Linux
  distributions was already that of a
production-ready operating system.
</p>
<p>
  A few of the more flexible-minded among old-school Unix
developers began to notice that the long-awaited dream of a cheap Unix
system for everybody had snuck up on them from an unexpected direction.
It didn't come from
AT&amp;T
  or
Sun
  or any
of the traditional vendors. Nor did it rise out of an organized effort
in academia.  It was a bricolage that bubbled up out of the Internet
by what seemed like spontaneous generation, appropriating and
recombining elements of the Unix tradition in surprising ways.
</p>
<p>
  Elsewhere, corporate maneuvering continued.
AT&amp;T
  divested
its interest in Sun in 1992; then sold its Unix Systems Laboratories
to Novell in 1993; Novell handed off the Unix trademark to the X/Open
standards group in 1994; AT&amp;T and Novell joined OSF in 1994,
finally ending the Unix wars.  In 1995 SCO bought UnixWare (and the
rights to the original Unix sources) from Novell.  In 1996, X/Open and
OSF merged, creating one big Unix standards group.
</p>
<p>
  But the conventional Unix vendors and the wreckage of their wars
came to seem steadily less and less relevant.  The action and energy
in the Unix community were shifting to Linux
  and BSD
  and the open-source
  developers.  By the time
IBM, Intel, and SCO
announced the Monterey project in 1998 — a last-gasp attempt to
merge One Big System out of all the proprietary Unixes left standing
— developers and the trade press reacted with amusement, and the
project was abruptly canceled in 2001 after three years of going
nowhere.
</p>
<p>
  The industry transition could not be said to have completed
until 2000, when SCO sold UnixWare and the original Unix source-code
base to Caldera — a Linux distributor. But after 1995, the story
of Unix became the story of the open-source movement.  There's another
side to that story; to tell it, we'll need to return to 1961 and the 
origins of the Internet hacker culture.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2881371" id="ftn.id2881371">[13]</a></sup>
  Ken Thompson
reminded me that today's cellphones have more RAM than the PDP-7 had
RAM and disk storage combined; a
  <span class="emphasis">
   <em>large</em>
  </span>
  disk, in
those days, was less than a megabyte of storage.
</p>

<p><sup><a href="#id2881412" id="ftn.id2881412">[14]</a></sup>
  There is a Web FAQ on the
  <a href="http://www.faqs.org/faqs/dec-faq/pdp8/">
   PDP computers</a>
  that explains the otherwise extremely obscure PDP-7's place in
history.
</p>

<p><sup><a href="#id2879903" id="ftn.id2879903">[15]</a></sup>
  The version 7 manuals can be browsed
on-line at
  <a href="http://plan9.bell-labs.com/7thEdMan/index.html">
   http://plan9.bell-labs.com/7thEdMan/index.html</a>.
</p>
</div>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2880193" id="ftn.id2880193">[16]</a></sup>
  UUCP was hot stuff when a
  <span class="emphasis">
   <em>fast</em>
  </span>
  modem was 300 baud.
</p>

<p><sup><a href="#id2885728" id="ftn.id2885728">[17]</a></sup>
  The
PS/2 did, however, leave one mark on later PCs — they made the
mouse a standard peripheral, which is why the mouse connector on the
back of your chassis is called a “PS/2
port”.
</p>
</div>


<!-- FILE: hackers.html -->
<h3 id="hackers"><a href="#hackers">§</a>Origins and History of the Hackers, 1961-1995</h3>
<p>
  The Unix tradition is an implicit culture that has always
carried with it more than just a bag of technical tricks. It transmits
a set of values about beauty and good design; it has legends and folk
heroes.  Intertwined with the history of the Unix tradition is another
implicit culture that is more difficult to label neatly.  It has its
own values and legends and folk heroes, partly overlapping with those
of the Unix tradition and partly derived from other sources.  It has
most often been called the “hacker culture”, and since
1998 has largely coincided with what the computer trade press calls
“the open source movement”.
</p>
<p>
  The relationships between the Unix tradition, the hacker
culture, and the open-source movement are subtle and complex.  They
are not simplified by the fact that all three implicit cultures have
frequently been expressed in the behaviors of the same human beings.
But since 1990 the story of Unix is largely the story of how the
open-source hackers changed the rules and seized the initiative from
the old-line proprietary Unix vendors.  Therefore, the other half of
the history behind today's Unix is the history of the hackers.
</p>
<h4 id="id2886621"><a href="#id2886621">§</a>At Play in the Groves of Academe: 1961-1980</h4>
<p>
  The roots of the hacker culture can be traced back to 1961, the
year MIT took delivery of its first PDP-1
  minicomputer. The PDP-1 was one of the earliest interactive computers,
and (unlike other machines) of the day was inexpensive enough that time
on it did not have to be rigidly scheduled.  It attracted a group of
curious students from the Tech Model Railroad Club who experimented
with it in a spirit of fun.
  <em>Hackers: Heroes of the Computer Revolution</em><sup><a href="#Levy" title="[Levy]">[Levy]</a></sup>
entertainingly describes the early days of the club.  Their most
famous achievement was SPACEWAR, a game of dueling rocketships loosely
inspired by the
  <em>Lensman</em> space operas of
E.E. “Doc” Smith.<sup><a href="#ftn.id2886667" id="id2886667">[18]</a></sup>
</p>
<p>
  Several of the TMRC experimenters later went on to become core
members of the MIT Artificial Intelligence Lab, which in the 1960s and
1970s became one of the world centers of cutting-edge computer
science.  They took some of TMRC's slang and in-jokes with them,
including a tradition of elaborate (but harmless) pranks called
“hacks”.  The AI Lab programmers appear to have been
the first to describe themselves as “hackers”.
</p>
<p>
  After 1969 the MIT AI Lab was connected, via the early ARPANET, to
other leading computer science research laboratories at Stanford, Bolt
Beranek &amp; Newman, Carnegie-Mellon University and elsewhere.
Researchers and students got the first foretaste of the way fast
network access abolishes geography, often making it easier to
collaborate and form friendships with distant people on the net than
it would be to do likewise with colleagues closer-by but less
connected.
</p>
<p>
  Software, ideas, slang, and a good deal of humor flowed over the
experimental ARPANET links.  Something like a shared culture began to
form.  One of its earliest and most enduring artifacts was the Jargon
File, a list of shared slang terms that originated at Stanford in 1973
and went through several revisions at MIT after 1976.  Along the way
it accumulated slang from CMU, Yale, and other ARPANET sites.
</p>
<p>
  Technically, the early hacker culture was largely hosted on
PDP-10 minicomputers.  They
used a variety of operating systems that have since passed into
history: TOPS-10, TOPS-20, Multics, ITS, SAIL.  They programmed in
assembler and dialects of Lisp. PDP-10 hackers took over running the ARPANET
itself because nobody else wanted the job. Later, they became the
founding cadre of the Internet Engineering Task Force
(IETF)
  and originated
the tradition of standardization through Requests For Comment
(RFCs).
</p>
<p>
  Socially, they were young, exceptionally bright, almost entirely
male, dedicated to programming to the point of addiction, and tended
to have streaks of stubborn nonconformism — what years later
would be called ‘geeks’.  They, too, tended to be shaggy
hippies and hippie-wannabes.  They, too, had a vision of computers
as community-building devices.  They read Robert Heinlein and
J. R. R. Tolkien, played in the Society for Creative Anachronism, and
tended to have a weakness for puns.  Despite their quirks (or perhaps
because of them!) many of them were among the brightest programmers in
the world.
</p>
<p>
  They were
  <em>not</em>
  Unix programmers.  The early
Unix community was drawn largely from the same pool of geeks in
academia and government or commercial research laboratories, but the
two cultures differed in important ways.  One that we've already 
touched on is the weak networking of early Unix.  There was
effectively no Unix-based ARPANET access until after 1980, and it
was uncommon for any individual to have a foot in both camps.
</p>
<p>
  Collaborative development and the sharing of source code was a
valued tactic for Unix programmers.  To the early ARPANET hackers, on
the other hand, it was more than a tactic: it was something
rather closer to a shared religion, partly arising from the academic
“publish or perish” imperative and (in its more extreme
versions) developing into an almost Chardinist idealism about
networked communities of minds.  The most famous of these hackers,
Richard M. Stallman, became the ascetic saint of that
religion.
</p>
<h4 id="id2886828"><a href="#id2886828">§</a>Internet Fusion and the Free Software Movement: 1981-1991</h4>
<p>
  After 1983 and the BSD
  port of
TCP/IP, the Unix and
ARPANET cultures began to fuse together.  This was a natural
development once the communication links were in place, since both
cultures were composed of the same kind of people (indeed, in a few
but significant cases the
  <em>same</em>
  people).  ARPANET
hackers learned C
  and began to speak the jargon of pipes, filters, and shells; Unix
programmers learned
TCP/IP
  and started to
call each other “hackers”.  The process of fusion was
accelerated after the Project Jupiter cancellation in 1983 killed the
PDP-10's
  future.
By 1987 the two cultures had merged so completely that most hackers
programmed in C and casually used slang terms that went back to the
Tech Model Railroad Club of twenty-five years earlier.
</p>
<p>
  (In 1979 I was unusual in having strong ties to both the Unix
and ARPANET cultures.  In 1985 that was no longer unusual. By the time
I expanded the old ARPANET Jargon File into the
  <em>New Hacker's Dictionary</em><sup><a href="#Raymond96" title="[Raymond96]">[Raymond96]</a></sup> in 1991,
the two cultures had effectively fused.  The Jargon File, born on the
ARPANET but revised on
Usenet, aptly
symbolized the merger.)
</p>
<p>
  But TCP/IP networking and slang were not the only things the
post-1980 hacker culture inherited from its ARPANET roots.  It also
got Richard Stallman, and Stallman's moral crusade.
</p>
<p>
  Richard M. Stallman
  (generally known by his login name, RMS) had
already proved by the late 1970s that he was one of the most able
programmers alive.  Among his many inventions was the Emacs editor.
For RMS, the Jupiter cancellation in 1983 only finished off a
disintegration of the MIT AI Lab culture that had begun a few years
earlier as many of its best went off to help run competing
Lisp-machine companies.  RMS felt ejected from a hacker Eden, and
decided that proprietary software was to blame.
</p>
<p>
  In 1983 Stallman founded the GNU project, aimed at writing an entire free
operating system.  Though Stallman was not and had never been a Unix
programmer, under post-1980 conditions implementing a Unix-like
operating system became the obvious strategy to pursue.  Most of RMS's
early contributors were old-time ARPANET hackers newly decanted into
Unix-land, in whom the ethos of code-sharing ran rather stronger than
it did among those with a more Unix-centered background.
</p>
<p>
  In 1985, RMS published the GNU Manifesto. In it he consciously
created an ideology out of the values of the pre-1980 ARPANET hackers
— complete with a novel ethico-political claim, a self-contained
and characteristic discourse, and an activist plan for change. RMS
aimed to knit the diffuse post-1980 community of hackers into a
coherent social machine for achieving a single revolutionary
purpose. His behavior and rhetoric half-consciously echoed Karl Marx's
attempts to mobilize the industrial proletariat against the alienation
of their work.
</p>
<p>
  RMS's manifesto ignited a debate that is still live in the
hacker culture today.  His program went way beyond maintaining a
codebase, and essentially implied the abolition of
intellectual-property rights in software. In pursuit of this goal, RMS
popularized the term “free software”, which was the first
attempt to label the product of the entire hacker culture. He wrote
the General Public License (GPL), which was to become both a rallying
point and a focus of great controversy, for reasons we will examine in
  <a href="#reusechapter" title="Chapter 16. Reuse">Chapter 16</a>. You can learn more
about RMS's position and the Free Software Foundation at the <a href="http://www.gnu.org">GNU website</a>.
</p>
<p>
  The term “free software” was partly a description
and partly an attempt to define a cultural identity for hackers. On
one level, it was quite successful. Before RMS, people in the hacker
culture recognized each other as fellow-travelers and used the same
slang, but nobody bothered arguing about what a ‘hacker’
is or should be. After him, the hacker culture became much more
self-conscious; value disputes (often framed in RMS's language even by
those who opposed his conclusions) became a normal feature of
debate. RMS, a charismatic and polarizing figure, himself became so
much a culture hero that by the year 2000 he could hardly be
distinguished from his legend.
  <em>Free as in Freedom</em><sup><a href="#Williams" title="[Williams]">[Williams]</a></sup> gives
us an excellent portrait.
</p>
<p>
  RMS's arguments influenced the behavior even of many hackers who
remained skeptical of his theories.  In 1987, he persuaded the
caretakers of BSD Unix
  that cleaning out AT&amp;T's proprietary
code so they could release an unencumbered version would be a good
idea.  However, despite his determined efforts over more than fifteen
years, the post-1980 hacker culture never unified around his
ideological vision.
</p>
<p>
  Other hackers were rediscovering open, collaborative development
without secrets for more pragmatic, less ideological reasons.  A few
buildings away from Richard Stallman's 9th-floor office at MIT, the X
development
  team thrived during the late 1980s.  It was funded by Unix vendors who
had argued each other to a draw over the control and
intellectual-property-rights issues surrounding the X windowing
system, and saw no better alternative than to leave it free to
everyone. In 1987–1988 the X development prefigured the really huge
distributed communities that would redefine the leading edge of Unix
five years later.
</p>
 <blockquote>
  <p>
   X was one of the first large-scale open-source projects to be
developed by a disparate team of individuals working for different
organizations spread across the globe.  E-mail allowed ideas to move
rapidly among the group so that issues could be resolved as quickly as
necessary, and each individual could contribute in whatever capacity
suited them best.  Software updates could be distributed in a matter
of hours, enabling every site to act in a concerted manner during
development.  The net changed the way software could be
developed.
  </p>
  <span>
   – Keith Packard
  </span>
 </blockquote>
<p>
  The X developers were no partisans of the GNU master
plan, but they
weren't actively opposed to it, either.  Before 1995 the most serious
opposition to the GNU plan
  came from the BSD
  developers. The BSD
people, who
remembered that they had been writing freely redistributable and
modifiable software years before RMS's
manifesto, rejected GNU's claim to historical and ideological
primacy. They specifically objected to the infectious or
“viral” property of the GPL, holding out the BSD license
as being “more free” because it placed fewer restrictions
on the reuse of code.
</p>
<p>
  It did not help RMS's case that, although his Free Software
Foundation had produced most of the rest of a full software toolkit,
it failed to deliver the central piece.  Ten years after the founding
of the GNU project, there was still no GNU kernel.  While
individual tools like Emacs and GCC proved tremendously useful, GNU
without a kernel neither threatened the hegemony of proprietary Unixes
nor offered an effective counter to the rising problem of the
Microsoft
  monopoly.
</p>
<p>
  After 1995 the debate over RMS's ideology took a somewhat
different turn.  Opposition to it became closely associated with both
Linus Torvalds
  and the author of this
book.
</p>
<h4 id="linux_reaction"><a href="#linux_reaction">§</a>Linux and the Pragmatist Reaction: 1991-1998</h4>
<p>
  Even as the HURD (the GNU kernel) effort was stalling, new
possibilities were opening up.  In the early 1990s the combination of
cheap, powerful PCs with easy Internet access proved a powerful lure
for a new generation of young programmers looking for challenges to
test their mettle.  The user-space toolkit written by the Free
Software Foundation suggested a way forward that was free of the high
cost of proprietary software development tools.  Ideology followed
economics rather than leading the charge; some of the newbies signed
up with RMS's crusade and adopted the GPL as their banner, and others
identified more with the Unix tradition as a whole and joined the
anti-GPL camp, but most dismissed the whole dispute as a
distraction and just wrote code.
</p>
<p>
  Linus Torvalds
  neatly straddled the GPL/anti-GPL divide
by using the GNU toolkit to surround the Linux kernel he had invented
and the GPL's infectious properties to protect it, but rejecting the
ideological program that went with RMS's license. Torvalds affirmed
that he thought free software better in general but occasionally used
proprietary programs. His refusal to be a zealot even in his own cause
made him tremendously attractive to the majority of hackers who had
been uncomfortable with RMS's rhetoric, but had lacked any focus or
convincing spokesperson for their skepticism.
</p>
<p>
  Torvalds's cheerful pragmatism and adept but low-key style
catalyzed an astonishing string of victories for the hacker culture in
the years 1993–1997, including not merely technical successes
but the solid beginnings of a distribution, service, and support
industry around the Linux operating system.  As a result his prestige
and influence skyrocketed.  Torvalds became a hero on Internet time;
by 1995, he had achieved in just four years the kind of culture-wide
eminence that RMS had required fifteen years to earn — and far
exceeded Stallman's
  record at selling “free
software” to the outside world.  By contrast with Torvalds,
RMS's rhetoric began to seem both strident and unsuccessful.
</p>
<p>
  Between 1991 and 1995 Linux
  went from a proof-of-concept surrounding
an 0.1 prototype kernel to an operating system that could compete on
features and performance with proprietary Unixes, and beat most of
them on important statistics like continuous uptime.  In 1995, Linux
found its killer app: Apache, the
open-source webserver.  Like Linux, Apache proved remarkably stable
and efficient.  Linux machines running Apache quickly became the platform
of choice for ISPs worldwide; Apache captured about 60% of
websites,<sup><a href="#ftn.id2887399" id="id2887399">[19]</a></sup>
  handily beating out both of its
major proprietary competitors.
</p>
<p>
  The one thing Torvalds did not offer was a new ideology —
a new rationale or generative myth of hacking, and a positive
discourse to replace RMS's hostility to intellectual property with a
program more attractive to people both within and outside the hacker
culture.  I
inadvertently supplied this lack in 1997 as a result of trying to
understand why Linux's development had not collapsed in confusion
years before. The technical conclusions of my published papers <sup><a href="#Raymond01" title="[Raymond01]">[Raymond01]</a></sup>
  will be summarized in
  <a href="#opensourcechapter" title="Chapter 19. Open Source">Chapter 19</a>. For this historical sketch, it will be
sufficient to note the impact of the first one's central formula: “Given a sufficiently large number of eyeballs, all
bugs are shallow”.
</p>
<p>
  This observation implied something nobody in the hacker culture had
dared to really believe in the preceding quarter-century: that its
methods could reliably produce software that was not just more elegant
but more reliable and
  <em>better</em>
  than our proprietary
competitors' code. This consequence, quite unexpectedly, turned out to
present exactly the direct challenge to the discourse of “free
software” that Torvalds himself had never been interested in
mounting. For most hackers and almost all nonhackers, “Free
software because it works better” easily trumped “Free
software because all software should be free”.
</p>
<p>
  The paper's contrast between ‘cathedral’
(centralized, closed, controlled, secretive) and ‘bazaar’
(decentralized, open, peer-review-intensive) modes of development
became a central metaphor in the new thinking.  In an important sense
this was merely a return to Unix's pre-divestiture roots — it is
continuous with McIlroy's
  1991 observations about the positive
effects of peer pressure on Unix development in the early 1970s and
Dennis Ritchie's
  1979 reflections on fellowship,
cross-fertilized with the early ARPANET's academic tradition of peer
review and with its idealism about distributed communities of mind.
</p>
<p>
  In early 1998, the new thinking helped motivate Netscape
Communications to release the source code of its Mozilla
browser. The press attention surrounding that event took Linux to Wall
Street, helped drive the technology-stock boom of 1999–2001, and
proved to be a turning point in both the history of the hacker culture
and of Unix.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2886667" id="ftn.id2886667">[18]</a></sup>
  SPACEWAR was not related to Ken
Thompson's Space Travel game, other than by the fact that both
appealed to science-fiction fans.
</p>

<p><sup><a href="#id2887399" id="ftn.id2887399">[19]</a></sup>
  Current and historical webserver share figures
are available at the monthly
  <a href="http://www.netcraft.com/survey/">
   Netcraft Web Server
Survey</a>.
</p>
</div>


<!-- FILE: ch02s03.html -->
<h3 id="ch02s03"><a href="#ch02s03">§</a>The Open-Source Movement: 1998 and Onward</h3>
<p>
  By the time of the Mozilla release in 1998, the hacker community
could best be analyzed as a loose collection of factions or tribes
that included Richard Stallman's
  Free Software Movement, the Linux community,
the Perl
  community, the
Apache
  community, the
BSD community, the X
developers, the Internet Engineering Task Force
(IETF), and at least a
dozen others.  These factions overlap, and an individual developer
would be quite likely to be affiliated with two or more.
</p>
<p>
  A tribe might be grouped around a particular codebase that they
maintain, or around one or more charismatic influence leaders, or
around a language or development tool, or around a particular software
license, or around a technical standard, or around a caretaker
organization for some part of the infrastructure.  Prestige tends to
correlate with longevity and historical contribution as well as more
obvious drivers like current market-share and mind-share; thus, perhaps the
most universally respected of the tribes is the
IETF, which can claim
continuity back to the beginnings of the ARPANET in 1969. The
BSD
  community, with
continuous traditions back to the late 1970s, commands considerable
prestige despite having a much lower installation count than
Linux. Stallman's
  Free Software Movement, dating back to the
early 1980s, ranks among the senior tribes both on historical
contribution and as the maintainer of several of the software tools in
heaviest day-to-day use.
</p>
<p>
  After 1995 Linux
  acquired a special role as both the
unifying platform for most of the community's other software and the
hackers' most publicly recognizable brand name.  The Linux community
showed a corresponding tendency to absorb other sub-tribes —
and, for that matter, to co-opt and absorb the
hacker
  factions
associated with proprietary Unixes.  The hacker culture as a whole
began to draw together around a common mission: push Linux and
the bazaar development model as far as it could go.
</p>
<p>
  Because the post-1980 hacker
culture
  had become so
deeply rooted in Unix, the new mission was implicitly a brief for the
triumph of the Unix tradition.  Many of the hacker community's senior
leaders were also Unix old-timers, still bearing scars from the
post-divestiture civil wars of the 1980s and getting behind
Linux
  as the last, best hope to fulfill
the rebel dreams of the early Unix days.
</p>
<p>
  The Mozilla release helped further concentrate opinions.  In
March of 1998 an unprecedented summit meeting of community influence
leaders representing almost all of the major tribes convened to
consider common goals and tactics.  That meeting adopted a new label
for the common development method of all the factions: open
source.
</p>
<p>
  Within six months almost all the tribes in the hacker community
would accept “open source” as its new banner.  Older
groups like IETF
  and the
BSD developers would begin to apply it retrospectively to what they
had been doing all along.  In fact, by 2000 the rhetoric of open
source would not just unify the hacker culture's present practice and
plans for the future, but re-color its view of its own past.
</p>
<p>
  The galvanizing effect of the Netscape announcement, and of the
new prominence of Linux, reached well beyond the Unix community and
the hacker culture.  Beginning in 1995, developers from various
platforms in the path of Microsoft's Windows juggernaut (MacOS; Amiga;
OS/2; DOS; CP/M; the weaker proprietary Unixes; various mainframe,
minicomputer, and obsolete microcomputer operating systems) had banded
together around Sun Microsystems's Java
language.  Many
disgruntled Windows developers joined them in hopes of maintaining at
least some nominal independence from Microsoft.  But Sun's handling of
Java was (as we discuss in
  <a href="#languageschapter" title="Chapter 14. Languages">Chapter 14</a>) clumsy and alienating on several levels.
Many Java developers liked what they saw in the nascent open-source
movement, and followed Netscape's lead into Linux and open source just
as they had previously followed Netscape into Java.
</p>
<p>
  Open-source activists welcomed the surge of immigrants from
everywhere.  The old Unix hands began to share the new immigrants'
dreams of not merely passively out-enduring the Microsoft monopoly,
but actually reclaiming key markets from it.  The open-source
community as a whole prepared a major push for mainstream
respectability, and began to welcome alliances with major corporations
that increasingly feared losing control of their own businesses as
Microsoft's lock-in tactics grew ever bolder.
</p>
<p>
  There was one exception: Richard
Stallman
  and the Free Software Movement.  “Open source” was
explicitly intended to replace Stallman's preferred “free
software” with a public label that was ideologically neutral,
acceptable both to historically opposed groups like the
BSD
  hackers and
those who did not wish to take a position in the GPL/anti-GPL debate.
Stallman flirted with adopting the term, then rejected it on the
grounds that it failed to represent the moral position that was
central to his thinking.  The Free Software Movement has since
insisted on its separateness from “open source”,
creating perhaps the most significant political
fissure in the hacker culture of 2003.
</p>
<p>
  The other (and more important) intention behind “open
source” was to present the hacker community's methods to the
rest of the world (especially the business mainstream) in a more
market-friendly, less confrontational way.  In this role, fortunately,
it proved an unqualified success — and led to a revival of
interest in the Unix tradition from which it sprang.
</p>



<!-- FILE: ch02s04.html -->
<h3 id="ch02s04"><a href="#ch02s04">§</a>The Lessons of Unix History</h3>
<p>
  The largest-scale pattern in the history of Unix is this: when
and where Unix has adhered most closely to
open-source
  practices, it has prospered.  Attempts to proprietarize it have
invariably resulted in stagnation and decline.
</p>
<p>
  In retrospect, this should probably have become obvious much
sooner than it did.  We lost ten years after 1984 learning our lesson,
and it would probably serve us very ill to ever again forget
it.
</p>
<p>
  Being smarter than anyone else about important but narrow issues
of software design didn't prevent us from being almost completely
blind about the consequences of interactions between technology and
economics that were happening right under our noses.  Even the most
perceptive and forward-looking thinkers in the Unix community were at
best half-sighted.  The lesson for the future is that over-committing
to any one technology or business model would be a mistake — and
maintaining the adaptive flexibility of our software and the design
tradition that goes with it is correspondingly imperative.
</p>
<p>
  Another lesson is this: Never bet against the cheap plastic
solution. Or, equivalently, the low-end/high-volume hardware
technology almost always ends up climbing the power curve and winning.
The economist Clayton Christensen calls this
  <em>disruptive technology</em>
  and showed in
  <em>The Innovator's Dilemma</em><sup><a href="#Christensen" title="[Christensen]">[Christensen]</a></sup> how this happened
with disk drives, steam shovels, and motorcycles.  We saw it happen as
minicomputers displaced mainframes, workstations and servers replaced
minis, and commodity Intel machines replaced workstations and servers.
The open-source movement is winning by commoditizing software.  To
prosper, Unix needs to maintain the knack of co-opting the cheap
plastic solution rather than trying to fight it.
</p>
<p>
  Finally, the old-school Unix community failed in its efforts to
be “professional” by welcoming in all the command
machinery of conventional corporate organization, finance, and
marketing.  We had to be rescued from our folly by a rebel alliance of
obsessive geeks and creative misfits
  —who then
proceeded to show us that professionalism and dedication really meant
what we had been doing
  <em>before</em>
  we succumbed to the
mundane persuasions of “sound business practices”.
</p>
<p>
  The application of these lessons with respect to software 
technologies other than Unix is left as an easy exercise for the 
reader.
</p>



<!-- FILE: contrastchapter.html -->
<h3 id="contrastchapter"><a href="#contrastchapter">§</a>Chapter 3. Contrasts</h3>
 <blockquote class="epigraph">
  <p>
   If you have any trouble sounding condescending, find a Unix user
to show you how it's done.
  </p>
  <span>
   – Scott Adams
Dilbert newsletter 3.0, 1994
  </span>
 </blockquote>
<p>
  The design of operating systems conditions the style of software
development under them in many ways both obvious and subtle.  Much of
this book traces connections between the design of the Unix operating
system and the philosophy of program design that has evolved around
it.  For contrast, it will therefore be instructive to compare the
classic Unix way with the styles of design and programming native to
other major operating systems.
</p>



<!-- FILE: ch03s01.html -->
<h3 id="ch03s01"><a href="#ch03s01">§</a>The Elements of Operating-System Style</h3>
<p>
  Before we can start discussing specific operating systems, we'll
need an organizing framework for the ways that operating-system
design can affect programming style for good or ill.
</p>
<p>
  Overall, the design and programming styles associated with
different operating systems seem to derive from three different
sources: (a) the intentions of the operating-system designers, (b)
uniformities forced on designs by costs and limitations in the
programming environment, and (c) random cultural drift, early
practices becoming traditional simply because they were there
first.
</p>
<p>
  Even if we take it as given that there is some random cultural
drift in every operating-system community, considering the intentions
of the designers and the costs and limitations of the results does
reveal some interesting patterns that can help us understand the Unix
style better by contrast.  We can make the patterns explicit by
analyzing some of the most important ways that operating systems
differ.
</p>
<h4 id="id2892028"><a href="#id2892028">§</a>What Is the Operating System's Unifying Idea?</h4>
<p>
  Unix has a couple of unifying ideas or metaphors that shape its
APIs and the development style that proceeds from them.  The most
important of these are probably the “everything is a
file” model and the pipe metaphor<sup><a href="#ftn.id2892049" id="id2892049">[20]</a></sup>
  built on top of it.
In general, development style under any given operating system is
strongly conditioned by the unifying ideas baked into the system by
its designers — they percolate upwards into applications
programming from the models provided by system tools and APIs.
</p>
<p>
  Accordingly, the most basic question to ask in contrasting Unix
with another operating system is: Does it have unifying ideas that
shape its development, and if so how do they differ from
Unix's?
</p>
<p>
  To design the perfect anti-Unix, have no unifying idea at all,
just an incoherent pile of ad-hoc features.
</p>
<h4 id="id2892085"><a href="#id2892085">§</a>Multitasking Capability</h4>
<p>
  One of the most basic ways operating systems can differ is in
the extent to which they can support multiple concurrent processes.  At
the lowest end (such as DOS or CP/M) the operating system is basically
a sequential program loader with no capacity to multitask at all.
Operating systems of this kind are no longer competitive on
general-purpose computers.
</p>
<p>
  At the next level up, an operating system may have
  <em>cooperative multitasking</em>.  Such systems can
support multiple processes, but a process has to voluntarily give up
its hold on the processor before the next one can run (thus, simple
programming errors can readily freeze the machine).  This style of
operating system was a transient adaptation to hardware that was
powerful enough for concurrency but lacked either a periodic clock
interrupt<sup><a href="#ftn.id2892115" id="id2892115">[21]</a></sup>
  or a memory-management unit or both; it,
too, is obsolete and no longer competitive.
</p>
<p>
  Unix has
  <em>preemptive multitasking</em>, in
which timeslices are allocated by a scheduler which routinely
interrupts or pre-empts the running process in order to hand control
to the next one.  Almost all modern operating systems support
preemption.
</p>
<p>
  Note that “multitasking” is not the same as
“multiuser”.  An operating system can be multitasking
but single-user, in which case the facility is used to support a
single console and multiple background processes.  True multiuser
support requires multiple user privilege domains, a feature we'll
cover in the discussion of internal boundaries a bit further on.
</p>
<p>
  To design the perfect anti-Unix, don't support multitasking at
all — or, support multitasking but cripple it by surrounding
process management with a lot of restrictions, limitations, and
special cases that mean it's quite difficult to get any actual use out
of multitasking.
</p>
<h4 id="id2892171"><a href="#id2892171">§</a>Cooperating Processes</h4>
<p>
  In the Unix experience, inexpensive process-spawning and easy
inter-process communication (IPC) makes a whole ecology of small
tools, pipes, and
filters possible.  We'll explore this ecology in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">Chapter 7</a>; here, we need to point out some
consequences of expensive process-spawning and IPC.
</p>
 <blockquote>
  <p>
   The pipe was technically trivial, but profound in its effect.
However, it would not have been trivial without the fundamental
unifying notion of the process as an autonomous unit of computation,
with process control being programmable.  As in Multics, a shell was
just another process; process control did not come from God inscribed
in JCL.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  If an operating system makes spawning new processes expensive
and/or process control is difficult and inflexible, you'll usually see
all of the following consequences:
</p>
 <div>
  <ul>
   <li>
    <p>
     Monster monoliths become a more natural way of programming.
    </p>
   </li>
   <li>
    <p>
     Lots of policy has to be expressed within those monoliths. This
encourages C++
     and
elaborately layered internal code organization, rather than C and
relatively flat internal hierarchies.
    </p>
   </li>
   <li>
    <p>
     When processes can't avoid a need to communicate, they do so
through mechanisms that are either clumsy, inefficient, and insecure
(such as temporary files) or by knowing far too much about each others'
implementations.
    </p>
   </li>
   <li>
    <p>
     Multithreading is extensively used for tasks that Unix would
handle with multiple communicating lightweight processes.
    </p>
   </li>
   <li>
    <p>
     Learning and using asynchronous I/O is a must.
    </p>
   </li>
  </ul>
 </div>
<p>
  These are examples of common stylistic traits (even in
applications programming) being driven by a limitation in the OS
environment.
</p>
<p>
  A subtle but important property of pipes and the other classic
Unix IPC methods is that they require communication between programs
to be held down to a level of simplicity that encourages separation of
function.  Conversely, the result of having no equivalent of the pipe
is that programs can only be designed to cooperate by building in full
knowledge of each others' internals.
</p>
<p>
  In operating systems without flexible IPC and a strong tradition
of using it, programs communicate by sharing elaborate data
structures.  Because the communication problem has to be solved anew
for all programs every time another is added to the set, the
complexity of this solution rises as the square of the number of
cooperating programs.  Worse than that, any change in one of the
exposed data structures can induce subtle bugs in an arbitrarily 
large number of other programs.
</p>
 <blockquote>
  <p>
   Word and Excel and PowerPoint and other Microsoft programs have
intimate — one might say promiscuous — knowledge of each
others' internals.  In Unix, one tries to design programs to operate
not specifically with each other, but with programs as yet unthought
of.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  We'll return to this theme in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">Chapter 7</a>.
</p>
<p>
  To design the perfect anti-Unix, make process-spawning very
expensive, make process control difficult and inflexible, and
leave IPC as an unsupported or half-supported afterthought.
</p>
<h4 id="id2888136"><a href="#id2888136">§</a>Internal Boundaries</h4>
<p>
  Unix has wired into it an assumption that the programmer knows
best.  It doesn't stop you or request confirmation when you do
dangerous things with your own data, like issuing
  <code>rm -rf *</code>.  On the other hand, Unix is rather careful about not
letting you step on other people's data.  In fact, Unix encourages you
to have multiple accounts, each with its own attached and possibly
differing privileges, to help you protect yourself from misbehaving
programs.<sup><a href="#ftn.id2888159" id="id2888159">[22]</a></sup>
  System
programs often have their own pseudo-user accounts to confer access to
special system files without requiring unlimited
(or
  <em>superuser</em>) access.
</p>
<p>
  Unix has at least three levels of internal boundaries that guard
against malicious users or buggy programs. One is memory management;
Unix uses its hardware's memory management unit (MMU) to ensure that
separate processes are prevented from intruding on the others'
memory-address spaces.  A second is the presence of true privilege
groups for multiple users — an ordinary (nonroot) user's
processes cannot alter or read another user's files without
permission.  A third is the confinement of security-critical functions
to the smallest possible pieces of trusted code.  Under Unix, even the
shell (the system command interpreter) is not a privileged
program.
</p>
<p>
  The strength of an operating system's internal boundaries
is not merely an abstract issue of design: It has important
practical consequences for the security of the system.
</p>
<p>
  To design the perfect anti-Unix, discard or bypass memory
management so that a runaway process can crash, subvert, or corrupt
any running program.  Have weak or nonexistent privilege groups, so
users can readily alter each others' files and the system's critical
data (e.g., a macro virus, having seized control of your word
processor, can format your hard drive).  And trust large volumes of
code, like the entire shell and GUI, so that any bug or successful
attack on that code becomes a threat to the entire system.
</p>
<h4 id="id2888217"><a href="#id2888217">§</a>File Attributes and Record Structures</h4>
<p>
  Unix files have neither record structure nor attributes.  In
some operating systems, files have an associated record structure; the
operating system (or its service libraries) knows about files with a 
fixed record length, or about text line termination and whether CR/LF
is to be read as a single logical character.
</p>
<p>
  In other operating systems, files and directories can have
name/attribute pairs associated with them — out-of-band data
used (for example) to associate a document file with an application
that understands it.  (The classic Unix way to handle these associations is
to have applications recognize ‘magic numbers’, or other
type data within the file itself.)
</p>
<p>
  OS-level record structures are generally an optimization
hack, and do
little more than complicate APIs and programmers' lives.  They
encourage the use of opaque record-oriented file formats that generic
tools like text editors cannot read properly.
</p>
<p>
  File attributes can be useful, but (as we will see in
  <a href="#futurechapter" title="Chapter 20. Futures">Chapter 20</a>) can raise some awkward semantic issues in a
world of byte-stream-oriented tools and
pipes.  When file
attributes are supported at the operating-system level, they
predispose programmers to use opaque formats and lean on the file
attributes to tie them to the specific applications that interpret
them.
</p>
<p>
  To design the perfect anti-Unix, have a cumbersome set of record 
structures that make it a hit-or-miss proposition whether any given
tool will be able to even read a file as the writer intended it.  Add
file attributes and have the system depend on them heavily, so that 
the semantics of a file will not be determinable by looking at the
data within it.
</p>
<h4 id="id2888298"><a href="#id2888298">§</a>Binary File Formats</h4>
<p>
  If your operating system uses binary formats for critical data
(such as user-account records) it is likely that no tradition of
readable textual formats for applications will develop.  We explain in
more detail why this is a problem in
  <a href="#textualitychapter" title="Chapter 5. Textuality">Chapter 5</a>.  For now it's sufficient to note the
following consequences:
</p>
 <div>
  <ul>
   <li>
    <p>
     Even if a command-line interface, scripting, and
pipes
     are supported,
very few filters will evolve.
    </p>
   </li>
   <li>
    <p>
     Data files will be accessible only through dedicated tools.
Developers will think of the tools rather than the data files as central.
Thus, different versions of file formats will tend to be incompatible.
    </p>
   </li>
  </ul>
 </div>
<p>
  To design the perfect anti-Unix, make all file formats binary 
and opaque, and require heavyweight tools to read and edit them.
</p>
<h4 id="id2888363"><a href="#id2888363">§</a>Preferred User Interface Style</h4>
<p>
  In
  <a href="#interfacechapter" title="Chapter 11. Interfaces">Chapter 11</a>
  we will develop in some detail the consequences of the differences between
  <em>command-line interfaces</em> (CLIs) and
  <em>graphical user interfaces</em> (GUIs).  Which kind
an operating system's designers choose as its normal mode of
presentation will affect many aspects of the design, from process
scheduling and memory management on up to the
  <em>application programming interfaces</em>
  (APIs) presented for applications
to use.
</p>
<p>
  It has been enough years since the first Macintosh that very few
people need to be convinced that weak GUI facilities in an operating
system are a problem.  The Unix lesson is the opposite: that weak
CLI facilities are a less obvious but equally severe deficit.
</p>
<p>
  If the CLI facilities of an operating system are weak or
nonexistent, you'll also see the following consequences:
</p>
 <div>
  <ul>
   <li>
    <p>
     Programs will not be designed to cooperate with each other in
unexpected ways — because they
     <em>can't</em>
     be.  Outputs
aren't usable as inputs.
    </p>
   </li>
   <li>
    <p>
     Remote system administration will be sparsely supported, more
difficult to use, and more network-intensive.<sup><a href="#ftn.id2888440" id="id2888440">[23]</a></sup>
    </p>
   </li>
   <li>
    <p>
     Even simple noninteractive programs will incur the overhead 
of a GUI or elaborate scripting interface.
    </p>
   </li>
   <li>
    <p>
     Servers, daemons, and background processes will probably be
impossible or at least rather difficult, to program in any graceful
way.
    </p>
   </li>
  </ul>
 </div>
<p>
  To design the perfect anti-Unix, have no CLI and no 
capability to script programs — or, important facilities that
the CLI cannot drive.
</p>
<h4 id="id2888484"><a href="#id2888484">§</a>Intended Audience</h4>
<p>
  The design of operating systems varies in response to the 
expected audience for the system.  Some operating systems are
intended for back rooms, some for desktops.  Some are designed
for technical users, others for end users.  Some are intended to
work standalone in real-time control applications, others for an 
environment of timesharing and pervasive networking.
</p>
<p>
  One important distinction is client
vs. server. ‘Client’ translates as: being lightweight,
suppporting only a single user, able to run on small machines,
designed to be switched on when needed and off when the user is done,
lacking pre-emptive multitasking, optimized for low latency, and
putting a lot of its resources into fancy user interfaces.
‘Server’ translates as: being heavyweight, capable of
running continuously, optimized for throughput, fully pre-emptively
multitasking to handle multiple sessions.  In origin all operating
systems were server operating systems; the concept of a client
operating system only emerged in the late 1970s with inexpensive but
underpowered PC hardware.  Client operating systems are more focused
on a visually attractive user experience than on 24/7 uptime.
</p>
<p>
  All these variables have an effect on development style. One of
the most obvious is the level of interface complexity the target
audience will tolerate, and how it tends to weight perceived
complexity against other variables like cost and capability. Unix is
often said to have been written by programmers for programmers —
an audience that is notoriously tolerant of interface
complexity.
</p>
 <blockquote>
  <p>
   This is a consequence rather than a goal.  I abhor a system designed
for the “user”, if that word is a coded pejorative
meaning “stupid and unsophisticated”.
  </p>
  <span>
   – Ken Thompson
  </span>
 </blockquote>
<p>
  To design the perfect anti-Unix, write an operating system that
thinks it knows what you're doing better than you do.  And then adds
injury to insult by getting it wrong.
</p>
<h4 id="id2888581"><a href="#id2888581">§</a>Entry Barriers to Development</h4>
<p>
  Another important dimension along which operating systems differ
is the height of the barrier that separates mere users from becoming
developers.  There are two important cost drivers here.  One is the
monetary cost of development tools, the other is the time cost of
gaining proficiency as a developer.  Some development cultures evolve
social barriers to entry, but these are usually an effect of the
underlying technology costs, not a primary cause.
</p>
<p>
  Expensive development tools and complex, opaque APIs produce
small and elitist programming cultures.  In those cultures,
programming projects are large, serious endeavors — they have to
be in order to offer a payoff that justifies the cost of both hard and
soft (human) capital invested.  Large, serious projects tend to
produce large, serious programs (and, far too often, large expensive
failures).
</p>
<p>
  Inexpensive tools and simple interfaces support casual
programming, hobbyist cultures, and exploration.  Programming projects
can be small (often, formal project structure is plain unnecessary),
and failure is not a catastrophe.  This changes the style in which
people develop code; among other things, they show less tendency to
over-commit to failed approaches.
</p>
<p>
  Casual programming tends to produce lots of small programs and a
self-reinforcing, expanding community of knowledge.  In a world of
cheap hardware, the presence or absence of such a community is an
increasingly important factor in whether an operating system is
long-term viable at all.
</p>
<p>
  Unix pioneered casual programming. One of the things Unix was
first at doing was shipping with a compiler and scripting tools as
part of the default installation available to all users, supporting a
hobbyist software-development culture that spanned multiple
installations.  Many people who write code under Unix do not think of
it as writing code — they think of it as writing scripts to
automate common tasks, or as customizing their environment.
</p>
<p>
  To design the perfect anti-Unix, make casual programming
impossible.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2892049" id="ftn.id2892049">[20]</a></sup>
  For
readers without Unix experience, a pipe is a way of connecting the
output of one program to the input of another.  We'll explore the ways
this idea can be used to help programs cooperate in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">Chapter 7</a>.
</p>

<p><sup><a href="#id2892115" id="ftn.id2892115">[21]</a></sup>
  A periodic clock interrupt from the hardware
is useful as a sort of heartbeat for a timesharing system; each time
it fires, it tells the system that it may be time to switch to another
task, defining the size of the unit timeslice.  In 2003 Unixes
usually set the heartbeat to either 60 or 100 times a
second.
</p>

<p><sup><a href="#id2888159" id="ftn.id2888159">[22]</a></sup>
  The modern buzzword for this is
  <em>role-based security</em>.
</p>

<p><sup><a href="#id2888440" id="ftn.id2888440">[23]</a></sup>
  This
problem was considered quite serious by Microsoft itself during their
rebuild of Hotmail.  See <sup><a href="#BrooksD" title="[BrooksD]">[BrooksD]</a></sup>.
</p>
</div>


<!-- FILE: ch03s02.html -->
<h3 id="ch03s02"><a href="#ch03s02">§</a>Operating-System Comparisons</h3>
<p>
  The logic of Unix's design choice stands out more clearly when
we contrast it with other operating systems.  Here we will attempt
only a design overview; for detailed discussion of the technical
features of different operating systems.<sup><a href="#ftn.id2888666" id="id2888666">[24]</a></sup>
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 3.1. Schematic history of timesharing.
   </b>
  </p>
  <div class="center">
   <img alt="Schematic history of timesharing." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAsoAAAL4CAAAAABHT446AAAAAnRSTlMA/1uRIrUAAAACYktHRAD/h4/MvwAAAAlwSFlzAAAAZAAAAGQAD5bF3QAARZtJREFUeNrtnU+o60p64D+SId3zMuMXEW7SA57MPQfSfQ0hxM+Qk2xCDIYeaDJzz4HTvM0Q4TeYgceBYN6LFmcxYJhBNIEevDB4dRuPF4+zaYwhWXjhhZmdoBfeNZgs1GtvtAhZeapKfyzbsqWyqlQl+ftxr6UjyXK59HP5U/1xwW632SXi7BCkRMDGBrp0LOg40WJ3D9BTnTQE4QHYv92utdv17qPFeKE6XQjCSagyedjCIlx0WtYm75kRpFAilbfk/yJcLKx7A2NlpFSEKj/buwVxOFiQsvm5pTppCMJDqLJjGBYpkoMFYQOqk4YgPIQqE3pWfLEzVCcNQXjYqzxubcPFlqxZluqkIQgPsLUBiLUby6Im+4uxcd9Ck5FyERTJ20V8gSDlA2/ukIqAKiMVAVVGKgKqjFQEVBmpCKgyUhFQZaQioMpIRUCVkYqAKiMVoVQqb74tAM2Hz2AenKNUKi/mnnTmmndDwTw4B6pcssuIeXAOVLlklxHz4ByocskuI+bBOVDlkl1GzINzoMolu4yYB+dAlUt2GTEPzoEql+wyYh6cA1Uu2WXEPDgHqlyyy5g3D9YVyINkKqPyynj02gBNcrGac8+IXbtmG+5cstKHNTmAMS/vZUxXmbxJA4zHVSxv+gbcdUkeDAySQ+mfBd3zIJnKqOx178g1gInnud2D7YOBB0aTroHXZ49ev9Iqey5Qe+/2Jj/Sx0fy5uknfD5AldVz8TKuaFl7R67akCxdN/oqba49WBldJrHrq8yWJb2MWQIM9hb3X0yPE/bGyMeZZUP6CXTPg2Sqo7J31/VWTXBp0TskF3MCQwPIpja9tEMY+Fc4fCztZcyo8rxL/X0kscY6jLaA5ks7w9O1z4NkKqTywHD7a2OwDqII+n9FYoqhH1OQ0ON2VO73m90VNZfQD98xXUzuoO+iyuq5fBnXMOySiHmw3qtM/tM7PrrWNVa3ozL9YJNYuTv0/2TyBhFHF/qosnpSLuMjKXlX0A4vJvvPbnlY7Ni8uymV6UOXWut6bRYrTx69Of2U9yH1+brnQTJVUnlIy527wYHKrGCCFSuVIFZGlfYyZlV5eEczZO6tJ96A1d88rsidH3nyqo0qqyflMrq0EGLxxRwG6zkM1wP4gctCRrpnRU1f9S/WKut/GdNVpm/RaLJ65T4Y9J0Pm2S5ot9MBkDXTTuB9nmQTJVUFoLulxHz4ByocskuI+bBOVDlkl1GzINzoMolu4yYB+dAlUt2GTEPzoEqH/F//mir+m0qzwNUWTpFXMbv4I9Uv03leYAqSyf1MtIOcZc7l69TzuDNv4D/pHO5nJAH6e/6Um4kPBFVlk6ayqsJuTID1qi36kN7FS36AEEnZjett+58VAOdp6o/zYMM79rrG9Bc0eY/aLvRwn9SQo6gytJJa+3zLxy7qE2/L76/WM+9ddjzwE3pTTNffAD49z9X/Vaz50GWdz2ZeOuu4Xl3fa/fjxbBk05zBFWWTorK/cn+ogIdTDEPF563HyLVvXyS+eLnAPA9U/V7zZwHWd71OtgJa2/djBZh16qTHEGVpZOiMhvBF15Usk4vqr/wvEE0SmrymKLy7h1x+XdbmgbMJ3mQ7V0TnbtRLyvw9uon5QiqLJ0UlWNdzL3HgTcnVzNYeMO+EX6NxkYKnVHZpD3Wa5r+xvBJHmR716Tsdc+pfJIjqLJ0OFReGUafFE7Bgl4eegkBvLQOy+Qybgz4t7/7z6rfbNY8yPiuJyvvnMonOYIqS4dDZS/oeB4t9sFyqsq7vzLMRU/1m82aB9neNTPZu1uzO8FggSqrI0Xl9sGFGTbd2MKbhF+1q9RYeef8crezxqrfbcY8yPSuh+RZ7sRr970+ud8LFuGTVhgrF06KygO62x2wjvbrPhuO6S/mxt1dNDozuOO/pDLjWc/K5ZM8yPKuJ+yHbFw6SvVu5YWL4EmnOYIqSyfLKJJgdR5fHBzUvXiO/WXcdrSswzitV87yri9m20mOoMrSydLal3bd0sbO7y+jnuFycmtfDhJyBFWWTmofjHXqhVulHRC7jFqGywl5kP6uOXOk8iqrnzGu6F5hCeHyF18TvvsN4etoLbaauDFt//HGL3XKg/LAobL6TCw6BQnhsunIx9IpD8oDqnwpBafhMqqsLajyxRSchMuosragypdTcBwuo8ragipfTsFxuDwqQGXd8qAkoMopKTgKlwsw+XIro/qroCuocloKDsNlVFlbUOXUFByEy6iytqDKqSk4CJdRZW0pl8pffcPJlz/ifcZXpymIh8tXmLl8FaqymjwoAUJVdgfhbxcbaYcWVB58/KGIs8TC5XP6TWsd5wGg4Tizxqh2aDKIVFlVHuiP4FI5fXKAYlX+8LmQ0+zD5bP1yk91xxmBTdR9Ot7Fq7KVJ6nS8kB7JKkcmzdPpcrbd98X0ul4Hy6fVXkKI8epdxzndeQsl6RwTlN5uixGZVF5oD1yVI7Nm+f6c461jbb3mC63YJU/AXwScqIoXD7f2ld/cqYNWDqmQyMKG15rQMrnlzrUyJ/TOjSmzozo/vTgOObMeaqBWYzKwvJAdySVyvt588JV1+hneL5glT8CfBRzpjBcPq/yS21pzmovM9Mvhqm/4Jjklm9GVhtL5nDHdGggTQ9ZzuxiVBaXB5ojV+X4SPVh8NsjRar8AeC9oFMF4fJ5lWfw+kQi5pdZpDL5XwsCDPJvScvqumM2XqfEb7N2vl5DrMoC80BvZKjsrpNU7rfT5z4UrPL2HYAhKFAMwuULfTA65KZvCg9OXGUaQAcqs//1kfnaMf1C/OncibTNA72RoXLXPVB5xX5YZDJfQ/oJxKr8iY4z/iToZH64fN5k55UWwfWXA5U7jRErjp9mzojcEjpmfbasUZVnNPw4g8gsEJsHWiNUZTpjHKEZmzdvTueOm9/N58Z8fgepsx+KVfkjTY2wQJGFyxdUXlJFaXwxgpfZCF5nLzBadgBMovfyAR5ojcXsiWlNi/DGayEqi80DnSmgtW/NcaxYlRvv33/+viHsdDRcdgpAZBbQPHgvMA80plQN11cg8haKhsulU1lwHmgMqswBCZdRZW1BlbnONlY+IEp5HmgLqszF89+gyrqCKnOx/TGqrCuoMh9lDDBK2fuYH5Eqn58/bn20rJLKS1ZfnKTkLM3ZM8fcSCkqGoEqn50/LtjoZZk1T3eVTxqupzbx8YW13E1NeJhGi2AjxazRfnHOa421kwQLf+Py5VTlGylFRSNO5bPzx3mxHvnps+YJfn+iVT4pk/2eFMzaht8BP1js+ynbtjN7qjlO3XRMM1yEG5en5bzgJN8K4lS+NH/cfnBJ9/JJSqeyae9VZt3fRuFir/Is2AkzZ9YIF+FG52mEKgtBnMqX5o/bq5w+a55YZKtcX8ZUJutUZX9xOHqEdr4IehlBtItudOyObJVvJPYWp/KF+eNiKqfPmicW2SpDbNF5cUbE4WBxqPLTMkFlutFZ1lBlIchR+Xj+OL+ozjZrnliKVHlaq5mkSA4WYVENdGFPnVOV2caEoX+Ck4wqn5Bj1jw4OaysKpsXVKblrBlb7B31pa3P2OCoYBGafKoyNpFchTiVL80ft/c3w6x5QpGt8sOBjq+NZWwROfpKwo2l7TyYjklu+4JFsNGZdlBlIYhTeUB3J80fF80PR8k6a54oZKv8QoPi5QvQ8dMz02TNJf4i2EiLXzYgYenYdahPnWARbgzrQCSqfCP11ALrlYXOmicK2SrHqoWXo/giK6e/AIOtfdchuLUvBY5Z8wQhveF6amcy9qzJ5ukvu6DKV0FU3mQ8tOBZ88QgveE6U0+L80wTtt1IQCAa2NisYHYs6DjRYmzA6Txf2DNuV8KxfbcDBDFGa7fr3UeLe2tnnUiAKu9QZY0JVSYPW1hEi81u0zo+FFXelVPlG4m9I5VJPEEdDha7hBtCVHmHKmtMqPKzvVsQh4MFqnwOVFlbQpUdw7BIkRwsUOVzlHFA1I2pTOhZ0eKexMqochKosrbsVR63ttGiY+0svO1Loowq30g9NWxtAJJ3G8uiJgeLt3u4PwnZUOVdMSr/nayLXW2CInm7iC+SQZV3Rag8/x34peBE3wY8fTDKOGOcaJV/0iP84teEXrQWWz3dOP3x5f0nG78A+FPBib4NOFTmR4MZ45Tf8nDnAe39eSPRrVikqvzh91W/PfUqc8+atyAq3wudcUF5HhSDTJW37z5TPgmG6svIP2seVRmEJlt1HhSETJV1mDFO9WXkzwOmMohs8lOdBwUhU2UdZoxTfRmvyAOmcovzSTrnQUHIVPkDwAfV70/1Zbxi1jymMtjVyYOCkKgynTHunepgWfFlvGbWPF9lI+vgnnRupD5EospazBinWOVr8qDlu9zjexYiUWUtZoxTrPI1edDxVb5Xm/LyIVFlwbPmXYdila/JA1/l+7HalJcPqU0kqkUqZwosgH/3ZwLv+m4FVFm/FCxu5D5NMKiynikQWfOjPg8KAVXWMgUdkU3X6vOgEFBlLVNgwHOV8qAQUGUtU/BmCeyEoT4PCgFV1jUF4qJl9XlQCKiypikQGC3fSIUIqqxpCoRGyzcBqqxpCoRGyzcBqlz9FNwIqLK+KVDdQbZkoMrapkDYjZ/6PCgEVFnbFAi78VOfB4WAKmubAmE3furzoBBQZUxBRUCVNU6BoPs+9XlQCKiyvikQdd+HrX0CKLNI6lOADX5coMr6pkDXBr+Hbwn/9K+Eb6O12GrixrT9xxu/5E8Wqlz9FIimn/93tFO5ItdQZa1ToGWDH6qshHKnQMyNn+g8QJWVUO4UiLnxQ5U1zMRbS4GYGz/ReTAvQOUrKhBRZb1TICJYFp0HBZjsXZEsVFnrFAgJllFlAZRcJPUpEBIsi27tQ5WVUPIUaNlKgiorAVMgHn4x16gypkDHVpJsMq76Btx1Xc8bGADNOfG56ZFNzRWqfKMpEPrrcWLIVK+8eqSPj+RYgyznA6L0YDLx1l0jk8pYr1y9FGjYPS6Tyo8T+jhvEpW7dMXzmmsWZwCqfKMpEHDjp6S1Lyh8ibhDaM9pMd1mG9ZdVBlToEsKMqkM+8XkDvqu1x+yDTR6RpVvNQV5b/zUqMyUdf3CuQt9745tmKwymYwqVzEFWwNytnEo6YPRZrHy5NGbr8myD/5tYFaTsQ9GFVPg5J5ZVUnD9aBJHx9X5M5vTgPlLo0vhmTVnWR5+hXJQpW1T4Ft5Yww1DRcD5tg9Ekh7DYNgK5L44sJm8bNRZUxBZqQMUbIxRXJQpVLkALNGvxQZSVUIAX57/sEgyoroQIpyH/fJxgcEKWEKqQg730fju0TQBVE0iIFuVxGlQVQEZFUpyBntIwqC6ASIqlPQc5oWb7Krutd078+IOmJqHJFU5AvWpbecL2aEB8HrAPRqg/tFetBZAy8daxJJOh1PzSg7UYLf6M7OFUZG64xBQnIbu1z/X6bTOWm53XvWBfPNXhDlzb2sZ1hr/u7vtfvh4two3tazl+RLFS5HCnQqZXkWLv+ZK8yeXBh7pEiee73Tx4O9kEE2QlrOjAqWIQbve4cVb6RFOjVSnKsnd99M1CZrBOVJ9Dv+1sf95Ew7XUPgdHh8X5X/MkjqnwjKdCrleRYu1gve++RFMdEZe/RaDOVg/iCQXvdn6jMuuK7Bqp8KynI3TtOJJdUXhlGn5TM/cm62Y3iC3Lv5wV9lY9VDjowA6qMKVBA/4LKtJzts/U1+7sdxRe+tHdrtiNYRF3xT1TGyrgKp+D6Yll2vXL7QMdhk4QMxsQPGtZRfDGcs1737b7XJ9uCRbAx+KUBVPkmUpDnxk+2yoM5DXcHAGTH2r/dm9zBHd06CKuMw173dMfKCxZRV/z+BFW+mRTkufGTrXKsWtide1fgnv6gAKpc3RTkuPGT3nC9yjRc77zJQb0dqowpKDgFpyXvOpfKq4Rt2HBd5RRcXSrj7ysLoEIiqU6BRg1+qLISKpMCjRr8UGUlVCcF+jT4ocpKqFQKNHEZVVZChVJwdbSMA6IEUCGR1Kfg6mgZVRZAhUTSIAXXRsuosgCqJBKmIARVVkLFUnBVsYwqC6BiIqlOwZU3fqKbVn76DeEf/4XwTbRGV//6JwkbT1djG//6T5LP9M03P+NPFqpcohRo1EySxPf+L+cTtr89EvjyqHKZUqBPM0kC/4P7K+PL3xL5hYEqVz8FxbD9PV6Vf1n7XOQnE1UuVwr0LZV/Apwqb38An4tMAKpcqhRcNU1wIXmwMXhV/hLgD0WmAFUuVQqumia4kDxoAKfKDnH/L0SmAFUuVQqumia4iDz45fcBfsCl8nvi/nuRSUCVy5YC/mi5iDz4Aa+YJh1s3RCZBKLyJnlP7lnCd1UUSXkKroiWC8iDT5/xqvyn78gzvhSZBtjYrGB2LOgQed/uwaC18PcAPQFnr5xI6lNgwI++/fbbf/pXwrffhmux1YSN/5Sy/3Qjv2LO337+H2tcz9j8Wf0zsSoHMUZrt+vdk4wiL0H+Hguquq6cSOpT8PbnKy17QIzHvA3knd1GaNViqDJ52JI7UFIkLzrkVVrWJu+ZKZUTSYMUaNqZp8er5ZvoNvhIZZISovIbWLRtdGHdGxgr65kCTVXu8D6hJ6SwjBGq/EyKY1ov+Gx02Mdr+9wScPbqiaQ+BXqq7HA/hdv9NEKVHcOwSMlsvW1a/v3eRkQ1XfVEUp+CeQEq898qWbxPER5fRCoTepZfNxf8bQg4e/VEUp+CAky+YrwzdyOk8PgipvK4RSIL4223NXZbsmaJuATVE0l9CrRUecutsvD4gtzu2UAr3Tfsdo/WK98vdmPjviXkClRPJPUp0FJl7nBBfHwRFslbOb9HVj2R1KdAS5W5w4Vn8b1VsQ9G2VIgwNS1cJV5wwX+gCQdVLlsKbjoYBuAeeoasDrcs+obcEdnFhsYAM25WJU3vG9yPBaf0ahy2VJwuV4ZDDYZwqB9NOeSP3HNY5/N2evNBxdPwl2vbL9xPkFCfIEqly4FKSr3WbF8Nz9S+ZHNsTBvEpWp6ymlMm+aec2UEV+gyqVLQYrKLlV12KZTj/WbQNQlgUVz4gXTlZKtQ2iniMyvMm+oLCO+QJVLl4IUlT06mWlzTaVlU0rTecQm8/g0kZM7SJjHJo/KC96aNRnxBapcuhSkqewa/bk/L7o7HEJUHDN5g7mku5DSkYMzzbyjtKTEF6hy6VJwOTqghbFBZ+MFb910ySP4x7dZrDx59OZkHym5L6vM3fOYDynxBapcuhRclhBW3hq6fqRx57pAxJ57q6E3YDP0Pq7InR9xe9W+fBa+FG14BxxJiS9Q5dKl4KKDQzo7b3/tzfswWRlG32j+vy4YNJwYNslyRWKMpgHQdUWqzFvIyokvUOXSpcArAL4U8Q4gkRNfoMqlS4F+KvOGynLiC1S5dCnQTmXeASTcoXVGUOWypUC7AVG8A0i4W7kzgiqXLQXaqcx7Eye+070Pqly2FOimMm99hKz4AlUuXQp0U5l3PIis+AJVLl0KTlV2XS9Dd/pzJD2RJ828A0hkxReoculSMD/2bjUhPg5YU/SqD+0V6zBksB7JbjM4hnaPIzuGBrTdaNEH2i7oJvRd5rmR41RTWnyBKpcuBSdlMutr73d9I+Z271jv+jX7exL0tZhMvHWXbL3re/1+uFjP/aPc03KeIzm8A0ikxReoculScKxdf7JXmXaHg7lHiuQ57WUxcSEWRJB1WHvrZrTw/CElXneeQ2VeNaXFF6hy6VJwrN2dG1OZrBOVJ9CnPZJXUTdlprPf85MZHR4/YCX65DGHypxNd/LiC1S5dCk41i7Wqd57JMUx7dX5aJBYmAYOMZVpF6IjlYd91tMo6MV8ncqcpay8+AJVLl0KLqlMO8ORkrk/WTe7tIOcLy2wsSMr77RU9uYQO8U1KvMOIJEXX6DKpUtB/4LKtPD1y2JyQ9ems32E40WYyd7dmt3pBYsoWD5ROXuaOQeQ8P/gZ3ZQ5bKl4Fjl9oHKwyaJI4xJGDSEkg5J1OFOvHbf65P7vWBBDadnWz1erzJnKXvNBFdZQZXLloJjlQdzGu4OWPm7Zrd7tF75bh5XecIKaJftWHnBYm7c3bHDgzqQa1TmLWUlxheoculScKxyrFrYnXtXEFRMX6WyRvEFqly6FJw0aKwmmYw9a3LCLwlkTjPn1Agy4wtUuXQpOC1517lUXiVsy9pwzduVSGZ8gSqXLgW5vM1I1rRwdiWSGl+gyqVLgUYq83ZVlhpfoMqlS4FGKvMOnZYaX6DKpUuBRipzqik3vkCVS5cCfVTm7RokN75AlUuXAn0GRPEOtZYbX6DKpUuBPipzqrmQfC1Q5bKlQBuVedUUP+nkIahy2VKgjcrajE8NQJXLlgJdVOatVJYw6eQhqHLZUvDTbwj/+C+Eb6K12GrixrT9xxt/liEdvJXKsuMLVPkGUiCHDufvccqOL1DlG0iBFHgrlaXHF6jyDaRACrzjTaXHF6jyDaRACrzxgvT4AlW+gRTIgLdSWX58gSrfQAoksOW96ZMfX6DKN5ACGW+Ks/tFAfEFqnwDKRDPgveX7guIL1DlG0iBcLYt3jmeJE0KdQCqzMcXXxO++w3h62gttpqw8buU/acbv1SdaamZyvvDb5ImnTwEVebDdOSjPtcuwx1eyJp08hBUmQ9Umb/Jupj4AlXmBFXmDy+KiS9QZU5QZYffy0LiC1SZk1EBKvPW2RYLf3hRTHyBKnNSgMlyxyXnzlD+GuJi4gtUmZNbV9m5otmumPgCVebk1lXuXNGXopj4AlXm5MZVtq9ogC4ovkCVOcmq4yzHAarz7EJuXjNVWUHxBarMyTn9HgCYnMsaTJ2XGkDDr+tYvkANah2brk/NGtSflmQtdkCJVN52rpKyoPgCVebkbL0y1J7o4uUBHKdGVkYv4Q4qcY38Ne3QPzv0DAcHnKA+1xJxOld9yCROOnkIqszHeZVNVizXR1RlavUoprLz2iASs6J51HCODiiJyuMrKpQpEiedPARV5uO8ykvq5+sDVfcVHvaeMpWXQVkd/H1wQDlU7l2bqgI63fugynycV9kxYek0ZkxVuw7mMq4yfYTY3/EDyqDypnNt2VpYfIEqc3JB5WXNHD2Fxj4BORIAYqUyMHeXQeHMDiiLyovrwmRKYfEFqszJ6LzKzlPtYUZXRjRoNuE4Vn5gsbJNbv4ODzhBuz4Ydo5KiMLiC1SZk7MBLkydGTwxdUe0nm36EFN5VCMav9AbPqczdY4OOEF1nh2xfc4xMK+4+AJV5uScfq9AAgZz5oxMsJeNGsCTHwpPTRJl1J+mftEMNZOuxQ/QXOWN/dzJ8y1RXHyBKnPiFIDqPAvZvlkd6y1fA0dx8QWqzMnNqEyC+mc79++wFBhfoMqc3ITKzrj3zD/sKYkC4wtUmZPKDohyFgvbsp47z+SfNRb1s1gFxheoMieVUvlAX8teLER/IRT6qUSV+ShC5b+wpGN+IU3fg9wvMlhClfmoVKksnSLjC1SZk1OVl7R+OLEjfVr3+9mZY9TnmiCKfSeoMh8nDddTm/j4whqhpyY8TFlXIdo9OdhIMWvQIDtea/CwjBb+/mVCr2XtGq6vpdD4AlXm5KRMZh3u/Y4WDcd5qrPOnDOINhJs25k9ka110zHNaBF2NDot51XnmTAKjS9QZU6OtTPtvcpAe8CNHFIkjx7iKs+CP2DmzBrRIupDN6qqygVHSqgyH8fa1Zcxlck6UdkG0++LHO/6Ngu6f0K0CPfbnaqqXGx8gSpzcqxdvD99hxTHRGWnU3s4UZl2HkpWOezAXD2Vi40vUGVOLqk8rdXoSBLTnjWe9kU1sGElU+ecyg5UVOWia2JQZT7MCyrTwtdk64e3fYHJTn3GdgSL8yqrzzUhFBxfoMqcHKv8cKDja4PEETU7CBoiR19J1LG0nQfTMeloEn8R7p92KqpywfEFqszJscovtP5h+UI73jsz/3bPrkN9FG2kG4CyZDv8eme6CPcHdSCVU5l3ksrcoMp8HKscqxZeXvXby0HFdPVULmDSyUNQZT5OGjSmdiZjz5qc8BsC6nNNBEXHF1RliZ8e9RdF/ojr1B86vMg0YVslGq6LmHTyENjYrGB2LKC/dfB2DwZJw9iAK39W6ZDqqZzL24yozjMhFB5f0FKZqdwiL36/2xmkkCZ/31s7S4QEqPLNqlx4fBGpTB62sNiRInnRoWX1btMScHZU+VZVLj6+2KtM4gmi8htY1tbfJOKGEFW+VZWLjy8ilZ9JcUxU3j0bHVT5AqhyNoqPLyKVHcOwSMlsvW1aPVT5PDggKhMK4otI5Z3/C7oQ3PZt2CI36i8KqqwEBfFFTOVxi0QWxttua5CvB2tn4W1fEqhyJhTEF+R2zwYgebdht3u0Xvl+4S9EhGzqLwqqrAIV8UVYJG/ltDCpvyiosgqKmhTqAOyDwcdPeoRf/JrQi9Ziq6cbpz++vD9h489UZ1peipp08hBUWTIff6g6BcVT1KSTh6DKkvnwueoUFI+S+AJVlsz23feVXFel71lJfIEqS+YTwCfVeVA0auILVFkyHwE+qs6DolETX6DKkvkA8F51HhSMovgCVZbL9h2AcWPBsqL4AlWWyyc61vqT6kwoFkXxBaosl49U5dsKllXFF+VSefMtNz/lfobQPl2N9+8/f9+Qmse6oSq+KJfKi7knnbno3ijqv5mKRVV8gSqjymIpctLJQ1BlVFkoRU46eQiqjCoLRUWnex9UGVUWibr4AlVGlYWiLr5AlVFloaiLL1BlVFkkCuMLVBlVFonC+OKWVF6jytJRGF9UT+U2gEuEhKZL1pi9rgErb2AANLN8ElDlHKiML6qnstcn4nrecOh5YHTphkEbPM+glg5QZbmojC8qqLJ3RwV+JP+hz4rluzlVmW7EUlkyKuOLKqo8JAKv+1Rllwo8bHtAN7YzPRlVzoHaH6OpoMqe0ff6tDgGEmy4XnNNVfYmd9B3UWWpFD3p5CFVVLlvuDS+IAa7Rn/e9ZjKnteFPqosFaXxRSVVdo320FfZ6xrtNV2Z01K6D6iyTBT/2F0VVfa6d2wBK28NXeb0nFbErdqoskzUxhfVVJnd9JE7PWBB87wPE7dpAHRdVFkmauOLaqqcB1T5WlT/mC6qjCqLeqOK5wNClVFlQSiOL1BlVFkQquMLVBlVFvU+Vc83iCqjymJQHV+gyqiyGBbK32e1VHZdL6WL/TrlDKjylaiYdPKQSqm8mhBXB6x5etWHNm3so7i0L5Hhd1Z20/oso8rXoTy+qJTKLutp73cearLm6yEppd0m63i/DjpguCl9ilDlq1Ay6eQhVVK5P9mrTB5cYIcPSTlMiuR52AGje/kkqPJVqI8vKqXynRtTmaz7Kj+uPW8C/aiz8uQRVRaP+viiUipDbPFIymGmMo0vyJ9GO1TZNVBl4WgQX1RW5ZVh0CEkfnxBQo91k3bBB9gfhioLRIP4orIqE7rsBo92vaeb1nB0GKosEA3ii0qp3D5QddikhfKaxRfGZB9XrDBWFo4O8UWlVB7Q3e6A9rj31sF93oDVI0/u4C58blDPgSoLRIf4olIqx6qM3bNHBpXPqLJIdIgvKqUya+1LwU37BQFUmR8t4otqqZzhFw5XaQegyvwomxTqgGqpLIAUlb/4mvDdbwhfR2ux1YSN36XsP934pdRrIh5lk04egirzqWw68ilbOa5s0slDUGVUOS96xBeoMqqcF03iC1QZVc6LJvEFqsyp8qgAlUXXoUhGk/gCVeZUuQCTVY9c5kSX+AJVRpVzokt8gSqjyjnRJb5AlVHlfGgTX5RM5a++4eTLH/E+4yshKs9uRmVt4otyqczPxx8KPmG6iEuzAQAPprN8Icu6SbxuPAAwuZc1mFZMZW3ii6qr/OFzwSdMr1d+qr2SxxE9EKjOjvPy4kDtie57eYAMpbLyXONA6aSTh1Rb5e277wsuNNJVZiYTl5nK7H9j5oDJiuX6qGoqK5108pBqq/wJ4JPYM6arDAerLzVn+kDWlrRYfn1wqqayFp3ufaqt8keAj2LPyKdyDRq2Y77SjSYsWfFcLZU1ii8qrvIHgPdiz5hB5eWR1fUli5pr5ujJqZrKGsUX1VZ5+w7AEBssp/fBaLweqjzt+GtPtYdZNpVL1AdDo/ii2ip/or/j+UnoKdNFNOu0vm1mhyo/UbVh6szgycmmstpM40Gn+KLaKn+kKosNljOYSOuVadE8NQGC+OIVwHTMmTMywa6SyjrFF9VWufGe0BB6ygwq50ZtpvGgU3xRbZUlpABVjqFVfIEqc4Iqx9AqvkCVOcEBUTG0ii9QZU5Q5T2aJRRV5gNVjuWtXqFQ1VUW3dyAKu/RK76ovMqiOVV5SRuqk7vaT+2wEftsV/ykHSXJNd3SiSrzMTrVlfj44jdRm/BAW/UoxOHpQ9gccrDfsetQewkXy5dTlUvScK1ZfIEqc3JSJrMu9X57dMNxnurOK7F4SVZn9diAkdh+p0b2QbRYnpbzqt9jRjSLL1BlTo61M+29qlRMYMX2Kylrn+KOxveTsnj04IQL52lUTpV1iy8qr7LsJpL6MqYq7c3JxOyQELjegX25HN9vg2mStWDh2J1yqqxbfIEqc3KsHcQWHVLOMpVpfEE3mQ8Hh4X7O7UH6nCwWNbKqbJu8QWqzMkllae1msk63tP4wg8nyALgaL9pzxpPTrhI6PepOs+yZYT6a3sEqsyHeUFlJwyQaR97B+Id7eP7wb/fCxYJKqvPtSwZq90nDlXm41jlhwNVXxuskrnB9jyxAaqn+2s2CyqChT/KpHwqaxdfVF5l2a19Lyw2fqFd652Zfx9Hf/eCMKpHt32H+22yYxQtwjqQkqm80C+RVVdZNMcqx6qFlynj/pL3BxXTZVNZi0knD0GV+Thp0JhmGOF0yW9zebKtDLmmX3xBVT7z+RIR1pfhovBxWrLm+qVDJ+kn5ErQcK3HpJOHwMZmBbNjQcfZbVj/ge1udw8gYrBL9VTO5W1GVL/HDGgYX9BSmancIsm7342JxVuyOhZUMKhXGQdESUHD+CJSmTxsgQk8Jt8dnZYl5GOHKldTZR3ji73KpDz2VX7e0KqWe6MasTKqLAMd44tI5Wd7t2Aq0/iCLp5bAs6OKldTZR3ji0hlxzAsWjKz+IKyEVFNVz2VcUDUTtP4IlKZ0GNZ2Am/OwwBZ1d/UXBsnwS0jC9iKo9btFDe0LhiS9YsERmq/UXhBlXeaRpfkNs9G4Dk3cay2K+32vS7Y2zct4Tkp/YXhRtUWdf4IiySt3JamHS/KPygyjpNCnUA9sHg4yc9wi9+TehFa7HVxI1p+483/kz1m7yMPpNOHlJ1ldWnoHLoM+nkIagywomm8QWqjHCia3yBKiOc6BpfoMoIJ7rGF5VXuQTd2MuFtvFF5VVGBKNtfIEqI3xoG1+gyggX+sYXqDLChb7xBaqMcKFvfFF5ldWnoFLoNenkIagywoFek04egiojHOjZ6d4HVUayo3N8gSojHOgcX1ReZWy4FonO8UXlVUYEonV8gSoj2dE6vkCVkexoHV+gykhm9I4vKq+y+hRUB73jC1QZyYze8QWqjGRF95+aQZWRjOg36eQhqDKSEc3ji8qrjK19otA9vqi8yogodI8vUGUkI7rHF6jybbL5lpv/wv2MTY5X40fIjCPnQZU1ZTH3pDNfFPtqVVdZfQq0BFXmRb1I6lOgJagyL+pFUp8CLUGVeVEvkvoUaAmqzIt6kdSnQEtQZV7Ui4StfYmgyryoVxlJBFXmBVXWFFSZF1RZU66Ua51xm1CV15mOQpVvlDNytQFcYgU0XbLGFHINWFGdmm6/CQDtvnewZ2AANOfn5Ep5teOXjk67T8bFF7gxldWnQEvOydVn4g6HngdGl24YtIEtBl1jSIXpH+4x6LaBCJUPTrtPxqUXQJWRC3LdUZ8eqVl9VkrezZnKzTUzmRhzuIfpJ6RUPnzBKBmXXgBVRi7INSQ+rfvULJdaNGx71KyVvwici+0ZQnt+Xq7UVztQOf6CUTIuvQCqjFySy+h7fVo6AvmWd0lpzMzqD+Mqx/dM7qDvilE5ftooGZdeAFVGLsnVN9xH3yzX6M+7HjPrzvUg8ulgj+d1oS9I5fhpw2RceoEbUxlb+xI5L5drtIe+WV7XaK/ZyopY1RzunYv2zGnB2YdzcqW/2oHK+xeMknHxBW5MZSSRC3J173yzVt4auoFixKr+3Yr8sZ4c7JnTejISSAtROfaCUTIuvgCqjFyUi91tkdstYNHqvA8TGl8Ql5sAtGiO73GbBkDXFaHywQtGybj4Aqgygg3X/KDKmoIq86JeZfUp0BJUmRf1IqlPgZagyryoF0l9CrQEVeZFvUjqU6AlqDIv6kVSnwItQZV5US8StvYlkiqX63opnd7XKWfgUVnIq1VdZSSRNLlWE2LPgLW7rfrQpg1xFNfrG9Bc+fql9SLOrrKYV0OVb5IUuVzWC95vQm6yRuShS5vevMnEW3eN4KCUXj6ZVRb0aqjyTZIiV3+yl4s8uMAOHw787/mwd0/38kkyqyzo1VDlmyRFLtbpIpSLrPtyPTK1SEEZHDV5vHiSzCoLejVU+SZJkQtii8eBN2dykW98v3h0g6NcQ4zKgl6t6iqrT4GWcMi1Mow+63c/9O+8Jiu6B2B/mEiVc7waqnyTcMhFS0Z2y0W7xQduHR4mUuUcr4Yq3yQpcrUP5Bk2aTG5Zt/4Q/JE179NY4NLRKgs6NVQ5ZskRa4B3e0OaG94b933h4kO6Df+JKjwZQQ1D7lVFvRqqPJNklbTu6/Edc8e6XYvnoOjXlnMq1VdZWy4TiRL+1sKbtqYfr7WvvyvVnWVkURSe0WsU+VapR3A0QdDyKuhyjcJ9ozjBVXWFFSZF1RZU1BlXtSrrD4FWoIq86JeJPUp0BJUmRf1IqlPgZagyryoF0l9CrQEVeZFvUjqU6AlqDIv6kXC1r5EUGVe1KuMJIIq84Iqa8riq2+S+fPHMzv+23/4hpOvFqmvdpa//hP+V0OVkRj/G351Zo8D/1BcMra/PeJ/EqqM7Pn5935wdt8ffOYUlo6//K0r7nGqrrL6FJSI5e/Cx7M7/xh+sC0oHZ9+5/MrnoUqIyHLGsDb2b1fAjSKScfWgN+74mmoMhLgEJP/8PzuNwDoFJKQvwT4syuehiojPk6duPqn5/dv3wF8ZhaQkE/fB3h/xfNQZYTBTIa/v3DEe7L/ez+XnhASXgD88RVPrLrK2NqXkV9RU39vc+GIv6KufyY9IX9JX+bLK55IVN5c8bSMqFcZycwP/uDy9/rfE5H/Rn4lRsu4VuWNzQpmx4KOs9uwHx7Y7sYGdE4SvfmWm59yP0Pi5wq5iDXefnkxFHZq/+ufnwtIyOb9+8/+/ornQRBjtHa73v1uTPzdktV7a2edlKjFttsjxbLJZKlVwPXZ9Habawr/UGXysAWWzrFNy+rdpnV8KKpcZTqZvg+3BRTL135cIpXJ58BX+Xnjbzq5ISylyhitZ+MtY0YVUCxfW3kdqvxs7xZMZRpfoMq3xraT8StdfrHsXHvJQpUdw7BoycziC1T51she2Eovlq1rey3B3tkeu+wsZronsTKqfDs42cta6cXy1Y3je5XHLVoo+3d7HWtnVeO2D1XOwjNHHajkYvnNvvaZsLUByPXeWBaLlmx2prd7uD8p50upMtaIZMDm0Udysdy7umUhKJK3GS55KVVG0tnyfadLLZZzfFA4+mCgyhWlx5fpUovl8fjqp4pW2R2wqaoGsAq3GBmehSorZMF7PyGzWH6+vpOH+FIZYo9YKpeAFq89EovlPKeWqPI6KKddVFlnrDf+p0i7SjZ/YiLkqTyBoQFdb0j+bhvtcJ7XolXGyrgUFleUg/KK5TwjriSWyuTfyl94rtHP9mRUuWAyt1gfIKtY3vRyPFmuyuHCG95lCzNQ5YJ5virDZRXLuT4iklR224cq99v9TE9GlYsla4e4YyQVy7lGdItX+ZFOwtZfHag8ma8h07NR5ULZXOuOnGL56k5xDPEqr9sATaLzHIbrAcznMFjPjfn8DtoqVMYakUs8X/3bWVKK5as7xTGwte+Gsa7uuiOnWM73izGo8u3C0bXzFAnF8vWd4hio8s2y5W7mO3i2+GL5+k5xDFT5ZuHsRXSM8GI574ej6ipjDcY5rq2HCxFeLOfoFMdAlW+Uq+vhIkQXyzk6xTFQ5Rvl+nq4EMHFcu7TiVSZ9YFbH25bTdzYX+uUM6DKRZGjHm5/DqEXK0+nOIZAlVcT4uqAtVOv+tBe0WV7EvuLdsxHlbUgVz1ciNhiOXfAI05lt8sWTOWm53XviNh3q9hf7KCUrhjY2lcI+erhIkQWy7k6xTHEqdyf7FUmDy7MvW7fi/3F6F4+CVbGFcIV3e2TEFks5/9YiFM56Mbpq0zWibx3j0DL5eAvxuQRVVZO3nq4CIHFcv5pTsSpDLHF48CbE3mB9u6M/vIjjMujVlHlAriuu33imYQVy/k6xTHkqLwyjD4pi1lksf8LwEsbv4oqF0BH3FySworlfJ3iGHJUJtA4Gdbh393+0WFFqYw1GCdw/RZRCsKKZQHTqIlTuX2g6rDpkk1db9WO/mKsCo6VUeVjrhmXeh5BxXLOTnEMcSoP6G53AEAK4HW/T92d37HbvuAvRlDPgSqrYiMsUGYIKpZzdopjCKxX3lcZuwdHxv8KKp9RZVVsBQbKDCHFspAPhODWvhTcffGMKishZ8/OU4RYmLdTHENkH4x1qsqrtAOwtU8uIrpeHJ9SQBbn7RTHqHrPOCTOW+7W4VMEFMtiAm5U+YZwBFR5nZK/WM7dKY6BKt8OgjoRnZw2d5kq5hOGKt8OoisvQvIWy/k7xTGqrjLWYET0RFQTJJG3WBbUzIIq3wpjeVmR00VBETyqfCPIueXzyVcsC+gUx0CVbwPB7dVH5CqWBXSKY6DKN4Hw9uqj0+cplkV9XVRdZawRYfTEjIA6S45iWUSnOAaPyl99w8mXP+J9xleongwktFcfkqNYFtEpjsGhMj8ffyjz7EhWZLRXH3F1sSxuTJVUlT/8vsyzIxlxpN7y+VxtpJBOcQyZKm/ffSY/D5E0xI1KvcS1xbKQTnEMmSp/Avgk8fRINuRWXoRcWSwL/CkNmSp/BPgo8fSZwMo4ae3VR1xXLIvpFMeQqfIHgA8ST5+Jm1dZeuVFyHXlq8A2SIkqb98BvFMdLN+6ymP5lRch1xTLgjrFMSSqTEJl9cHyjatcoMlXFcsif0BRosofqcqqg+XbVrlIk6/yUmQfJ4kqN94TGvLOn4mbbj1cyOkN98XXhO9+Q/g6WqOr//2/Jmw8XY1v/M/JZ/r66y/5kyW1iQRRiqymEdORzxXfpqhyZZHWyHeTKt92pKoWec3VqDJSJNuWqB5nJ6DKSlCfAjXI7Gs/KkDlK27XUeVKInXUSAEmX5N6VLmKyB3/dJMqq6/VvU2V5XYhukmV1XOTKkvuDIcqK0H990LxyO7WyWHk7GTL1F6iykg2LNnfRCkWTs0a1J+IsC81gAat7pg1TIAntu/BJo+vNXhYospICvK7EF2uV5526GOHHFQjy9ELeXj525EzA+p0fUp31k3HTKmc1q5eGSmcAjrDXbawQ8tdZ9QgKtOCmJbKDRpnULGf/KfCjBTUqDJykSK6dV5WueYvSCH8Cg8jP6qgJTP1ut4BWi6Dv79UKquvP1CfgkIppIPyZZVhv7DrYJKY2HwlWps1k200H1DlsqagSIrpap+iMruhW/qF8xOQg+tsywiYv0tAlcuagiLfbDGDRi73wWB1FI7dcUY0QjYhuA9kkQcJkqnD9Zl/F3gB7IOhYQqKo1fQm70s4Qu7oetMyZ3fiMXJT69su03K54cnFjg/mI6Zctt3RbJQ5cpQ1A9epNUrvzagZpKbu2WjBvC0pPHFqFav06h5VGe3fba/UKjyuTFd5zd+l7JfyJiui9xOa19hJleh4VrTLtfIjo7cL8xkVBlVlsi2I/m3wOOgyqiyNCTPz3CEph6gyhWgWJN19YBHZU3HdF3kFj4aTqtQk6ugcgHvQPg1uQGVnWLLZFQZVZZEEdMzHHKq8pI2TR91sw/62O+72s/OXfOkHajyCZVXuXiTTwPNqU18fGFN0VMTHmjrh9/HPlw4R/tn9JcxYemYNWhMneXLqQeSG65RZf0YF2/yiQdLNkDE7yDUcJynetTHfhZv1Ivtf13SxkDHtp3ZU42smiI8KFzl2cFCusoVb+0b9xT8FvvxNTPtvaqs79so7GP/FHc0vp/w+uJLQDc/jQR4kFflBwCWoGUN6DcFS+ULTIO1B/D5APTPpdkg6w/mftCXfJWrTbG/nxxyfM38TpyBqmSdXOugj32wcE72Ezp+aTajRbrdKVjlxDtXYMNenJcHiJK7749q+ivmaMk+ezXaR2pk7gd9nVL1gEAothKTT1SOdbZ3Oi/OiKi672NPF6f7WXzhF9xLJ+rdrFplkxXL9VGSystgZckea35vv9F+0BeqnINtr6gZc464pPK0VjNhGetjzxYAR/tZfEGxp/FTKFZ5ScV8fXCSVD6zKRz0hSrnoNBuFwccewAHCxYgB33sg8XpfhJ7zmImn6qsouEaHPopa8x4VA4HfRWgcmU/GkU38cU49uDhQMfXxnLfx95fnO4PRly/0jso24kGmqhWeVkzR09OFpVj9rJBX6jy1YzFTajLzfGVe2Gx7wvQSzozWRkV9LEf7fvYH+53Xmh8YQfVy2EdSHEqJwYFQG/nHmZxlZcP0dosrnLDj5WjQV9JYB+MbG9LzQ2fz7HKsWrhZUo/neT9QcV0gSonJg5o281T6C77PQ86Gsb/k96e+mUx++yxT+jMDgd9JSE62yupcpH97BM4+T6d2k4elgnB5nUqH/3Qv/Pmf3WdWpWUjFf6tWHOnJEJ9P3MHgAaNmufpDTYyog9kgyg9cqkaA4HfaHK17HpqG34OS1Zz3avyETSML9rGq43NiuYHQtYByvHvy++Bzj9CsuV3oxcTm0ZRxcKZ9GRNstINtR7kAgEMUZrt+vdkw/8PTvJOPFDof4taNq9sFBU3vD5qPcgkVBl8rCFRfhTCp2WlfDJV/8WUOXCfuziAuo9SCRSmXzUicr3z0DL5YV1b5yeTb1I6lOgGMU3fD4FXIQ8Kj/buwVRmaxbHT/PWifHqhdJfQoUS6SuXSSeigK4Ilmhyo5hWKRkZnEG27E5raZTL1IZRxcK5E1B5+QE1HuQCOyrlmkUBpvob0PDt1BAAnQo9s5gq+icnIB6DxLZqzxukYzq9HZOZ7fdJs5owTWma19bmFzpSA7jH9NVQB5qq7KyjnAn6Kry1gYgz9tYFv3IL+7pbd/YuG8lnItjTFc9mEbleP/BYfxjum5YZXUd4U7QVeUgo7JEiMcvd35M12vc+vj+w8O4x3TdrsoLLW74fPRWORPHL3d+TNdDw9xHD/H9h4dxj+m6LltmiaulUtnSJExm/KRH+MWvCb1oLbaauDFt//HGn/EnK4/K58d0jcx6LXFM1+Fh3GO6zukXjiEcRZPG0T6FUDedg3GEQbBzedo41aIkvW19gguNyaPy+TFdpOztNA4OC/YfHcY7puvcV1s0hnA/aRztSE3NPRxHyNJyedo4/eqV7WfFnS7KgSiVD8d00RIwcUzX8WGcY7rOCRiNIdxPGhf2/z8cR+i/6MVp43RTefusW4o0Jc8okvNjuii1o8Piv40AB131s4t06YYDYi8aaPxSOx5HCLG95VB5obhHZ3nIo/LZMV20unn/FX4wputg6Bf3mK5UlWOfLqixntOH4whLp7KlvB9cacij8tkxXa+1eiM8+HD/4dAv7jFd6SrvJ43by8rGEcaCnfKovOlo0HuoLORRmX9M19Fh3GO6Lr0KkzOaNC6U9WgcoX/bd3HaOI2+z8eqO9mXilwjrgsf03XpbKxAjiaNi1Q+HEfo+35x2jjVVyRiq0HX5DKRb8R10WO6LpyLjSHcTxpH/2Yfl/g4wiDYuTxtnOorEr3XlkbfD2WgXD9Kqz4FhYH3e7ygylqqvHnWpRtceUCVdVT5rejpRapAuVTWtE+WYLZ+h1uED1RZO5UXLew8dA3lmoJSfQqks+3p1J+zTKDKeqk8xiq4aym7ypdGF0bInjFOGJuO8vCmvJRLZY7RhdFkF0f77TrUXmhbNh18KGjGOFFY2FCdg3KpfHz0+dGF9Heoo8Pi+2usK/Vs5HfDEDNjnBgWLew7lAcelbnHdE1/LHhM17F250cXOvbySOVgPymSR36XDNa3WciMcSLA27288KjMzccfCj7hsXbnRxdOR86xyv5+G8IpBFiJLmTGOAHg7V5upKr84fcFn/BYu7OjC2ngcKRyOGNcp8bGqL6aNVp+C5kxLjd4uycAmSpv330m+DvzksoHwwbNYMTV6ehC0541/Ag7PtOgWpXxdk8EMlX+BPBJ7Bkzjy70f03AdBL2O1G/+1qiyoWXj3i7JwaZKn8E+Cj2jNlnjHNOAoxgf80Ogwqbnk3IjHF5wNs9UchU+QPAB7FnzD5jXEzlw/203/3IGdXqdfankBnjcoC3e8KQqPL2HcA7sSWOpjPGXQ3e7glEosqfaLj6Segp1Y8uFMkWb/dEIlHlj1RlscGy+tGF4thazxhbiESiyo337z9/3xB6ylzeZkRyhoeM8ScuBCO1iUT4XKaVUXmMFXDCQZUVqLx4xhFP4kGVC1fZ6aDIMkCVC1Z50+thtYUUyqWy+h7TOdla+LMAskCVC1QZ699kgioXpzJWW0il6iovuZ8hS2UUWTKVVHk2GtkmodP6N/APeqiM9W/SKZfK2UYXDiHGjwuYMS6VBda/yadcKmejEzP5+79SkoQDxs8W1r/Jp4oq/8+9yeq7nm3HWCIXQ/VU3u5mocj3yn9HcGvhzV5RVEplUvptDVjs6r7JykvDTQ8n3SuOKqncAWvnANg7i8UWqpvVFr2e6iTcFFVRmRbABjzvdjYpizcAhurv9bdn7GtRLFVQeeuHFbs3KywFF2PFscW4pTy6uTnKrzLVmIUV2oD3ekooucqk6GMa2/oUghvrWXnFyU3Co/IXXxO++w3h62gttpqw8buU/acbv8ycGuouvdHTSWPyweph5zdFlOv3lff40TG70dOH7Rjv9dRRSpXDsCJ2o6cBi15H9d3mTVM6lbc6hhUkQrY72NFCLWVTmWqsWVixox2G8FZPOTwqj/Kbmsqle6awGUSrsILEOlbH1uob4kYpyWyqYe8K3TTebe0ONk/rQTlUjnpXaMZb7xkbQ3ShBCpvY70rdGJDAgu809MHvVUO4wrdwgq/ChnbQrRCgsqzM39n+v3Y+Osxi3WMK1hgoddXBCJY5aXZAIAHM5jWBmD0UgNojBwnXGZWOWoG0S2uIOUxBhY6IrZe+an2Sh5HpkMPpTPojegMNqMXfzam0UvqCVi9sp69Kxgbu4PlsaaIVZmZTJxlv6TC5pCuPbG/nXCZxt/p2buC4VidHraEaItYleHkj1d4GMWXKQFKLex7rN2N3luvo1uSkANkq0wnFwsnGTNTf/Vqqlnf4wAMj8uAYJXjskZzmAazmj5B+gle/kI3jTE8Lgti+2A0Xo9UHtEaOBOiZSqa1dWS8NjC8LgciK2MM9lEpjM7KqJHtAJu+hAtU1GdH/G3az9jeFwiBDeR0Hplv2iemgAjZ9moATwto2VZVF5YnY61wLCiTOjdcK2C7ZvVebY0C3SQdFDlOJtx77lna/B5QvhBlaN3Zz8/W2OscistZRsQJYeFRTR+w9C41Ny6ypuF1XvuYGhcAW5X5e3CphLbWE9REW5RZSKx1XnuYWVbtcin8pLWFB91qZ/aRxsT95NlYl98uSpHEuPdXfXI1XA9tYmoL6w5emrCA23pmz7Qpr5go+Oc2e/UAZ6cZUL/ZUlB62axsFDiapOnMm75xBZM1YbjPNWJuKzl2jnoI5ew/9X/VCxPy3mhb44J3Ov0Oh3LGqPEFSePyqa9V5U8LGHkPJlOssqH+x8aJosuno4L+hGRzqLeEa7V+lBgrJu4FfKoXF/GVCXrRNV6B/xy90Tlg/0js16jh9md01J5QzV+Y0Z3CETKju+3TXfEzXTYhuBY/2gU+HbJozLEFp0XZ0RUpeP5HpJUPt6/7DToYy1jgLFl0jJjnzs+gcC+4Ausjbh5RKk8rdVMUvKyOGJfFAOc2+/M4Mh4CbEyckvkqYyDgwWLg2G2j42PDjvc74/BPlVZTcM1UgHyqPxwoOprg4TDD09BB/tTlWP7aXW0Sc827aDKiCDyqPxC6x+WL0DH7M1MNgh1VGe3dcFG58z+11q9wXYHdSCoMpKfPCrHqoWXKeP+kvcHFdOoMiKAXA3XU9vJwzLh1wRQZeRKiMpHrWDO2X67pyVrpl80PMs0YRtWCCNXAhubFcyO5c9v7nToWPmxAZ1ToXN5mxHV+YGUFghijNZu17snJfQ9k+ne2lmnX/WoMqIxocrkYQuLXc8XGDa7TevkWFQZ0ZhIZRJPEJXvn4GWy7BLuiFElRGNCVV+tncLojJZtzqoMlJCQpUdw7BIyczijHMqV2VAFFJJYO8sjZNJkEz/viexMqqMlIq9yuMWnT66t3NIgNGxdtbpbR+qjGgMbG2g035sLPYD3Yt7dtv35i+OQJURjQmK5G2WVjZUGdEYnj4YP+kRfvFrQi9ai60mbkzbf7zxZ6ozBCkrPCojiMagykhFQJWRioAqIxUBVUYqAqqMVARUGakIqDJSEVBlpCKgykhFQJWRioAqIxUBVUYqAqqMVARUGakIqDJSEVBlpCKgykhFQJWRioAqIxUBVUYqAqqMVARUGakIqDJSEVBlpCKgykhFQJWRioAqIxUBVUYqAqqMVARUGakIqDJSEVBlpCKgykhFQJWRioAqIxUBVUYqAqqMVIQbUnlT0deqWuquRbTKWxvobJY2RJOxGgW/I5ICA4znN7ZGscia1SIrnULmt4xei738PZ2pttUBYPpsDXDynv8i51/IsQy4723JpTEAWllmHM2dkgV9oNfC2RWRAeJLZZB0Xr4UOIYdrG2J1D1jTNYWhagcey2gOhN57B0YPbrP7sjOl3Mv5DzTx2fLL1oWtvx82ELw4Fj3uyIyQKLKwdfYdist8ZdSMG4FazQZzC5yBYt49dhrgf+/tdmBxUql+4V0lc+8EP2WIokimcKcKiInIHzYGrsiMkCeym8wNqC3G5O/O0Zn91xcgMZSsA082vakvMu09x+u2sbO6ZC1LTVo3JGekvgLkUiHqEsCi9ZbGOaRrWPoFPKRjlRe9N4KyQCJpTL9boHwc2kVk32HKdjRULkj5V2mvbq/yiyyxnSjBVtWPEt/9f0L9difxKO3Rfi6dPF2D1YR35S+ypbV6jmFZIBclcPFbnxfYJhxUCrv6Pc9FPnq+9fys4K+dWCf5p78D1X8hbZj8pUYFscsVVv/rx4UcdcQBRj2fSEZIEnlbedQZauY2oNYCqJYmQbrrXFxrx57Lfby7IaLlpFGZ1OEytELbVpb8gj+12GHxcpvz7sFDfSsIr6mIP5QQAaIPzO7wbCcA5XfFhsoLsKgr7gw3oK1bW+7s+5pFdDmrYhXj70Wy9we+1pwdhsoImqPvZB1vyVfTT1jsXPGO5t+snfPDrnzIxeChu/SYV8E7HvxvpAMEH/mTQdohLhbwHhjw2IB9mZhLBb3UET27WjdD63OpfEZWTPIOr2ItK63qKI5fC2akJ0fX4xp7ba12S0skPtxir+QYxiW0fpVDwz6jThukSXJlG2L5ElPfsBF371FH4wW+QAVkQH/HzSoJGJpDSwkAAAAPHRFWHRjb21tZW50ACBJbWFnZSBnZW5lcmF0ZWQgYnkgR05VIEdob3N0c2NyaXB0IChkZXZpY2U9cG5tcmF3KQr6ixbzAAAAAElFTkSuQmCC"/>
  </div>
 </div>
<p>
  Figure 3.1 indicates the genetic relationships among the timesharing operating systems we'll survey.  A few other
  operating systems (marked in gray, and not necessarily timesharing) are included for context.  Sytems in solid boxes
  are still live.  The ‘birth’ are dates of first shipment;<sup><a href="#ftn.id2888745" id="id2888745">[25]</a></sup>
  the ‘death’ dates are generally when the system was end-of-lifed by its vendor.
</p>
<p>
  Solid arrows indicate a genetic relationship or very strong
design influence (e.g., a later system with an API deliberately
reverse-engineered to match an earlier one). Dashed lines indicate
significant design influence.  Dotted lines indicate weak design
influence. Not all the genetic relationships are acknowledged by the
developers; indeed, some have been officially denied for legal or
corporate-strategy reasons but are open secrets in the
industry.
</p>
<p>
  The ‘Unix’ box includes all proprietary Unixes,
including both AT&amp;T and early Berkeley versions.  The
‘Linux’ box includes the open-source Unixes, all of which
launched in 1991.  They have genetic inheritance from early Unix
through code that was freed from AT&amp;T proprietary control by the
settlement of a 1993 lawsuit.<sup><a href="#ftn.id2888778" id="id2888778">[26]</a></sup>
</p>
<h4 id="vms"><a href="#vms">§</a>VMS</h4>
<p>
  VMS is the proprietary operating system originally developed for
the VAX minicomputer from Digital Equipment Corporation.  It was first
released in 1978, was an important production operating system in the
1980s and early 1990s, and continued to be maintained when DEC was
acquired by Compaq and Compaq was acquired by Hewlett-Packard.  It is
still sold and supported in mid-2003, though little new development
goes on in it today.<sup><a href="#ftn.id2888820" id="id2888820">[27]</a></sup>
  VMS is surveyed here to show the contrast between
Unix and other CLI-oriented operating systems from the minicomputer
era.
</p>
<p>
  VMS has full preemptive multitasking, but makes
process-spawning very expensive.  The VMS file system has an elaborate
notion of record types (though not attributes).  These traits have all
the consequences we outlined earlier on, especially (in VMS's case)
the tendency for programs to be huge, clunky monoliths.
</p>
<p>
  VMS features long, readable COBOL-like system commands and
command options. It has very comprehensive on-line help (not for APIs,
but for the executable programs and command-line syntax). In fact, the
VMS CLI and its help system are the organizing metaphor of VMS.
Though X windows
  has been retrofitted onto the system, the
verbose CLI remains the most important stylistic influence on program
design.  This has the following major implications:
</p>
 <div>
  <ul>
   <li>
    <p>
     The frequency with which people use command-line functions — the more voluminously you have to type, the less you want to 
do it.
    </p>
   </li>
   <li>
    <p>
     The size of programs — people want to type less, so they
want to use fewer programs, and write larger ones with more bundled
functions.
    </p>
   </li>
   <li>
    <p>
     The number and types of options your program
accepts — they must conform to the syntactic
constraints imposed by the help system.
    </p>
   </li>
   <li>
    <p>
     The ease of using the help system — it's very complete,
but search and discovery tools for it are absent and it has poor
indexing.  This makes acquiring broad knowledge difficult, encourages
specialization, and discourages casual programming.
    </p>
   </li>
  </ul>
 </div>
<p>
  VMS has a respectable system of internal boundaries. It was
designed for true multiuser operation and fully employs the hardware
MMU to protect processes from each other.  The system command
interpreter is privileged, but the encapsulation of critical functions
is otherwise reasonably good.  Security cracks against VMS have been
rare.
</p>
<p>
  VMS tools were initially expensive, and its interfaces are
complex.  Enormous volumes of VMS programmer documentation are only
available in paper form, so looking up anything is a time-consuming,
high-overhead operation.  This has tended to discourage exploratory
programming and learning a large toolkit. Only since being nearly
abandoned by its vendor has VMS developed casual programming and a
hobbyist culture, and that culture is not particularly strong.
</p>
<p>
  Like Unix, VMS predated the client/server distinction.  It was
successful in its day as a general-purpose timesharing operating
system.  The intended audience was primarily technical users and
software-intensive businesses, implying a moderate tolerance for
complexity.
</p>
<h4 id="mac_os_contrast"><a href="#mac_os_contrast">§</a>MacOS</h4>
<p>
  The Macintosh operating system was designed at Apple in the
early 1980s, inspired by pioneering work on GUIs done earlier at
Xerox's Palo Alto Research Center.  It saw its debut with the
Macintosh in 1984.  MacOS has gone through two significant design
transitions since, and is undergoing a third. The first transition was
the shift from supporting only a single application at a time to being
able to cooperatively multitask multiple applications (MultiFinder);
the second was the shift from 68000 to PowerPC processors, which both
preserved backward binary compatibility with 68K applications and
brought in an advanced shared library management system for PowerPC
applications, replacing the original 68K trap instruction-based
code-sharing system.  The third was the merger of MacOS design ideas
with a Unix-derived infrastructure in MacOS X.  Except where
specifically noted, the discussion here applies to pre-OS-X
versions.
</p>
<p>
  MacOS has a very strong unifying idea that is very different
from Unix's: the Mac Interface Guidelines.  These specify in
great detail what an application GUI should look like and how it
should behave.  The consistency of the Guidelines influenced the
culture of Mac users in significant ways.  Not infrequently,
simple-minded ports of DOS or Unix programs that did not follow the
Guidelines have been summarily rejected by the Mac user base and
failed in the marketplace.
</p>
<p>
  One key idea of the Guidelines is that things stay where you
put them. Documents, directories, and other objects have
persistent locations on the desktop that the system doesn't mess with,
and the desktop context persists through reboots.
</p>
<p>
  The Macintosh's unifying idea is so strong that most of the
other design choices we discussed above are either forced by it or
invisible.  All programs have GUIs.  There is no CLI at all.
Scripting facilities are present but much less commonly used than
under Unix; many Mac programmers never learn them.  MacOS's
captive-interface GUI metaphor (organized around a single main event
loop) leads to a weak scheduler without preemption.  The weak
scheduler, and the fact that all MultiFinder applications run in a
single large address space, implies that it is not practical to use
separated processes or even threads rather than polling.
</p>
<p>
  MacOS applications are not, however, invariably monster
monoliths.  The system's GUI support code, which is partly implemented
in a ROM shipped with the hardware and partly implemented in shared
libraries, communicates with MacOS programs through an event interface
that has been quite stable since its beginnings.  Thus, the design of
the operating system encourages a relatively clean separation between
application engine and GUI interface.
</p>
<p>
  MacOS also has strong support for isolating application metadata
like menu structures from the engine code.  MacOS files have both a
‘data fork’ (a Unix-style bag of bytes that
contains a document or program code) and a ‘resource fork’
(a set of user-definable file attributes).  Mac applications tend
to be designed so that (for example) the images and sound used in them
are stored in the resource fork and can be modified separately from
the application code.
</p>
<p>
  The MacOS system of internal boundaries is very weak.  There is
a wired-in assumption that there is but a single user, so there are no
per-user privilege groups.  Multitasking is cooperative, not
pre-emptive. All MultiFinder applications run in the same address
space, so bad code in any application can corrupt anything outside the
operating system's low-level kernel. Security cracks against MacOS
machines are very easy to write; the OS has been spared an epidemic
mainly because very few people are motivated to crack it.
</p>
<p>
  Mac programmers tend to design in the opposite direction from
Unix programmers; that is, they work from the interface inward, rather
than from the engine outward (we'll discuss some of the implications
of this choice in
  <a href="#futurechapter" title="Chapter 20. Futures">Chapter 20</a>).
Everything in the design of the MacOS conspires to encourage
this.
</p>
<p>
  The intended role for the Macintosh was as a client operating
system for nontechnical end users, implying a very low tolerance for
interface complexity.  Developers in the Macintosh culture became
very, very good at designing simple interfaces.
</p>
<p>
  The incremental cost of becoming a developer, assuming you have
a Macintosh already, has never been high.  Thus, despite rather
complex interfaces, the Mac developed a strong hobbyist culture early
on.  There is a vigorous tradition of small tools, shareware, and
user-supported software.
</p>
<p>
  Classic MacOS has been end-of-lifed.  Most of its facilities
have been imported into MacOS X, which mates them to a Unix
infrastructure derived from the
Berkeley
  tradition.<sup><a href="#ftn.id2889123" id="id2889123">[28]</a></sup>
  At
the same time, leading-edge Unixes such as
Linux
  are beginning to borrow ideas like file attributes (a generalization
of the resource fork) from MacOS.
</p>
<h4 id="os_2"><a href="#os_2">§</a>OS/2</h4>
<p>
  OS/2 began life as an
IBM
  development project
called ADOS (‘Advanced DOS’), one of three competitors to
become DOS 4. At that time, IBM and
Microsoft
  were
formally collaborating to develop a next-generation operating system
for the PC.  OS/2 1.0 was first released in 1987 for the 286, but was
unsuccessful.  The 2.0 version for the 386 came out in 1992, but by
that time the
IBM/Microsoft
  alliance had already fractured.
Microsoft went in a different (and more lucrative) direction with
Windows 3.0. OS/2 attracted a loyal minority following, but never
attracted a critical mass of developers and users.  It remained third
in the desktop market, behind the Macintosh, until being subsumed into
IBM's Java
  initiative after 1996.  The last released version was 4.0 in
1996. Early versions found their way into embedded systems and still,
as of mid-2003, run inside many of the world's automated teller
machines.
</p>
<p>
  Like Unix, OS/2 was built to be preemptively multitasking and
would not run on a machine without an MMU (early versions simulated an
MMU using the 286's memory segmentation).  Unlike Unix, OS/2 was never
built to be a multiuser system.  Process-spawning was relatively
cheap, but IPC was difficult and brittle.  Networking was initially
focused on LAN protocols, but a TCP/IP stack was added in later
versions.  There were no programs analogous to Unix service daemons,
so OS/2 never handled multi-function networking very well.
</p>
<p>
  OS/2 had both a CLI and GUI.  Most of the positive legendry
around OS/2 was about the Workplace Shell (WPS), the OS/2 desktop.
Some of this technology was licensed from the developers of the
AmigaOS Workbench,<sup><a href="#ftn.id2892797" id="id2892797">[29]</a></sup>
  a pioneering GUI desktop that still as of 2003 has a loyal fan
base in Europe.  This is the one area of the design in which OS/2
achieved a level of capability which Unix arguably has not yet
matched.  The WPS was a clean, powerful, object-oriented design with
understandable behavior and good extensibility.  Years later it would
become a model for Linux's GNOME project.
</p>
<p>
  The class-hierarchy design of WPS was one of OS/2's unifying
ideas.  The other was multithreading.  OS/2 programmers used threading
heavily as a partial substitute for IPC between peer processes.
No tradition of cooperating program toolkits developed.
</p>
<p>
  OS/2 had the internal boundaries one would expect in a
single-user OS.  Running processes were protected from each other, and
kernel space was protected from user space, but there were no per-user
privilege groups. This meant the file system had no protection against
malicious code.  Another consequence was that there was no analog of a
home directory; application data tended to be scattered all over the
system.
</p>
<p>
  A further consequence of the lack of multiuser capability was
that there could be no privilege distinctions in userspace.  Thus,
developers tended to trust only kernel code. Many system tasks
that in Unix would be handled by user-space daemons were jammed
into the kernel or the WPS.  Both bloated as a result.
</p>
<p>
  OS/2 had a text vs. binary mode (that is, a mode in which CR/LF
was read as a single end-of-line, versus one in which no such
interpretation was performed), but no other file record structure. It
supported file attributes, which were used for desktop persistence
after the manner of the Macintosh.  System databases were mostly in
binary formats.
</p>
<p>
  The preferred UI style was through the WPS. User interfaces
tended to be ergonomically better than Windows, though not up to
Macintosh standards (OS/2's most active period was relatively early in
the history of MacOS Classic).  Like Unix and Windows, OS/2's user
interface was themed around multiple, independent per-task groups of
windows, rather than capturing the desktop for the running
application.
</p>
<p>
  The intended audience for OS/2 was business and nontechnical
end users, implying a low tolerance for interface complexity.  It was
used both as a client operating system and as a file and print
server.
</p>
<p>
  In the early 1990s, developers in the OS/2 community began to
migrate to a Unix-inspired environment called EMX that emulated
POSIX
  interfaces.
Ports of Unix software started routinely showing up under OS/2 in the
latter half of the 1990s.
</p>
<p>
  Anyone could download EMX, which included the GNU Compiler
Collection and other open-source development tools.
IBM
  intermittently gave
away copies of the system documentation in the OS/2 developer's
toolkit, which was posted on many BBSs and FTP sites.  Because of
this, the “Hobbes” FTP archive of user-developed OS/2
software had already grown to over a gigabyte in size by 1995.  A very
vigorous tradition of small tools, exploratory programming, and
shareware developed and retained a loyal following for some years
after OS/2 itself was clearly headed for the dustbin of
history.
</p>
<p>
  After the release of Windows 95 the OS/2 community, feeling
beleaguered by Microsoft and encouraged by
IBM, became increasingly
interested in Java.  After the Netscape source code release in early
1998, the direction of migration changed (rather suddenly), toward
Linux.
</p>
<p>
  OS/2 is interesting as a case study in how far a multitasking
but single-user operating-system design can be pushed.  Most of the
observations in this case study would apply well to other operating
systems of the same general type, notably
AmigaOS<sup><a href="#ftn.id2892968" id="id2892968">[30]</a></sup>
  and GEM.<sup><a href="#ftn.id2892980" id="id2892980">[31]</a></sup>
  A wealth of OS/2
material is still available on the Web in 2003, including some
good histories.<sup><a href="#ftn.id2892994" id="id2892994">[32]</a></sup>
</p>
<h4 id="nt_contrast"><a href="#nt_contrast">§</a>Windows NT</h4>
<p>
  Windows NT (New Technology) is Microsoft's operating system for
high-end personal and server use; it is shipped in several variants
that can all be considered the same for our purposes.  All of
Microsoft's operating systems since the demise of Windows ME in 2000
have been NT-based; Windows 2000 was NT 5, and Windows XP (current in
2003) is NT 5.1.  NT is genetically descended from VMS, with which
it shares some important characteristics.
</p>
<p>
  NT has grown by accretion, and lacks a unifying metaphor
corresponding to Unix's “everything is a file” or the
MacOS
  desktop.<sup><a href="#ftn.id2893067" id="id2893067">[33]</a></sup>
  Because core
technologies are not anchored in a small set of persistent central
metaphors, they become obsolete every few years.  Each of the technology
generations — DOS (1981), Windows 3.1 (1992), Windows 95 (1995),
Windows NT 4 (1996), Windows 2000 (2000), Windows XP (2002), and
Windows Server 2003 (2003) — has
required that developers relearn fundamental things in a different
way, with the old way declared obsolete and no longer well
supported.
</p>
<p>
  There are other consequences as well:
</p>
 <div>
  <ul>
   <li>
    <p>
     The GUI facilities coexist uneasily with the weak, 
remnant command-line interface inherited from DOS and VMS.
    </p>
   </li>
   <li>
    <p>
     Socket programming has no unifying data object analogous to the
Unix everything-is-a-file-handle, so multiprogramming and network
applications that are simple in Unix require several more fundamental
concepts in NT.
    </p>
   </li>
  </ul>
 </div>
<p>
  NT has file attributes in some of its file system types.  They
are used in a restricted way, to implement access-control lists on
some file systems, and don't affect development style very much.  It
also has a record-type distinction, between text and binary files,
that produces occasional annoyances (both NT and OS/2 inherited this
misfeature from DOS).
</p>
<p>
  Though pre-emptive multitasking is supported, process-spawning
is expensive — not as expensive as in VMS, but (at about 0.1
seconds per spawn) up to an order of magnitude more so than on a modern
Unix.  Scripting facilities are weak, and the OS makes extensive use
of binary file formats. In addition to the expected consequences we
outlined earlier are these:
</p>
 <div>
  <ul>
   <li>
    <p>
     Most programs cannot be scripted at all.  Programs rely on
complex, fragile
     <em>remote procedure call</em> (RPC)
methods to communicate with each other, a rich source of bugs.
    </p>
   </li>
   <li>
    <p>
     There are no generic tools at all.  Documents and databases
can't be read or edited without special-purpose programs.
    </p>
   </li>
   <li>
    <p>
     Over time, the CLI has become more and more neglected because the
environment there is so sparse.  The problems associated with a weak
CLI have gotten progressively worse rather than better. (Windows
Server 2003 attempts to reverse this trend somewhat.)
    </p>
   </li>
  </ul>
 </div>
<p>
  System and user configuration data are centralized in a central
properties registry rather than being scattered through numerous
dotfiles and system data files as in Unix.  This also has consequences
throughout the design:
</p>
 <div>
  <ul>
   <li>
    <p>
     The registry makes the system completely non-orthogonal.
Single-point failures in applications can corrupt the registry,
frequently making the entire operating system unusable and requiring a
reinstall.
    </p>
   </li>
   <li>
    <p>
     The
     <em>registry creep</em> phenomenon: as the
registry grows, rising access costs slow down all programs.
    </p>
   </li>
  </ul>
 </div>
<p>
  NT systems on the Internet are notoriously vulnerable to worms,
viruses, defacements, and cracks of all kinds.  There are many reasons
for this, some more fundamental than others.  The most fundamental is
that NT's internal boundaries are extremely porous.
</p>
<p>
  NT has access control lists that can be used to implement
per-user privilege groups, but a great deal of legacy code
ignores them, and the operating system permits this in order not to
break backward compatibility.  There are no security controls on
message traffic between GUI clients, either,<sup><a href="#ftn.id2893243" id="id2893243">[34]</a></sup>
  and adding them would also break backward compatibility.
</p>
<p>
  While NT will use an MMU, NT versions after 3.5 have the system
GUI wired into the same address space as the privileged kernel for
performance reasons.  Recent versions even wire the webserver into
kernel space in an attempt to match the speed of Unix-based
webservers.
</p>
<p>
  These holes in the boundaries have the synergistic effect of
making actual security on NT systems effectively
impossible.<sup><a href="#ftn.id2893270" id="id2893270">[35]</a></sup>
  If an intruder can get code run as any user at all (e.g., through the
Outlook email-macro feature), that code can forge messages through the
window system to any other running application.  And any buffer
overrun or crack in the GUI or webserver can be exploited to take
control of the entire system.
</p>
 <p id="dll_hell">
  Because Windows does not handle library versioning
properly, it suffers from a chronic configuration problem called
“DLL hell”, in which installing new programs can randomly
upgrade (or even downgrade!) the libraries on which existing programs
depend.  This applies to the vendor-supplied system libraries as well
as to application-specific ones: it is not uncommon for an application
to ship with specific versions of system libraries, and break silently
when it does not have them.<sup><a href="#ftn.id2893313" id="id2893313">[36]</a></sup>
</p>
<p>
  On the bright side, NT provides sufficient facilities to host
Cygwin, which is a compatibility layer implementing Unix at both the
utilities and the API level, with remarkably few
compromises.<sup><a href="#ftn.id2893328" id="id2893328">[37]</a></sup>
  Cygwin
permits C programs to make use of both the Unix and the native APIs,
and is the first thing many Unix hackers install on such Windows
systems as they are compelled by circumstances to make use of.
</p>
<p>
  The intended audience for the NT operating systems is primarily 
nontechnical end users, implying a very low tolerance for interface
complexity.  It is used in both client and server roles.
</p>
<p>
  Early in its history Microsoft relied on third-party development
to supply applications.  They originally published full documentation
for the Windows APIs, and kept the price of development tools low.
But over time, and as competitors collapsed, Microsoft's strategy
shifted to favor in-house development, they began hiding APIs from
the outside world, and development tools grew more expensive.  As
early as Windows 95, Microsoft was requiring nondisclosure agreements
as a condition for purchasing professional-quality development
tools.
</p>
<p>
  The hobbyist and casual-developer culture that had grown up
around DOS and earlier Windows versions was large enough to be
self-sustaining even in the face of increasing efforts by Microsoft to
lock them out (including such measures as certification programs
designed to delegitimize amateurs).  Shareware never went away, and
Microsoft's policy began to reverse somewhat after 2000 under market
pressure from open-source operating systems and Java.  However,
Windows interfaces for ‘professional’ programming
continued to grow more complex over time, presenting an increasing
barrier to casual (or serious!) coding.
</p>
<p>
  The result of this history is a sharp dichotomy between the
design styles practiced by amateur and professional NT developers
— the two groups barely communicate.  While the hobbyist culture
of small tools and shareware is very much alive, professional NT
projects tend to produce monster monoliths even bulkier than those
characteristic of ‘elitist’ operating systems like
VMS.
</p>
<p>
  Unix-like shell facilities, command sets, and library APIs 
are available under Windows through third-party libraries including
UWIN, Interix, and the open-source Cygwin.
</p>
<h4 id="beos"><a href="#beos">§</a>BeOS</h4>
<p>
  Be, Inc. was founded in 1989 as a hardware vendor, building
pioneering multiprocessing machines around the PowerPC chip.  BeOS was
Be's attempt to add value to the hardware by inventing a new,
network-ready operating system model incorporating the lessons of both
Unix and the MacOS family, without being either.  The result was a
tasteful, clean, and exciting design with excellent performance in its
chosen role as a multimedia platform.
</p>
<p>
  BeOS's unifying ideas were ‘pervasive threading’,
multimedia flows, and the file system as database.  BeOS was designed
to minimize latency in the kernel, making it well-suited for
processing large volumes of data such as audio and video streams 
in real time.  BeOS ‘threads’ were actually lightweight
processes in Unix terminology, since they supported thread-local
storage and therefore did not necessarily share all address spaces.
IPC via shared memory was fast and efficient.
</p>
<p>
  BeOS followed the Unix model in having no file structure above
the byte level. Like the MacOS, it supported and used file
attributes.  In fact, the BeOS file system was actually a database
that could be indexed by any attribute.
</p>
<p>
  One of the things BeOS took from Unix was intelligent design of
internal boundaries.  It made full use of an MMU, and sealed running
processes off from each other effectively.  While it presented as a
single-user operating system (no login), it supported Unix-like
privilege groups in the file system and elsewhere in the OS internals.
These were used to protect system-critical files from being touched by
untrusted code; in Unix terms, the user was logged in as an anonymous
guest at boot time, with the only other ‘user’ being root.
Full multiuser operation would have been a small change to the upper
levels of the system, and there was in fact a BeLogin utility.
</p>
<p>
  BeOS tended to use binary file formats and the native database
built into the file system, rather than Unix-like textual
formats.
</p>
<p>
  The preferred UI style of BeOS was GUI, and it leaned heavily on
MacOS experience in interface design.  CLI and scripting were,
however, also fully supported.  The command-line shell of BeOS was a
port of
bash(1),
the dominant open-source Unix shell, running through a
POSIX
  compatibility
library.  Porting of Unix CLI software was, by design, trivially easy.
Infrastructure to support the full panoply of scripting, filters, and
service daemons that goes with the Unix model was in place.
</p>
<p>
  BeOS's intended role was as a client operating system
specialized for near-real-time multimedia processing (especially sound
and video manipulation).  Its intended audience included technical and
business end users, implying a moderate tolerance for interface
complexity.
</p>
<p>
  Entry barriers to BeOS development were low; though the
operating system was proprietary, development tools were inexpensive
and full documentation was readily available.  The BeOS effort began
as part of one of the efforts to unseat Intel's hardware with RISC
technology, and was continued as a software-only effort after the
Internet explosion.  Its strategists were paying attention during
Linux's formative period in the early 1990s, and were fully aware of
the value of a large casual-developer base.  In fact they succeeded in
attracting an intensely loyal following; as of 2003 no fewer
than five separate projects are attempting to resurrect BeOS in open
source.
</p>
<p>
  Unfortunately, the business strategy surrounding BeOS was not as
astute as the technical design.  The BeOS software was originally
bundled with dedicated hardware, and marketed with only vague hints
about intended applications. Later (1998) BeOS was ported to generic PCs
and more closely focused on multimedia applications, but never
attracted a critical mass of applications or users.  BeOS finally
succumbed in 2001 to a combination of anticompetitive maneuvering by
Microsoft (lawsuit in progress as of 2003) and competition
from variants of Linux
  that had been adapted for multimedia
handling.
</p>
<h4 id="mvs"><a href="#mvs">§</a>MVS</h4>
<p>
  MVS (Multiple Virtual Storage) is IBM's flagship operating
system for its mainframe computers. Its roots stretch back to OS/360,
which began life in the mid-1960s as the operating system IBM wanted
its customers to use on the then-new System/360 computer systems.
Descendants of this code remain at the heart of today's IBM mainframe
operating systems.  Though the code has been almost entirely
rewritten, the basic design is largely untouched; backward
compatibility has been religiously maintained, to the point that
applications written for OS/360 run unmodified on the MVS of 64-bit
z/Series mainframe computers three architectural generations
later.
</p>
<p>
  Of all the operating systems surveyed here, MVS is the only one
that could be considered older than Unix (the ambiguity stems from the
degree to which it has evolved over time).  It is also the least
influenced by Unix concepts and technology, and represents the
strongest design contrast with Unix.  The unifying idea of MVS is that
all work is batch; the system is designed to make the most efficient
possible use of the machine for batch processing of huge amounts of
data, with minimal concessions to interaction with human users.
</p>
<p>
  Native MVS terminals (the 3270 series) operate only in block
mode.  The user is presented with a screen that he fills in,
modifying local storage in the terminal.  No interrupt is presented to
the mainframe until the user presses the send key.  Character-level
interaction, in the manner of Unix's raw mode, is impossible.
</p>
<p>
  TSO, the closest equivalent to the Unix interactive environment,
is limited in native capabilities.  Each TSO user is represented to
the rest of the system as a simulated batch job. The facility is
expensive — so much so that its use is typically limited to
programmers and support staff.  Ordinary users who need to merely run
applications from a terminal almost never use TSO. Instead, they work
through transaction monitors, a kind of multiuser application server
that does cooperative multitasking and supports asynchronous I/O. In
effect, each kind of transaction monitor is a specialized timesharing
plugin (almost, but not entirely unlike a webserver running CGI).
</p>
<p>
  Another consequence of the batch-oriented architecture is that
process spawning is a slow operation. The I/O system deliberately
trades high setup cost (and associated latency) for better
throughput. These choices are a good match for batch operation, but
deadly to interactive response. A predictable result is that TSO users
nowadays spend almost all their time inside a dialog-driven interactive
environment, ISPF. It is rare for a programmer to do anything inside
native TSO except start up an instance of ISPF. This does away with
process-spawn overhead, at the cost of introducing a very large
program that does everything but start the machine room
coffeepot.
</p>
<p>
  MVS uses the machine MMU; processes have separate address
spaces. Interprocess communication is supported only through shared
memory. There are facilities for threading (which MVS calls
“subtasking”), but they are lightly used, mainly because
the facility is only easily accessible from programs written in
assembler. Instead, the typical batch application is a short series of
heavyweight program invocations glued together by JCL (Job Control
Language) which provides scripting, though in a notoriously difficult
and inflexible way. Programs in a job communicate through temporary
files; filters and the like are nearly impossible to do in a usable
manner.
</p>
<p>
  Every file has a record format, sometimes implied (inline input
files in JCL are implied to have an 80-byte fixed-length record format
inherited from punched cards, for example), but more often explicitly
specified. Many system configuration files are in text format, but
application files are usually in binary formats specific to the
application.  Some general tools for examining files have evolved out
of sheer necessity, but it is still not an easy problem to solve.
</p>
<p>
  File system security was an afterthought in the original
design. However, when security was found to be necessary, IBM added it
in an inspired fashion: They defined a generic security API, then made
all file access requests pass by that interface before being
processed. As a result, there are at least three competing security
packages with differing design philosophies — and all of them
are quite good, with no known cracks against them between 1980 and
mid-2003. This variety allows an installation to select the package
that best suits local security policy.
</p>
<p>
  Networking facilities are another afterthought. There is no
concept of one interface for both network connections and local files;
their programming interfaces are separate and quite different. This
did allow TCP/IP to supplant IBM's native SNA (Systems Network
Architecture) as the network protocol of choice fairly seamlessly. It
is still common in 2003 to see both in use at a given
installation, but SNA is dying out.
</p>
<p>
  Casual programming for MVS is almost nonexistent except within
the community of large enterprises that run MVS. This is not due so
much to the cost of the tools themselves as it is to the cost of the
environment — when one must spend several million dollars on the
computer system, a few hundred dollars a month for a compiler is
almost incidental.  Within that community, however, there is a
thriving culture of freely available software, mainly programming and
system-administration tools. The first computer user's group, SHARE,
was founded in 1955 by IBM users, and is still going strong
today.
</p>
<p>
  Considering the vast architectural differences, it is a
remarkable fact that MVS was the first non-System-V operating system
to meet the Single Unix Specification (there is less to this than
meets the eye, however, as ports of Unix software from elsewhere have
a strong tendency to founder on ASCII-vs.-EBCDIC character-set
issues). It's possible to start a Unix shell from TSO; Unix
file systems are specially formatted MVS data sets.  The MVS Unix
character set is a special EBCDIC codepage with newline and linefeed
swapped (so that what appears as linefeed to Unix appears like newline
to MVS), but the system calls are real system calls implemented in the
MVS kernel.
</p>
<p>
  As the cost of the environment drops into the hobbyist range,
there is a small but growing group of users of the last public-domain
version of MVS (3.8, dating from 1979). This system, as well as
development tools and the emulator to run them, are all available for
the cost of a CD.<sup><a href="#ftn.id2893754" id="id2893754">[38]</a></sup>
</p>
<p>
  The intended role of MVS has always been in the back
office. Like VMS and Unix itself, MVS predates the server/client
distinction. Interface complexity for back-office users is not only
tolerated but expected, in the name of making the computer spend
fewer expensive resources on interfaces and more on the work it's
there to get done.
</p>
<h4 id="id2893777"><a href="#id2893777">§</a>VM/CMS</h4>
<p>
  VM/CMS is IBM's
  <em>other</em>
  mainframe operating
system.  Historically speaking, it is Unix's uncle: the common
ancestor is the CTSS
  system, developed at MIT around 1963 and running on the IBM 7094
mainframe.  The group that developed CTSS then went on to write
Multics, the immediate ancestor of Unix.  IBM established a group in
Cambridge to write a timesharing system for the IBM 360/40, a modified
360 with (for the first time on an IBM system) a paging
MMU.<sup><a href="#ftn.id2893806" id="id2893806">[39]</a></sup>
  The MIT
and IBM programmers continued to interact for many years thereafter,
and the new system got a user interface that was very CTSS-like,
complete with a shell named EXEC and a large supply of utilities
analogous to those used on Multics and later on Unix.
</p>
<p>
  In another sense, VM/CMS and Unix are funhouse mirror images of
one another.  The unifying idea of the system, provided by the VM
component, is virtual machines, each of which looks exactly like the
underlying physical machine.  They are preemptively multitasked, and
run either the single-user operating system CMS or a complete
multitasking operating system (typically MVS, Linux, or another
instance of VM itself).  Virtual machines correspond to Unix
processes, daemons, and emulators, and communication between them is
accomplished by connecting the virtual card punch of one machine to
the virtual card reader of another.  In addition, a layered tools
environment called CMS Pipelines is provided within CMS, directly
modeled on Unix's pipes but architecturally extended to support
multiple inputs and outputs.
</p>
<p>
  When communication between them has not been explicitly set up,
virtual machines are completely isolated from each other.  The
operating system has the same high reliability, scalability, and
security as MVS, and has far greater flexibility and is much easier to
use.  In addition, the kernel-like portions of CMS do not need to be
trusted by the VM component, which is maintained completely
separately.
</p>
<p>
  Although CMS is record-oriented, the records are essentially
equivalent to the lines that Unix textual tools use.  Databases are
much better integrated into CMS Pipelines than is typically the case
on Unix, where most databases are quite separate from the operating
system.  In recent years, CMS has been augmented to fully support the
Single Unix Specification.
</p>
<p>
  The UI style of CMS is interactive and conversational, very
unlike MVS but like VMS and Unix.  A full-screen editor called XEDIT
is heavily used.
</p>
<p>
  VM/CMS predates the client/server distinction, and is nowadays
used almost entirely as a server operating system with emulated IBM
terminals.  Before Windows came to dominate the desktop so completely,
VM/CMS provided word-processing services and email both internally to
IBM and between mainframe customer sites — indeed, many VM systems
were installed exclusively to run those applications because of VM's
ready scalability to tens of thousands of users.
</p>
<p>
  A scripting language called Rexx supports programming in a style
not unlike shell, awk, Perl or Python.  Consequently, casual
programming (especially by system administrators) is very important on
VM/CMS.  Free cycles permitting, admins often prefer to run production
MVS in a virtual machine rather than directly on the bare iron, so
that CMS is also available and its flexibility can be taken advantage
of.  (There are CMS tools that permit access to MVS
file systems.)
</p>
<p>
  There are even striking parallels between the history of VM/CMS
within IBM and Unix within Digital Equipment Corporation (which made
the hardware that Unix first ran on).  It took IBM years to understand
the strategic importance of its unofficial timesharing system, and
during that time a community of VM/CMS programmers arose that was
closely analogous in behavior to the early Unix community.  They
shared ideas, shared discoveries about the system, and above all
shared source code for utilities.  No matter how often IBM tried to
declare VM/CMS dead, the community — which included IBM's own
MVS system developers! — insisted on keeping it alive.  VM/CMS
even went through the same cycle of de facto open source to closed
source back to open source, though not as thoroughly as Unix
did.
</p>
<p>
  What VM/CMS lacks, however, is any real analog to C.  Both VM
and CMS were written in assembler and have remained so implemented.
The nearest equivalent to C was various cut-down versions of PL/I that
IBM used for systems programming, but did not share with its
customers.  Therefore, the operating system remains trapped on its
original architectural line, though it has grown and expanded as the
360 architecture became the 370 series, the XA series, and finally the
current z/Series.
</p>
<p>
  Since the year 2000, IBM has been promoting VM/CMS on mainframes
to an unprecedented degree — as ways to host thousands of
virtual Linux machines at once.
</p>
<h4 id="linux"><a href="#linux">§</a>Linux</h4>
<p>
  Linux, originated by Linus Torvalds in 1991, leads the pack of
new-school open-source Unixes that have emerged since 1990 (also
including FreeBSD, NetBSD, OpenBSD, and Darwin), and is representative of the design
direction being taken by the group as a whole.  The trends in it can
be taken as typical for this entire group.
</p>
<p>
  Linux does not include any code from the original Unix source
tree, but it was designed from Unix standards to behave like a Unix.
In the rest of this book, we emphasize the continuity between Unix and
Linux.  That continuity is extremely strong, both in terms of
technology and key developers — but here we emphasize some
directions Linux is taking that mark a departure from
‘classical’ Unix tradition.
</p>
<p>
  Many developers and activists in the Linux community have
ambitions to win a substantial share of end-user desktops.  This makes
Linux's intended audience quite a bit broader than was ever the case
for the old-school Unixes, which have primarily aimed at the server
and technical-workstation markets.  This has implications for the
way Linux hackers design software.
</p>
<p>
  The most obvious change is a shift in preferred interface
styles.  Unix was originally designed for use on teletypes and slow
printing terminals.  Through much of its lifetime it was strongly
associated with character-cell video-display terminals lacking either
graphics or color capabilities.  Most Unix programmers stayed firmly
wedded to the command line long after large end-user applications had
migrated to X-based GUIs, and the design of both Unix
operating systems and their applications have continued to reflect
this fact.
</p>
<p>
  Linux users and developers, on the other hand, have been
adapting themselves to address the nontechnical user's fear of CLIs.
They have moved to building GUIs and GUI tools much more intensively
than was the case in old-school Unix, or even in contemporary
proprietary Unixes.  To a lesser but significant extent, this is true
of the other open-source Unixes as well.
</p>
<p>
  The desire to reach end users has also made Linux developers
much more concerned with smoothness of installation and software
distribution issues than is typically the case under proprietary Unix
systems.  One consequence is that Linux features binary-package
systems far more sophisticated than any analogs in proprietary
Unixes, with interfaces designed (as of 2003, with only mixed
success) to be palatable to nontechnical end users.
</p>
<p>
  The Linux community wants, more than the old-school Unixes ever
did, to turn their software into a sort of universal pipefitting for
connecting together other environments.  Thus, Linux features support
for reading and (often) writing the file system formats and networking
methods native to other operating systems.  It also supports
multiple-booting with them on the same hardware, and simulating them
in software inside Linux itself.  The long-term goal is subsumption;
Linux emulates so it can absorb.<sup><a href="#ftn.id2894051" id="id2894051">[40]</a></sup>
</p>
<p>
  The goal of subsuming the competition, combined with the drive
to reach the end-user, has motivated Linux developers to adopt design
ideas from non-Unix operating systems to a degree that makes
traditional Unixes look rather insular.  Linux applications using
Windows .INI format files for configuration is a minor example we'll
cover in
  <a href="#configurationchapter" title="Chapter 10. Configuration"> Chapter 10</a>;
Linux 2.5's incorporation of extended file attributes, which among
other things can be used to emulate the semantics of the Macintosh
resource fork, is a recent major one at time of writing.
</p>
 <blockquote>
  <p>
   But the day Linux gives the Mac diagnostic that you can't open a
file because you don't have the application is the day Linux becomes
non-Unix.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  The remaining proprietary Unixes (such as Solaris, HP-UX, AIX,
etc.) are designed to be big products for big IT budgets.  Their
economic niche encourages designs optimized for maximum power on
high-end, leading-edge hardware.  Because Linux has part of its roots
among PC hobbyists, it emphasizes doing more with less.  Where
proprietary Unixes are tuned for multiprocessor and server-cluster
operation at the expense of performance on low-end hardware, core
Linux developers have explicitly chosen not to accept more complexity
and overhead on low-end machines for marginal performance gains on
high-end hardware.
</p>
<p>
  Indeed, a substantial fraction of the Linux user community is
understood to be wringing usefulness out of hardware as technically
obsolete today as Ken Thompson's PDP-7 was in 1969. As a consequence,
Linux applications are under pressure to stay lean and mean that their
counterparts under proprietary Unix do not experience.
</p>
<p>
  These trends have implications for the future of Unix as a
whole, a topic we'll return to in
  <a href="#futurechapter" title="Chapter 20. Futures">Chapter 20</a>.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2888666" id="ftn.id2888666">[24]</a></sup>
  See the
  <a href="http://www.osdata.com/">
   OSData website</a>.
</p>

<p><sup><a href="#id2888745" id="ftn.id2888745">[25]</a></sup>
  Except
for Multics which exerted most of its influence between the time its
specifications were published in 1965 and when it actually shipped in
1969.
</p>

<p><sup><a href="#id2888778" id="ftn.id2888778">[26]</a></sup>
  For details on the
lawsuit, see Marshall Kirk McKusick's paper in <sup><a href="#OpenSources" title="[OpenSources]">[OpenSources]</a></sup>.
</p>
</div>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2888820" id="ftn.id2888820">[27]</a></sup>
  More information is available at the
  <a href="http://www.openvms.org">
   OpenVMS.org site</a>.
</p>

<p><sup><a href="#id2889123" id="ftn.id2889123">[28]</a></sup>
  MacOS X actually consists of two
proprietary layers (ports of the OpenStep and Classic Mac GUIs)
layered over an open-source Unix core (Darwin).
</p>
</div>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2892797" id="ftn.id2892797">[29]</a></sup>
  In return for some Amiga technology,
IBM gave Commodore a license for its REXX scripting language. The deal
is described at
  <a href="http://www.os2bbs.com/os2news/OS2Warp.html">
   http://www.os2bbs.com/os2news/OS2Warp.html</a>.
</p>

<p><sup><a href="#id2892968" id="ftn.id2892968">[30]</a></sup>
  <a href="http://os.amiga.com/">
   AmigaOS
Portal</a>.
</p>

<p><sup><a href="#id2892980" id="ftn.id2892980">[31]</a></sup>
  <a href="http://www.geocities.com/SiliconValley/Vista/6148/gem.html">
   The
GEM Operating System</a>.
</p>

<p><sup><a href="#id2892994" id="ftn.id2892994">[32]</a></sup>
  See, for example, the
  <a href="http://www.os2voice.org/">
   OS Voice</a>
  and
  <a href="http://www.os2bbs.com/">
   OS/2 BBS.COM</a>
  sites.
</p>

<p><sup><a href="#id2893067" id="ftn.id2893067">[33]</a></sup>
  Perhaps. It has been argued that the unifying
metaphor of all Microsoft operating systems is “the customer
must be locked in”.
</p>

<p><sup><a href="#id2893243" id="ftn.id2893243">[34]</a></sup>
  <a href="http://security.tombom.co.uk/shatter.html">
   http://security.tombom.co.uk/shatter.html</a>
</p>

<p><sup><a href="#id2893270" id="ftn.id2893270">[35]</a></sup>
  Microsoft actually admitted publicly that NT
security is impossible in March 2003. See
  <a href="http://www.microsoft.com/technet/treeview/default.asp?url=/technet/security/bulletin/MS03-010.asp">
   http://www.microsoft.com/technet/treeview/default.asp?url=/technet/security/bulletin/MS03-010.asp</a>.
</p>

<p><sup><a href="#id2893313" id="ftn.id2893313">[36]</a></sup>
  The DLL hell problem is
somewhat mitigated by the .NET development framework, which handles
library versioning — but as of 2003 .NET only ships on the
highest-end server versions of NT.
</p>

<p><sup><a href="#id2893328" id="ftn.id2893328">[37]</a></sup>
  Cygwin is largely compliant with the
Single Unix Specification, but programs requiring direct hardware
access run into limitations in the Windows kernel that hosts it.
Ethernet cards are notoriously problematic.
</p>

<p><sup><a href="#id2893754" id="ftn.id2893754">[38]</a></sup>
  <a href="http://www.cbttape.org/cdrom.htm">
   http://www.cbttape.org/cdrom.htm</a>
</p>

<p><sup><a href="#id2893806" id="ftn.id2893806">[39]</a></sup>
  The development machine and initial target was a 40
with customized microcode, but it proved insufficiently powerful;
production deployment was on the 360/67.
</p>

<p><sup><a href="#id2894051" id="ftn.id2894051">[40]</a></sup>
  The results of Linux's
emulate-and-subsume strategy differ noticeably from the
embrace-and-extend practiced by some of its competitors. For
starters, Linux does not break compatibility with what it is
emulating in order to lock customers into the “extended”
version.
</p>
</div>


<!-- FILE: ch03s03.html -->
<h3 id="ch03s03"><a href="#ch03s03">§</a>What Goes Around, Comes Around</h3>
<p>
  We attempted to select for comparison timesharing systems that
either are now or have in the past been competitive with Unix.  The
field of plausible candidates is not wide.  Most
(Multics, ITS, DTSS,
TOPS-10, TOPS-20, MTS, GCOS, MPE and perhaps a
dozen others) are so long dead that they are fading from the
collective memory of the computing field.  Of those we surveyed, VMS
and OS/2 are moribund, and MacOS has been subsumed by a Unix
derivative. MVS and VM/CMS were limited to a single proprietary
mainframe line.  Only Microsoft Windows remains as a viable competitor
independent of the Unix tradition.
</p>
<p>
  We pointed out Unix's strengths in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">Chapter 1</a>, and they are certainly part of the
explanation.  But it's actually more instructive to look at the
obverse of that answer and ask which weaknesses in Unix's competitors
did them in.
</p>
<p>
  The most obvious shared problem is nonportability.  Most of
Unix's pre-1980 competitors were tied to a single hardware platform,
and died with that platform.  One reason VMS survived long enough to
merit inclusion here as a case study is that it was successfully
ported from its original VAX hardware to the Alpha processor (and in
2003 is being ported from Alpha to Itanium).  MacOS successfully
made the jump from the Motorola 68000 to PowerPC chips in the late
1980s.  Microsoft Windows
  escaped this problem by being in the
right place when commoditization flattened the market for
general-purpose computers into a PC monoculture.
</p>
<p>
  From 1980 on, another particular weakness continually reemerges
as a theme in different systems that Unix either steamrollered or
outlasted: an inability to support networking gracefully.
</p>
<p>
  In a world of pervasive networking, even an operating system
designed for single-user use needs multiuser capability (multiple
privilege groups) — because without that, any network
transaction that can trick a user into running malicious code will
subvert the entire system (Windows macro viruses are only the tip of
this iceberg).  Without strong multitasking, the ability of an
operating system to handle network traffic and run user programs at
the same time will be impaired.  The operating system also needs
efficient IPC so that its network programs can communicate with each
other and with the user's foreground applications.
</p>
<p>
  Windows gets away with having severe deficiencies in these areas
only by virtue of having developed a monopoly position before
networking became really important, and by having a user population
that has been conditioned to accept a shocking frequency of crashes
and security breaches as normal.  This is not a stable situation, and
it is one that partisans of Linux have successfully (in 2003)
exploited to make major inroads in the server-operating-system
market.
</p>
<p>
  Around 1980, during the early heyday of personal computers,
operating-system designers dismissed Unix and traditional timesharing
as heavyweight, cumbersome, and inappropriate for the brave new world
of single-user personal machines — despite the fact that GUI
interfaces tended to demand the reinvention of multitasking to cope
with threads of execution bound to different windows and widgets.  The
trend toward client operating systems was so intense that server
operating systems were at times dismissed as steam-powered relics of a
bygone age.
</p>
<p>
  But as the designers of BeOS noticed, the requirements of
pervasive networking cannot be met without implementing something very
close to general-purpose timesharing.  Single-user client operating
systems cannot thrive in an Internetted world.
</p>
<p>
  This problem drove the reconvergence of client and server
operating systems.  The first, pre-Internet attempts at peer-to-peer
networking over LANs, in the late 1980s, began to expose the
inadequacy of the client-OS design model.  Data on a network has to
have rendezvous points in order to be shared; thus, we can't do
without servers.  At the same time, experience with the Macintosh and
Windows client operating systems raised the bar on the minimum quality
of user experience customers would tolerate.
</p>
<p>
  With non-Unix models for timesharing effectively dead by 1990,
there were not many possible responses client operating-system
designers could mount to this challenge. They could co-opt Unix (as
MacOS X has done), re-invent roughly equivalent features a patch at a
time (as Windows has done), or attempt to reinvent the entire world
(as BeOS tried and failed to do).  But meanwhile, open-source Unixes
were growing client-like capabilities to use GUIs and run on
inexpensive personal machines.
</p>
<p>
  These pressures turned out, however, not to be as symmetrically
balanced as the above description might imply.  Retrofitting
server-operating-system features like multiple privilege classes and
full multitasking onto a client operating system is very difficult,
quite likely to break compatibility with older versions of the client,
and generally produces a fragile and unsatisfactory result rife with
stability and security problems.  Retrofitting a GUI onto a server
operating system, on the other hand, raises problems that can largely
be finessed by a combination of cleverness and throwing
ever-more-inexpensive hardware resources at the problem.  As with
buildings, it's easier to repair superstructure on top of a solid 
foundation than it is to replace the foundations without 
trashing the superstructure.
</p>
<p>
  Besides having the native architectural strengths of a server
operating system,  Unix was always agnostic about its intended
audience.  Its designers and implementers never assumed they knew all
potential uses the system would be put to.
</p>
<p>
  Thus, the Unix design proved more capable of reinventing itself as
a client than any of its client-operating-system competitors were of
reinventing themselves as servers.  While many other factors of
technology and economics contributed to the Unix resurgence of
the 1990s, this is one that really foregrounds itself in any
discussion of operating-system design style.
</p>



<!-- FILE: design.html -->
<h2 id="design"><a href="#design">§</a>Design</h2>


<!-- FILE: modularitychapter.html -->
<h3 id="modularitychapter"><a href="#modularitychapter">§</a>Chapter 4. Modularity</h3>
 <blockquote class="epigraph">
  <p>
   There are two ways of constructing a software design.  One is to make
it so simple that there are obviously no deficiencies; the other is to
make it so complicated that there are no obvious deficiencies. The
first method is far more difficult.
  </p>
  <span>
   – C. A. R. Hoare
The Emperor's Old Clothes, CACM February 1981
  </span>
 </blockquote>
<p>
  There is a natural hierarchy of code-partitioning methods that
has evolved as programmers have had to manage ever-increasing levels
of complexity.  In the beginning, everything was one big lump of
machine code.  The earliest procedural languages brought in the notion
of partition by subroutine.  Then we invented service libraries to
share common utility functions among multiple programs. Next, we
invented separated address spaces and communicating processes.  Today we
routinely distribute program systems across multiple hosts separated
by thousands of miles of network cable.
</p>
<p>
  The early developers of Unix were among the pioneers in software
modularity.  Before them, the Rule of Modularity was computer-science
theory but not engineering practice.  In
  <em>Design Rules</em><sup><a href="#Baldwin-Clark" title="[Baldwin-Clark]">[Baldwin-Clark]</a></sup>, a path-breaking
study of the economics of modularity in engineering design, the
authors use the development of the computer industry as a case study 
and argue that the Unix community was in fact the first to
systematically apply modular decomposition to production software, as
opposed to hardware.  Modularity of hardware has of course been one
of the foundations of engineering since the adoption of standard 
screw threads in the late 1800s.
</p>
<p>
  The Rule of Modularity bears amplification here: The only way to
write complex software that won't fall on its face is to build it out
of simple modules connected by well-defined interfaces, so that most
problems are local and you can have some hope of fixing or optimizing
a part without breaking the whole.
</p>
<p>
  The tradition of being careful about modularity and of paying
close attention to issues like
orthogonality
  and compactness are still much deeper in the bone among Unix
programmers than elsewhere.
</p>
 <blockquote>
  <p>
   Early Unix programmers became good at modularity because they had to
be.  An OS is one of the most complicated pieces of code around.  If
it is not well structured, it will fall apart.  There were a couple of
early failures at building Unix that were scrapped.  One can blame the
early (structureless) C for this, but basically it was because the OS
was too complicated to write.  We needed both refinements in tools (like C 
structures) and good practice in using them (like Rob Pike's rules for 
programming) before we could tame that complexity.
  </p>
  <span>
   – Ken Thompson
  </span>
 </blockquote>
<p>
  Early Unix hackers struggled with this in many ways.  In the
languages of 1970 function calls were expensive, either because call
semantics were complicated (PL/1.  Algol) or because the compiler was
optimizing for other things like fast inner loops at the expense of
call time.  Thus, code tended to be written in big lumps.  Ken and
several of the other early Unix developers knew modularity was a good
idea, but they remembered PL/1 and were reluctant to write small
functions lest performance go to hell.
</p>
 <blockquote>
  <p>
   Dennis Ritchie encouraged modularity by telling all and sundry that
function calls were really, really cheap in C.  Everybody started
writing small functions and modularizing.  Years later we found out
that function calls were still expensive on the PDP-11, and VAX code 
was often spending 50% of its time in the CALLS instruction.  Dennis
had lied to us!  But it was too late; we were all hooked...
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>
<p>
  All programmers today, Unix natives or not, are taught to
modularize at the subroutine level within programs.  Some learn the
art of doing this at the module or abstract-data-type level and call
that ‘good design’.  The
design-patterns
  movement is making a noble effort to
push up a level from there and discover successful design abstractions
that can be applied to organize the large-scale structure of
programs.
</p>
<p>
  Getting better at all these kinds of problem partitioning is a
worthy goal, and many excellent treatments of them are available
elsewhere.  We shall not attempt to cover all the issues relating to
modularity within programs in too much detail: first, because that is
a subject for an entire volume (or several volumes) in itself; and
second, because this is a book about the art of
  <em>Unix</em>
  programming.
</p>
<p>
  What we will do here is examine more specifically what the Unix
tradition teaches us about how to follow the Rule of Modularity.  In
this chapter, our examples will live within process units.  Later, in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">Chapter 7</a>, we'll
examine the circumstances under which partitioning programs into
multiple cooperating processes is a good idea, and discuss more
specific techniques for doing that partitioning.
</p>



<!-- FILE: ch04s01.html -->
<h3 id="ch04s01"><a href="#ch04s01">§</a>Encapsulation and Optimal Module Size</h3>
<p>
  The first and most important quality of modular code is
  <em>encapsulation</em>.  Well-encapsulated modules don't
expose their internals to each other.  They don't call into the middle
of each others' implementations, and they don't promiscuously share
global data.  They communicate using application programming
interfaces (APIs) — narrow, well-defined sets of procedure calls
and data structures.  This is what the Rule of Modularity is
about.
</p>
<p>
  The APIs between modules have a dual role. On the implementation
level, they function as choke points between the modules,
preventing the internals of each from leaking into its neighbors.  On
the design level, it is the APIs (not the bits of implementation
between them) that really define your architecture.
</p>
<p>
  One good test for whether an API is well designed is this one:
if you try to write a description of it in purely human language
(with no source-code extracts allowed), does it make sense?  It is a
very good idea to get into the habit of writing informal descriptions
of your APIs before you code them.  Indeed, some of the most able
developers start by defining their interfaces, writing brief comments
to describe them, and then writing the code — since the process
of writing the comment clarifies what the code must do.  Such
descriptions help you organize your thoughts, they make useful module
comments, and eventually you might want to turn them into a roadmap
document for future readers of the code.
</p>
<p>
  As you push module decomposition harder, the pieces get smaller and the
definition of the APIs gets more important. Global complexity,
and consequent vulnerability to bugs, decreases.  It has been received
wisdom in computer science since the 1970s (exemplified in papers such
as <sup><a href="#Parnas" title="[Parnas]">[Parnas]</a></sup>) that you ought to design
your software systems as hierarchies of nested modules, with the grain
size of the modules at each level held to a minimum.
</p>
<p>
  It is possible, however, to push this kind of decomposition too hard and make your modules too small.  There is
  evidence <sup><a href="#Hatton97" title="[Hatton97]">[Hatton97]</a></sup> that when one plots defect density versus
  module size, the curve is U-shaped and concave upwards (see Figure 4.1).  Very small and very large modules are
  associated with more bugs than those of intermediate size. A different way of viewing the same data is to plot lines
  of code per module versus total bugs.  The curve looks roughly logarithmic up to a ‘sweet spot’ where it flattens
  (corresponding to the minimum in the defect density curve), after which it goes up as the square of the number of the
  lines of code (which is what one might intuitively expect for the whole curve, following Brooks's
Law<sup><a href="#ftn.id2894437" id="id2894437">[41]</a></sup>).
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 4.1. Qualitative plot of defect count and
density vs. module size.
   </b>
  </p>
  <div class="center">
   <img alt="Qualitative plot of defect count and density vs. module size." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  This unexpectedly increasing incidence of bugs at small module
sizes holds across a wide variety of systems implemented in different
languages.  Hatton has proposed a model relating this nonlinearity to
the chunk size of human short-term memory.<sup><a href="#ftn.id2894501" id="id2894501">[42]</a></sup>
  Another way to interpret
the nonlinearity is that at small module grain sizes, the increasing
complexity of the interfaces becomes the dominating term; it's
difficult to read the code because you have to understand everything
before you can understand anything.  In
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">Chapter 7</a>
  we'll examine more advanced forms of
program partitioning; there, too, the complexity of interface
protocols comes to dominate the total complexity of the system as the
component processes get smaller.
</p>
<p>
  In nonmathematical terms, Hatton's empirical results imply a sweet spot
between 200 and 400 logical lines of code that minimizes probable
defect density, all other factors (such as programmer skill) being
equal.  This size is independent of the language being used — an
observation which strongly reinforces the advice given elsewhere in
this book to program with the most powerful languages and tools you
can.  Beware of taking these numbers too literally however. Methods
for counting lines of code vary considerably according to what the
analyst considers a logical line, and other biases (such as whether
comments are stripped).  Hatton himself suggests as a rule of thumb a
2x conversion between logical and physical lines, suggesting an
optimal range of 400–800 physical lines.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2894437" id="ftn.id2894437">[41]</a></sup>
  Brooks's Law predicts that adding programmers to a
late project makes it later. More generally, it predicts that costs
and error rates rise as the square of the number of programmers on a
project.
</p>

<p><sup><a href="#id2894501" id="ftn.id2894501">[42]</a></sup>
  In Hatton's
model, small differences in the maximum chunk size a programmer can
hold in short-term memory have a large multiplicative effect on the
programmer's efficiency.  This might be a major contributor to the
order-of-magnitude (or larger) variations in effectiveness observed by
Fred Brooks and others.
</p>
</div>


<!-- FILE: ch04s02.html -->
<h3 id="ch04s02"><a href="#ch04s02">§</a>Compactness and Orthogonality</h3>
<p>
  Code is not the only sort of thing with an optimal chunk size.
Languages and APIs (such as sets of library or system calls) run up
against the same sorts of human cognitive constraints that produce
Hatton's U-curve.
</p>
<p>
  Accordingly, Unix programmers have learned to think very hard
about two other properties when designing APIs, command sets,
protocols, and other ways to make computers do tricks:
  <em>compactness</em> and
  <em>orthogonality</em>.
</p>
<h4 id="compactness"><a href="#compactness">§</a>Compactness</h4>
<p>
  Compactness
  is the property that a design can fit inside a human being's head.  A
good practical test for compactness is this: Does an experienced user
normally need a manual?  If not, then the design (or at least the
subset of it that covers normal use) is compact.
</p>
<p>
  Compact software tools have all the virtues of physical tools
that fit well in the hand.  They feel pleasant to use, they don't obtrude
themselves between your mind and your work, they make you more
productive — and they are much less likely than unwieldy tools
to turn in your hand and injure you.
</p>
<p>
  Compact is not equivalent to ‘weak’.  A design can
have a great deal of power and flexibility and still be compact if it
is built on abstractions that are easy to think about and fit together
well.  Nor is compact equivalent to ‘easily learned’; some
compact designs are quite difficult to understand until you have
mastered an underlying conceptual model that is tricky, at which point
your view of the world changes and compact
  <em>becomes</em>
  simple.  For a lot of people, the Lisp
language is a classic example of this.
</p>
 <blockquote>
  <p>
   Nor does compact mean ‘small’.  If a well-designed 
system is predictable and ‘obvious’ to the experienced
user, it might have quite a few pieces.
  </p>
  <span>
   – Ken Arnold
  </span>
 </blockquote>
<p>
  Very few software designs are compact in an absolute sense, but
many are compact in a slightly looser sense of the term.  They have a
compact working set, a subset of capabilities that suffices for 80% or
more of what expert users normally do with them.  Practically
speaking, such designs normally need a reference card or cheat sheet
but not a manual.  We'll call such designs
  <em>semi-compact</em>, as opposed to
  <em>strictly compact</em>.
</p>
<p>
  The concept is perhaps best illustrated by examples.  The Unix
system call API is semi-compact, but the standard
C
  library is not
compact in any sense.  While Unix programmers easily keep a subset of
the system calls sufficient for most applications programming (file
system operations, signals, and process control) in their heads, the C
library on modern Unixes includes many hundreds of entry points,
e.g., mathematical functions, that won't all fit inside a single
programmer's cranium.
</p>
<p>
  <em>The Magical Number Seven, Plus or Minus Two: Some Limits on Our Capacity for Processing Information</em><sup><a href="#Miller" title="[Miller]">[Miller]</a></sup> is one of the foundation papers in cognitive
psychology (and, incidentally, the specific reason that U.S.
local telephone numbers have seven digits).  It showed that the number
of discrete items of information human beings can hold in
short-term memory is seven, plus or minus two. This gives us a good
rule of thumb for evaluating the compactness of APIs: Does a
programmer have to remember more than seven entry points?  Anything
larger than this is unlikely to be strictly compact.
</p>
<p>
  Among Unix tools, make(1) is compact; autoconf(1) and automake(1) are not.  Among markup languages, HTML is
  semi-compact, but DocBook (a documentation markup language we shall discuss in
  <a href="#documentationchapter" title="Chapter 18. Documentation">Chapter 18</a>) is not.  The
man(7) macros are compact, but troff(1) markup is not.
</p>
<p>
  Among general-purpose programming languages, C and Python are semi-compact; Perl, Java, Emacs Lisp, and shell are not
  (especially since serious shell programming requires you to know half-a-dozen other tools like sed(1) and awk(1)). C++
  is anti-compact — the language's designer has admitted that he doesn't expect any one programmer to ever understand it
  all.
</p>
<p>
  Some designs that are not compact have enough internal
redundancy of features that individual programmers end up carving out
compact dialects sufficient for that 80% of common tasks by choosing a
working subset of the language.  Perl has this kind of
pseudo-compactness, for example.  Such designs have a built-in trap;
when two programmers try to communicate about a project, they may find
that differences in their working subsets are a significant barrier to
understanding and modifying the code.
</p>
<p>
  Noncompact designs are not automatically doomed or bad,
however.  Some problem domains are simply too complex for a compact
design to span them.  Sometimes it's necessary to trade away
compactness for some other virtue, like raw power and range.  Troff
markup is a good example of this.  So is the
BSD
  sockets
API. The purpose of emphasizing compactness as a virtue is not to
condition you to treat compactness as an absolute requirement, but to
teach you to do what Unix programmers do: value compactness
properly, design for it whenever possible, and not throw it away
casually.
</p>
<h4 id="orthogonality"><a href="#orthogonality">§</a>Orthogonality</h4>
<p>
  Orthogonality
  is one of the most important properties that can help make even
complex designs
compact.  In a purely
orthogonal design, operations do not have side effects; each action
(whether it's an API call, a macro invocation, or a language
operation) changes just one thing without affecting others.  There is
one and only one way to change each property of whatever system you
are controlling.
</p>
<p>
  Your monitor has orthogonal controls.  You can change the
brightness independently of the contrast level, and (if the monitor
has one) the color balance control will be independent of both.
Imagine how much more difficult it would be to adjust a monitor on
which the brightness knob affected the color balance: you'd
have to compensate by tweaking the color balance every time after you
changed the brightness.  Worse, imagine if the contrast control also
affected the color balance; then, you'd have to adjust both knobs
simultaneously in exactly the right way to change either contrast or
color balance alone while holding the other constant.
</p>
<p>
  Far too many software designs are non-orthogonal.  One common
class of design mistake, for example, occurs in code that reads and
parses data from one (source) format to another (target) format.  A
designer who thinks of the source format as always being stored in a
disk file may write the conversion function to open and read from a
named file.  Usually the input could just as well have been any file
handle.  If the conversion routine were designed orthogonally,
e.g., without the side effect of opening a file, it could save work
later when the conversion has to be done on a data stream supplied
from standard input, a network socket, or any other source.
</p>
<p>
  Doug McIlroy's
  advice to “Do one thing well”
is usually interpreted as being about simplicity.  But it's also,
implicitly and at least as importantly, about orthogonality.
</p>
<p>
  It's not a problem for a program to do one thing well and
other things as side effects, provided supporting those other things
doesn't raise the complexity of the program and its vulnerability
to bugs.  In
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>
  we'll
examine a program called
  <em>ascii</em> that prints
synonyms for the names of ASCII characters, including hex, octal, and
binary values; as a side effect, it can serve as a quick base
converter for numbers in the range 0–255.  This second use is not an
orthogonality violation because the features that support it are all
necessary to the primary function; they do not make the program
more difficult to document or maintain.
</p>
<p>
  The problems with non-orthogonality arise when side effects
complicate a programmer's or user's mental model, and beg to be
forgotten, with results ranging from inconvenient to dire.  Even when
you do not forget the side effects, you're often forced to do extra
work to suppress them or work around them.
</p>
<p>
  There is an excellent discussion of orthogonality and how to
achieve it in
  <em>The Pragmatic Programmer</em> <sup><a href="#Hunt-Thomas" title="[Hunt-Thomas]">[Hunt-Thomas]</a></sup>.  As they point out, orthogonality reduces
test and development time, because it's easier to verify code that
neither causes side effects nor depends on side effects from other
code — there are fewer combinations to test. If it breaks,
orthogonal code is more easily replaced without disturbance to the
rest of the system.  Finally, orthogonal code is easier to document
and reuse.
</p>
<p>
  The concept of
  <em>refactoring</em>, which first
emerged as an explicit idea from the ‘Extreme Programming’
school, is closely related to orthogonality.  To refactor code is to
change its structure and organization without changing its observable
behavior.  Software engineers have been doing this since the birth of
the field, of course, but naming the practice and identifying a stock
set of refactoring techniques has helped concentrate peoples'
thinking in useful ways.  Because these fit so well with the central
concerns of the Unix design tradition, Unix developers have quickly
coopted the terminology and ideas of refactoring.<sup><a href="#ftn.id2895110" id="id2895110">[43]</a></sup>
</p>
<p>
  The basic Unix APIs were designed for orthogonality with
imperfect but considerable success.  We take for granted being able to
open a file for write access without exclusive-locking it for write,
for example; not all operating systems are so graceful.  Old-style
(System III)
signals were non-orthogonal, because signal receipt had the
side-effect of resetting the signal handler to the default
die-on-receipt.  There are large non-orthogonal patches like the BSD
sockets
  API and
  <em>very</em>
  large ones like the X windowing system's
drawing libraries.
</p>
<p>
  But on the whole the Unix API is a good example:
Otherwise it not only would not but
  <em>could</em>
  not
be so widely imitated by C
  libraries on other operating systems.  This is also a reason that the
Unix API repays study even if you are not a Unix programmer; it has
lessons about orthogonality to teach.
</p>
<h4 id="spot_rule"><a href="#spot_rule">§</a>The SPOT Rule</h4>
<p>
  <em>The Pragmatic Programmer</em> articulates a
rule for one particular kind of orthogonality that is especially
important.  Their “Don't Repeat Yourself” rule is: every
piece of knowledge must have a
  <em>single</em>,
unambiguous, authoritative representation within a system.  In this
book we prefer, following a suggestion by Brian Kernighan, to call
this the Single Point Of Truth or SPOT rule.
</p>
<p>
  Repetition leads to inconsistency and code that is subtly
broken, because you changed only some repetitions when you needed to
change
  <em>all</em>
  of them.  Often, it also means
that you haven't properly thought through the organization 
of your code.
</p>
<p>
  Constants, tables, and metadata should be declared and
initialized
  <em>once</em>
  and imported elsewhere.  Any
time you see duplicate code, that's a danger sign.  Complexity
is a cost; don't pay it twice.
</p>
<p>
  Often it's possible to remove code duplication by
  <em>refactoring</em>; that is, changing the organization
of your code without changing the core algorithms.  Data duplication
sometimes appears to be forced on you.  But when you see it, here are
some valuable questions to ask:
</p>
 <div>
  <ul>
   <li>
    <p>
     If you have duplicated data in your code because it has to
have two different representations in two different places, can you
write a function, tool or code generator to make one representation from the
other, or both from a common source?
    </p>
   </li>
   <li>
    <p>
     If your documentation duplicates knowledge in your code, can you
generate parts of the documentation from parts of the code, or
vice-versa, or both from a common higher-level representation?
    </p>
   </li>
   <li>
    <p>
     If your header files and interface declarations duplicate
knowledge in your implementation code, is there a way you can generate
the header files and interface declarations from the code?
    </p>
   </li>
  </ul>
 </div>
<p>
  There is an analog of the SPOT rule for data structures:
“No junk, no confusion”.  “No junk” says
that the data structure (the model) should be minimal, e.g., not made
so general that it can represent situations which cannot exist.
“No confusion” says that states which must be kept
distinct in the real-world problem must be kept distinct in the model.
In short, the SPOT rule advocates seeking a data structure whose
states have a one-to-one correspondence with the states of the
real-world system to be modeled.
</p>
<p>
  From deeper within the Unix tradition, we can add some of our
own corollaries of the SPOT rule:
</p>
 <div>
  <ul>
   <li>
    <p>
	 Are you duplicating data because you're caching intermediate results of some computation or lookup?  Consider
	 carefully whether this is premature optimization; stale caches (and the layers of code needed to keep caches
	 synchronized) are a fertile source of bugs,<sup><a href="#ftn.id2895368" id="id2895368">[44]</a></sup> and can even
	 slow down overall performance if (as often happens) the cache-management overhead is higher than you expected.
    </p>
   </li>
   <li>
    <p>
     If you see lots of duplicative boilerplate code, can you
generate all of it from a single higher-level representation,
twiddling a few knobs to generate the different cases?
    </p>
   </li>
  </ul>
 </div>
<p>
  The reader should begin to see a pattern emerging here.
</p>
<p>
  In the Unix world, the SPOT Rule as a unifying idea has seldom
been explicit — but heavy use of code generators to implement
particular
  <em>kinds</em>
  of SPOT are very much part of the
tradition.  We'll survey these techniques in
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>.
</p>
<h4 id="id2895445"><a href="#id2895445">§</a>Compactness and the Strong Single Center</h4>
<p>
  One subtle but powerful way to promote compactness in a
design is to organize it around a strong core algorithm addressing a
clear formal definition of the problem, avoiding heuristics and
fudging.
</p>
 <blockquote>
  <p>
   Formalization often clarifies a task spectacularly.  It is not
enough for a programmer to recognize that bits of his task fall within
standard computer-science categories — a little depth-first
search here and a quicksort there.  The best results occur when the
nub of the task can be formalized, and a clear model of the job at
hand can be constructed.  It is not necessary that ultimate users
comprehend the model.  The very existence of a unifying core will
provide a comfortable feel, unencumbered with the
why-in-hell-did-they-do-that moments that are so prevalent in using
Swiss-army-knife programs.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  This is an often-overlooked strength of the Unix
tradition.  Many of its most effective tools are thin wrappers around
a direct translation of some single powerful algorithm.
</p>
<p>
  Perhaps the clearest example of this is
diff(1),
the Unix tool for reporting differences between related files.  This
tool and its dual,
patch(1),
have become central to the network-distributed development style of
modern Unix.  A valuable property of diff is that it seldom surprises
anyone.  It doesn't have special cases or painful edge conditions,
because it uses a simple, mathematically sound method of sequence
comparison.  This has consequences:
</p>
 <blockquote>
  <p>
   By virtue of a mathematical model and a solid
algorithm, Unix diff contrasts markedly with its
imitators.  First, the central engine is solid, small, and
has never needed one line of maintenance.  Second, the
results are clear and consistent, unmarred by surprises
where heuristics fail.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  Thus, people who use diff can develop an intuitive feel for what
it will do in any given situation without necessarily understanding
the central algorithm perfectly.  Other well-known examples of
this special kind of clarity achieved through a strong central
algorithm abound in Unix:
</p>
 <div>
  <ul>
   <li>
    <p>
     The
grep(1)
utility for selecting lines out of files by pattern matching is a
simple wrapper around a formal algebra of regular-expression patterns
(see
     <a href="#regexps" title="Case Study: Regular Expressions">
      the section called “Case Study: Regular Expressions”</a>
     for discussion).  If it had
lacked this consistent mathematical model, it would probably look like
the design of the original
glob(1)
facility in the oldest Unixes, a handful of ad-hoc wildcards that
can't be combined.
    </p>
   </li>
   <li>
    <p>
     The yacc(1) utility for
generating language parsers is a thin wrapper around the formal theory
of LR(1) grammars. Its partner, the lexical analyzer generator
lex(1),
is a similarly thin wrapper around the theory of nondeterministic
finite-state automata.
    </p>
   </li>
  </ul>
 </div>
<p>
  All three of these programs are so bug-free that their correct
functioning is taken utterly for granted, and compact enough to fit
easily in a programmer's hand. Only a part of these good qualities are due
to the polishing that comes with a long service life and frequent use;
most of it is that, having been constructed around a strong and
provably correct algorithmic core, they never needed much polishing
in the first place.
</p>
<p>
  The opposite of a formal approach is using
  <em>heuristics</em> —rules of thumb leading
toward a solution that is probabilistically, but not certainly,
correct.  Sometimes we use heuristics because a deterministically
correct solution is impossible. Think of spam filtering, for example;
an algorithmically perfect spam filter would need a full solution to
the problem of understanding natural language as a module.  Other
times, we use heuristics because known formally correct methods are
impossibly expensive.  Virtual-memory management is an example of
this; there are near-perfect solutions, but they require so much
runtime instrumentation that their overhead would swamp any
theoretical gain over heuristics.
</p>
<p>
  The trouble with heuristics is that they proliferate special
cases and edge cases.  If nothing else, you usually have to backstop 
a heuristic with some sort of recovery mechanism when it fails.  All
the usual problems with escalating complexity follow.  To manage the
resulting tradeoffs, you have to start by being aware of them.  Always
ask if a heuristic actually pays off in performance what it costs 
in code complexity — and don't guess at the performance
difference, actually measure it before making a decision.
</p>
<h4 id="id2899405"><a href="#id2899405">§</a>The Value of Detachment</h4>
<p>
  We began this book with a reference to Zen: “a special
transmission, outside the scriptures”.  This was not mere
exoticism for stylistic effect; the core concepts of Unix have always
had a spare, Zen-like simplicity that continues to shine through the
layers of historical accidents that have accreted around
them.  This
quality is reflected in the cornerstone documents of Unix, like
  <em>The C Programming Language</em> <sup><a href="#Kernighan-Ritchie" title="[Kernighan-Ritchie]">[Kernighan-Ritchie]</a></sup> and the 1974 CACM paper that introduced
Unix to the world; one of the famous quotes from that paper observes
“...constraint has encouraged not only economy, but also a
certain elegance of design”.  That simplicity came from trying
to think not about how much a language or operating system could do,
but of how
  <em>little</em>
  it could do — not by
carrying assumptions but by starting from zero (what in Zen is called
“beginner's mind” or “empty mind”).
</p>
<p>
  To design for
compactness
  and
orthogonality,
start from zero.  Zen teaches that attachment leads to suffering;
experience with software design teaches that attachment to unnoticed
assumptions leads to non-orthogonality, noncompact designs, and
projects that fail or become maintenance nightmares.
</p>
<p>
  To achieve enlightenment and surcease from suffering, Zen
teaches detachment.  The Unix tradition teaches the value of
detachment from the particular, accidental conditions under which a
design problem was posed.  Abstract.  Simplify.  Generalize.  Because
we write software to solve problems, we cannot completely detach from
the problems — but it is well worth the mental effort to see how
many preconceptions you can throw away, and whether the design becomes
more compact
  and
orthogonal as you do that.  Possibilities for code reuse often
result.
</p>
<p>
  Jokes about the relationship between Unix and Zen are a live
part of the Unix tradition as well.<sup><a href="#ftn.id2899522" id="id2899522">[45]</a></sup>
  This is not an accident.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2895110" id="ftn.id2895110">[43]</a></sup>
  In
the foundation text on this topic,
  <em>Refactoring</em> <sup><a href="#Fowler" title="[Fowler]">[Fowler]</a></sup>, the author comes very close to stating that
the principal goal of refactoring is to improve orthogonality. But
lacking the concept, he can only approximate this idea from several
different directions: eliminating code duplication and various other
“bad smells” many of which are some sort of orthogonality
violation.
</p>

<p><sup><a href="#id2895368" id="ftn.id2895368">[44]</a></sup>
  An archetypal example of bad caching is the <code>rehash</code> directive in csh(1); type <code>man 1 csh</code> for
  details.  See
  <a href="#binary_caches" title="Caching Operation Results">
   the section called “Caching Operation Results”</a> for another example.
</p>

<p><sup><a href="#id2899522" id="ftn.id2899522">[45]</a></sup>
  For a recent example
of Unix/Zen crossover, see
  <a href="unix_koans.html" title="Appendix D. Rootless Root">
   Appendix D</a>.
</p>
</div>


<!-- FILE: ch04s03.html -->
<h3 id="ch04s03"><a href="#ch04s03">§</a>Software Is a Many-Layered Thing</h3>
<p>
  Broadly speaking, there are two directions one can go in
designing a hierarchy of functions or objects.  Which direction you
choose, and when, has a profound effect on the layering of your code.
</p>
<h4 id="id2899552"><a href="#id2899552">§</a>Top-Down versus Bottom-Up</h4>
<p>
  One direction is bottom-up, from concrete to abstract —
working up from the specific operations in the problem domain that you
know you will need to perform.  For example, if one is designing
firmware for a disk drive, some of the bottom-level primitives might
be ‘seek head to physical block’, ‘read physical
block’, ‘write physical block’, ‘toggle drive
LED’, etc.
</p>
<p>
  The other direction is top-down, abstract to concrete — from the
highest-level specification describing the project as a whole, or the
application logic, downwards to individual operations.  Thus, if one is
designing software for a mass-storage controller that might drive
several different sorts of media, one might start with abstract
operations like ‘seek logical block’, ‘read logical
block’, ‘write logical block’, ‘toggle
activity indication’.  These would differ from the similarly named
hardware-level operations above in that they're intended to be 
generic across different kinds of physical devices.
</p>
<p>
  These two examples could be two ways of approaching design for
the same collection of hardware.  Your choice, in cases like this, is
one of these: either abstract the hardware (so the objects encapsulate the real
things out there and the program is merely a list of manipulations on
those things), or organize around some behavioral model (and
then embed the actual hardware manipulations that carry it out in the
flow of the behavioral logic).
</p>
<p>
  An analogous choice shows up in a lot of different contexts.
Suppose you're writing MIDI sequencer software.  You could organize
that code around its top level (sequencing tracks) or around its
bottom level (switching patches or samples and driving wave
generators).
</p>
<p>
  A very concrete way to think about this difference is to ask
whether the design is organized around its main event loop (which
tends to have the high-level application logic close to it) or around
a service library of all the operations that the main loop can invoke.  A
designer working from the top down will start by thinking about the
program's main event loop, and plug in specific events later.  A
designer working from the bottom up will start by thinking about
encapsulating specific tasks and glue them together into some kind of
coherent order later on.
</p>
<p>
  For a larger example, consider the design of a Web browser.  The
top-level design of a Web browser is a specification of the expected
behavior of the browser: what types of URL (like
  <code>http:</code> or
  <code>ftp:</code> or
  <code>file:</code>) it interprets, what kinds of images it is expected to be
able to render, whether and with what limitations it will accept
Java
  or
JavaScript, etc.  The layer of the implementation
that corresponds to this top-level view is its main event loop; each
time around, the loop waits for, collects, and dispatches on a user
action (such as clicking a Web link or typing a character into a
field).
</p>
<p>
  But the Web browser has to call a large set of domain
primitives to do its job.  One group of these is concerned with
establishing network connections, sending data over them, and
receiving responses.  Another set is the operations of the GUI 
toolkit the browser will use.  Yet a third set might be concerned
with the mechanics of parsing retrieved HTML from text into a 
document object tree.
</p>
<p>
  Which end of the stack you start with matters a lot, because the
layer at the other end is quite likely to be constrained by your
initial choices.  In particular, if you program purely from the top
down, you may find yourself in the uncomfortable position that the
domain primitives your application logic wants don't match the ones
you can actually implement.  On the other hand, if you program purely
from the bottom up, you may find yourself doing a lot of work that is
irrelevant to the application logic — or merely designing a pile
of bricks when you were trying to build a house.
</p>
<p>
  Ever since the structured-programming controversies of the
1960s, novice programmers have generally been taught that the correct
approach is the top-down one: stepwise refinement, where you specify
what your program is to do at an abstract level and gradually fill in
the blanks of implementation until you have concrete working code.
Top-down tends to be good practice when three preconditions are true:
(a) you can specify in advance precisely what the program is to do,
(b) the specification is unlikely to change significantly during
implementation, and (c) you have a lot of freedom in choosing, at
a low level, how the program is to get that job done.
</p>
<p>
  These conditions tend to be fulfilled most often in programs
relatively close to the user and high in the software stack —
applications programming.  But even there those preconditions often
fail.  You can't count on knowing what the ‘right’ way for
a word processor or a drawing program to behave is until the user
interface has had end-user testing.  Purely top-down programming often
has the effect of overinvesting effort in code that has to be scrapped
and rebuilt because the interface doesn't pass a reality check.
</p>
<p>
  In self-defense against this, programmers try to do both things
— express the abstract specification as top-down application
logic,
  <em>and</em>
  capture a lot of low-level domain
primitives in functions or libraries, so they can be reused when the
high-level design changes.
</p>
<p>
  Unix programmers inherit a tradition that is centered in systems
programming, where the low-level primitives are hardware-level
operations that are fixed in character and extremely important.  They
therefore lean, by learned instinct, more toward bottom-up
programming.
</p>
<p>
  Whether you're a systems programmer or not, bottom-up can also
look more attractive when you are programming in an exploratory way,
trying to get a grasp on hardware or software or real-world phenomena
you don't yet completely understand.  Bottom-up programming gives you
time and room to refine a vague specification.  Bottom-up also appeals to
programmers' natural human laziness — when you have to scrap and
rebuild code, you tend to have to throw away larger pieces if you're
working top-down than you do if you're working bottom-up.
</p>
<p>
  Real code, therefore tends to be programmed both top-down and
bottom-up.  Often, top-down and bottom-up code will be part of the
same project.  That's where ‘glue’ enters the
picture.
</p>
<h4 id="id2899777"><a href="#id2899777">§</a>Glue Layers</h4>
<p>
  When the top-down and bottom-up drives collide, the result
is often a mess.  The top layer of application logic and the bottom
layer of domain primitives have to be impedance-matched by a layer of
glue logic.
</p>
<p>
  One of the lessons Unix programmers have learned over decades is
that glue is nasty stuff and that it is vitally important to keep glue
layers as thin as possible.  Glue should stick things together, but
should not be used to hide cracks and unevenness in the layers.
</p>
<p>
  In the Web-browser example, the glue would include the rendering
code that maps a document object parsed from incoming HTML into a
flattened visual representation as a bitmap in a display buffer, using
GUI domain primitives to do the painting.  This rendering code is
notoriously the most bug-prone part of a browser.  It attracts into
itself kluges to address problems that originate both in the HTML
parsing (because there is a lot of ill-formed markup out there) and
the GUI toolkit (which may not have quite the primitives that are
really needed).
</p>
<p>
  A Web browser's glue layer has to mediate not merely between
specification and domain primitives, but between several different
external specifications: the network behavior standardized in
HTTP, HTML document structure, and various graphics and multimedia
formats as well as the users' behavioral expectations from the
GUI.
</p>
<p>
  And one single bug-prone glue layer is not the worst fate that can
befall a design.  A designer who is aware that the glue layer exists,
and tries to organize it into a middle layer around its own set of
data structures or objects, can end up with
  <em>two</em>
  layers of glue — one above the midlayer and one below.
Programmers who are bright but unseasoned are particularly apt to fall
into this trap; they'll get each fundamental set of classes
(application logic, midlayer, and domain primitives) right and make
them look like the textbook examples, only to flounder as the multiple
layers of glue needed to integrate all that pretty code get thicker
and thicker.
</p>
<p>
  The thin-glue principle can be viewed as a refinement of the
Rule of Separation.  Policy (the application logic) should be cleanly
separated from mechanism (the domain primitives), but if there is a
lot of code that is neither policy nor mechanism, chances are that it
is accomplishing very little besides adding global complexity to the
system.
</p>
<h4 id="c_thin_glue"><a href="#c_thin_glue">§</a>Case Study: C Considered as Thin Glue</h4>
<p>
  The C language itself is a good example of the effectiveness 
of thin glue.
</p>
<p>
  In the late 1990s, Gerrit Blaauw and Fred Brooks observed in
  <em>Computer Architecture: Concepts and Evolution</em> <sup><a href="#BlaauwBrooks" title="[BlaauwBrooks]">[BlaauwBrooks]</a></sup> that the
architectures in every generation of computers, from early mainframes
through minicomputers through workstations through PCs, had tended to
converge.  The later a design was in its technology generation, the
more closely it approximated what Blaauw &amp; Brooks called the
“classical architecture”: binary representation, flat
address space, a distinction between memory and working store
(registers), general-purpose registers, address resolution to
fixed-length bytes, two-address instructions,
big-endianness,<sup><a href="#ftn.id2899932" id="id2899932">[46]</a></sup>
  and data types
a consistent set with sizes a multiple of either 4 or 6 bits (the
6-bit families are now extinct).
</p>
<p>
  Thompson
  and Ritchie
  designed C to be a sort of structured assembler for an idealized
processor and memory architecture that they expected could be
efficiently modeled on most conventional computers.  By happy
accident, their model for the idealized processor was the
PDP-11, a
particularly mature and elegant minicomputer design that closely
approximated Blaauw &amp; Brooks's classical architecture.  By good
judgment, Thompson and Ritchie declined to wire into their language
most of the few traits (such as little-endian byte order) where the
PDP-11 didn't match it.<sup><a href="#ftn.id2900000" id="id2900000">[47]</a></sup>
</p>
<p>
  The PDP-11 became an important model for the following
generations of microprocessor architectures.  The basic abstractions
of C turned out to capture the classical architecture rather neatly.
Thus, C started out as a good fit for microprocessors and, rather than
becoming irrelevant as its assumptions fell out of date, actually
became a
  <em>better</em>
  fit as hardware converged more
closely on the classical architecture. One notable example of this
convergence was when Intel's 386, with its large flat memory-address
space, replaced the 286's awkward segmented-memory addressing after
1985; pure C was actually a better fit for the 386 than it had been
for the 286.
</p>
<p>
  It is not a coincidence that the experimental era in computer
architectures ended in the mid-1980s at the same time that C (and its
close descendant C++) were sweeping all before them as
general-purpose programming languages.  C, designed as a thin but
flexible layer over the classical architecture, looks with two
decades' additional perspective like almost the best possible design
for the structured-assembler niche it was intended to fill.  In
addition to
compactness,
orthogonality,
and detachment (from the machine architecture on which it was
originally designed), it also has the important quality of
transparency
  that we will discuss in
  <a href="#transparencychapter" title="Chapter 6. Transparency">
   Chapter 6</a>. The few language designs since that
are arguably better have needed to make large changes (like
introducing garbage collection) in order to get enough functional
distance from C not to be swamped by it.
</p>
<p>
  This history is worth recalling and understanding because C
shows us how powerful a clean, minimalist design can be.  If
Thompson
  and
Ritchie
  had
been less wise, they would have designed a language that did much
more, relied on stronger assumptions, never ported satisfactorily off
its original hardware platform, and withered away as the world changed
out from under it.  Instead, C has flourished — and the example
Thompson and Ritchie set has influenced the style of Unix development
ever since.  As the writer, adventurer, artist, and aeronautical
engineer Antoine de Saint-Exupéry once put
it, writing about the
design of airplanes:
  <span class="foreignphrase" lang="fr">
   <em>«La perfection est atteinte non quand il ne reste rien à ajouter, mais quand il ne reste rien à enlever».</em>
  </span>
  (“Perfection is
attained not when there is nothing more to add, but when there is
nothing more to remove”.)
</p>
<p>
  Ritchie and Thompson lived by this maxim.  Long after the
resource constraints on early Unix software had eased, they worked at
keeping C as thin a layer over the hardware as possible.
</p>
 <blockquote>
  <p>
   Dennis used to say to me, when I would ask for some
particularly extravagant feature in C, “If you want PL/1, you know
where to get it”.  He didn't have to deal with some marketer saying
“But we need a check in the box on the sales viewgraph!”
  </p>
  <span>
   – Mike Lesk
  </span>
 </blockquote>
<p>
  The history of C is also a lesson in the value of having a
working reference implementation
  <em>before</em>
  you
standardize.  We'll return to this point in
  <a href="#portabilitychapter" title="Chapter 17. Portability">
   Chapter 17</a>
  when we discuss the evolution of C and
Unix standards.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2899932" id="ftn.id2899932">[46]</a></sup>
  The terms
  <em>big-endian</em> and
  <em>little-endian</em> refer to architectural choices about
the order in which bits are interpreted within a machine word.  Though
it has no canonical location, a Web search for
  <em>On Holy Wars and a Plea for Peace</em>
  should turn up a classic and
entertaining paper on this subject.
</p>

<p><sup><a href="#id2900000" id="ftn.id2900000">[47]</a></sup>
  The widespread belief that the
autoincrement and autodecrement features entered C because they
represented PDP-11 machine instructions is a myth.  According to
Dennis Ritchie, these operations were present in the ancestral B
language before the PDP-11 existed.
</p>
</div>


<!-- FILE: ch04s04.html -->
<h3 id="ch04s04"><a href="#ch04s04">§</a>Libraries</h3>
<p>
  One consequence of the emphasis that the Unix programming style
put on modularity and well-defined APIs is a strong tendency to
factor programs into bits of glue connecting collections of
libraries, especially shared libraries (the equivalents of what are
called dynamically-linked libraries or DLLs under Windows and
other operating systems).
</p>
<p>
  If you are careful and clever about design, it is often possible
to partition a program so that it consists of a
user-interface-handling main section (policy) and a collection of
service routines (mechanism) with effectively no glue at all.  This
approach is especially appropriate when the program has to do a lot of
very specific manipulations of data structures like graphic images,
network-protocol packets, or control blocks for a hardware interface.
Some good general architectural advice from within the Unix tradition,
particularly applicable to the resource-management challenges of this
sort of library is collected in
  <em>The Discipline and Method Architecture for Reusable Libraries</em><sup><a href="#Vo" title="[Vo]">[Vo]</a></sup>.
</p>
<p>
  Under Unix, it is normal practice to make this layering
explicit, with the service routines collected in a library that is
separately documented.  In such programs, the front end gets to
specialize in user-interface considerations and high-level protocol.
With a little more care in design, it may be possible to detach the
original front end and replace it with others adapted for different
purposes.  Some other advantages should become evident from our case
study.
</p>
<p>
  There is a flip side to this. In the Unix world, libraries which
are delivered
  <em>as libraries</em>
  should come with
exerciser programs.
</p>
 <blockquote>
  <p>
   APIs should come with programs, and vice versa.  An API that you
must write C code to use, which cannot be invoked easily from the
command line, is harder to learn and use.  And contrariwise, it's a
royal pain to have interfaces whose
   <em>only</em>
   open,
documented form is a program, so you cannot invoke them easily from a
C program — for example,
route(1)
in older Linuxes.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  Besides easing the learning curve, library exercisers often make
excellent test frameworks.  Experienced Unix programmers therefore see
them not just as a form of thoughtfulness to the library's users but
as an indication that the code has probably been well tested.
</p>
<p>
  An important form of library layering is the
  <em>plugin</em>, a library with a set of known entry
points that is dynamically loaded after startup time to perform a
specialized task.  For plugins to work, the calling program has to be
organized largely as a documented service library that the plugin can
call back into.
</p>
<h4 id="gimp_plugins"><a href="#gimp_plugins">§</a>Case Study: GIMP Plugins</h4>
<p>
  The GIMP (GNU Image Manipulation
program)
  is a graphics
editor designed to be driven through an interactive GUI.  But GIMP is
built as a library of image-manipulation and housekeeping routines
called by a relatively thin layer of control code.  The driver code
knows about the GUI, but not directly about image formats; the library
routines reverse this by knowing about image formats and operations
but not about the GUI.
</p>
<p>
  The library layer is documented (and, in fact shipped as
“libgimp” for use by other programs).  This means that C
programs called “plugins” can be dynamically loaded by
GIMP and call the library to do image manipulation, effectively taking
over control at the same level as the GUI (see Figure 4.2).
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 4.2. Caller/callee relationships in GIMP with a plugin loaded.
   </b>
  </p>
  <div class="center">
   <img alt="Caller/callee relationships in GIMP with a plugin loaded." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAV8AAACDCAAAAAAPVUe9AAAAAnRSTlMA/1uRIrUAAAACYktHRAD/h4/MvwAAAAlwSFlzAAAAZAAAAGQAD5bF3QAABcpJREFUeNrtnbGu2zYUhg+Qi6YZelECRZPhtgg8JFl6Fz9AUUBDgKKjAI8ZCm0ZW00dMgQQvGStpi6dtNwH4NAX0CvoFfgKLElJtmRJvpatIx7rnh+xYkgRxfOF5k9TPDJstZHkDc5mC5qFKeaLK+aLK+aLK5C+a7BoSW6/uGK+uGK+uGK+uGJ/QxX7G7KYL66YL66YL67Y31DF/oYs5osr5osr5osr9jdUsb8hi/niivniivniiv0NVUT9rYhHq/Bd537R5CtHf6rGnzGPmC+umC+uaPrbYvgS9bfF8OX+AVnMF1fMF1fX4W/56DOI6Dr8Le/WUhw/g4yugu8JtWS+Y7SjVfTUUtmdSu0Ots8gJtp8U4iESF0tFZT9RLwWAuLUvMsgFRAdnEFNxP0NlE5WZSsoXykUOlvv9ux6ZqJ8afqb2j5U7yqMe74SYq2C5p4qEJp86fUP+Z/Bu+df/dGonmjRzAAC1cP351j5rnqfKPFV2eb1y28B4Lt/G/1DFlYkc/dpqzB2268MKRKmxDd/DlY3vzX63xUEheGaFDoGIVcyX8E6CDO7R0JaJLV/2DMoEiblb/cW7zcfm/7WOOqGY7lUUmaic2p5BjnCtPzt0zOA2y96gK+TyEw/kqTdQOp2TIwwIb4GzRu4+8+9rWgZM4vb/yhdAYQ90xH78QMtwmT4OiwPr8rvZJfNn1EiTITvAZJL5yfpECbhbx0cl8//EiFMwd96UEwxv06DsHe+vRimuX9BgbBnvgMIpro/5J/wIN98/BKwQQ3d3hkMf7r7b8OE5wjwiL9NOCE1UNSRxjXl/c2hy+AHqI/5G/blj350ZTS2BUVHqtt/qVn4ak98H+kY1cS9Zt/lFszXg+10L7lYvp5M/fCyM/Gd2988DpnKS38+e47jtADbR2Zuv54HpPbydwdzdNMGeKhZ+fof7mv5ExzOMU8YYFcz8iVA1+jO3iO5/bA4vjTo2hl7qxe/LsvfiNC1lflwf/fKEH77sBx/25KhW6r4Z/PjzYu/pwvQc//wOym6laJP0wVIoP8lp4X5Gzktyt8IapHf3wiJ+wdcEec74nkA18K3vsuTXV7UTmfxzSMBEIZalcsXE8gDOLKQ4kr45tVi46zFRJxT1F7n+FthFzjrItT1f0+VHnHG5T2qWys4+PuConZHzmm/UfkBkrrBVy+Er1KNUGymkktU2n8/Kk4rqlXmWChCHZy+HL6pCyUGuwzWZSq9B9sIkwCCWEC8S2g6OcBz+LpzZAjp8viWL6XjVZ2pVO0sqmSlKqFpHKuRUKBoVWd5fJ2dVJlK0D7QG+rE/raOW9Vx+VIL41uOI2ymUg9f8XhRuyPntN8Y3NOw7KmhtTq3PAiOrBa5Pr5ZVGcqHfItE5pODvCs8W9qhrsiSLQdqgGsM7uYq7OS/7Si/Km7KsPlJCWFDs3gXukyU+kvtxOkacwqg7xKaDo9QP5+PKT+TCUYWRTzHVJ/ptJovjw/OaDeTKWstxvk+UlvATJf3KKYL25RT41v/nrTyAjHD/Cp+ZsZy8LLd5Yx33/DkCzXRxnGvzzMEeAsfDcTpupcqE2J9+b2+ze8vgRBpv1+/cP9x5z9DUe5YztfgE/N32YO8Mn529wBMl/copgvblHMF7co9jfUotjfkItivrhFMV/corw+v8SrPD+/hDWFKDyfa9Fivrhivrhivrhif0MV+xuymC+umC+umC+ursLfiP529Ami7291rqjNEDUvh1oJyG3yKMAqvrR8ZFHnu88VtRmiINzvZSUBlHU3jH1X8BFRr187VxRi14BXEuq6U68/9fq1c0VB2QaclllpdpOckn7tU9T9rZ0rCjoGpddFxVe43CXKIu9v7VxR0+OKWEZ6137Ji3od27mi5k8kbP4Z851IjVxR0zOYYVnhfnKT+U6lOlfUZoi+t9lRhreMIXM7fFfucVH3tysXeX+7djFfXDFfXDFfXMHWbiVvcDbb/wGvRPR+FfUi/wAAADx0RVh0Y29tbWVudAAgSW1hZ2UgZ2VuZXJhdGVkIGJ5IEdOVSBHaG9zdHNjcmlwdCAoZGV2aWNlPXBubXJhdykK+osW8wAAAABJRU5ErkJggg=="/>
  </div>
 </div>
<p>
  Plugins are used to perform lots of special-purpose
transformations such as colormap hacking, blurring and despeckling;
also for reading and writing file formats not native to the GIMP core;
for extensions like editing animations and window manager themes; and
for lots of other sorts of image-hacking that can be automated by
scripting the image-hacking logic in the GIMP core.  A registry of
GIMP plugins is available on the World Wide Web.
</p>
<p>
  Though most GIMP plugins are small, simple C programs, it is also possible to write a plugin that exposes the library
  API to a scripting language; we'll discuss this possibility in <a href="#interfacechapter" title="Chapter 11.
  Interfaces"> Chapter 11</a> when we examine the ‘polyvalent program’ pattern.
</p>



<!-- FILE: unix_and_oo.html -->
<h3 id="unix_and_oo"><a href="#unix_and_oo">§</a>Unix and Object-Oriented Languages</h3>
<p>
  Since the mid-1980s most new language designs have included
native support for
  <em>object-oriented programming</em> (OO).  Recall that in object-oriented programming, the functions that
act on a particular data structure are encapsulated with the data in
an object that can be treated as a unit.  By contrast, modules in
non-OO languages make the association between data and the functions
that act on it rather accidental, and modules frequently leak data or
bits of their internals into each other.
</p>
<p>
  The OO design concept initially proved valuable in the design of
graphics systems, graphical user interfaces, and certain kinds of
simulation. To the surprise and gradual disillusionment of many, it
has proven difficult to demonstrate significant benefits of OO outside
those areas.  It's worth trying to understand why.
</p>
<p>
  There is some tension and conflict between the Unix tradition of
modularity and the usage patterns that have developed around OO
languages.  Unix programmers have always tended to be a bit more
skeptical about OO than their counterparts elsewhere. Part of this is
because of the Rule of Diversity; OO has far too often been promoted
as the One True Solution to the software-complexity problem.  But
there is something else behind it as well, an issue which is worth
exploring as background before we evaluate specific OO
(object-oriented) languages in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>.  It will also help throw some
characteristics of the Unix style of non-OO programming into sharper
relief.
</p>
<p>
  We observed above that the Unix tradition of modularity is one
of thin glue, a minimalist approach with few layers of abstraction
between the hardware and the top-level objects of a program.  Part of
this is the influence of C.  It takes serious effort to simulate true
objects in C.  Because that's so, piling up abstraction layers is an
exhausting thing to do.  Thus, object hierarchies in C tend to be
relatively flat and
transparent. Even when Unix programmers use other
languages, they tend to want to carry over the
thin-glue/shallow-layering style that Unix models have taught
them.
</p>
<p>
  OO languages make abstraction easy — perhaps too easy.
They encourage architectures with thick glue and elaborate layers.
This can be good when the problem domain is truly complex and demands
a lot of abstraction, but it can backfire badly if coders end up doing
simple things in complex ways just because they can.
</p>
<p>
  All OO languages show some tendency to suck programmers into the
trap of excessive layering.  Object frameworks and object browsers are
not a substitute for good design or documentation, but they often get
treated as one.  Too many layers destroy
transparency
  : It becomes too difficult
to see down through them and mentally model what the code is actually
doing.  The Rules of Simplicity, Clarity, and Transparency get
violated wholesale, and the result is code full of obscure bugs and
continuing maintenance problems.
</p>
<p>
  This tendency is probably exacerbated because a lot of
programming courses teach thick layering as a way to satisfy the Rule
of Representation.  In this view, having lots of classes is
equated with embedding knowledge in your data.  The problem with this
is that too often, the ‘smart data’ in the glue layers is
not actually about any natural entity in whatever the program is
manipulating — it's just about being glue. (One sure sign of
this is a proliferation of abstract subclasses or
‘mixins’.)
</p>
<p>
  Another side effect of OO abstraction is that opportunities for
optimization
  tend to disappear.  For example,
  <em>a</em>
  +
  <em>a</em>
  +
  <em>a</em>
  +
  <em>a</em>
  can become
  <em>a</em>
  * 4 and even
  <em>a</em>
  &lt;&lt; 2 if a is an integer.  But if one creates a class with
operators, there is nothing to indicate if they are commutative,
distributive, or associative.  Since one isn't supposed to look inside
the object, it's not possible to know which of two equivalent
expressions is more efficient.  This isn't in itself a good reason to
avoid using OO techniques on new projects; that would be premature
optimization.
But it is reason to think twice before transforming non-OO code into a
class hierarchy.
</p>
<p>
  Unix programmers tend to share an instinctive sense of these
problems. This tendency appears to be one of the reasons that, under
Unix, OO languages have failed to displace non-OO workhorses like
C,
Perl
  (which
actually has OO facilities, but they're not heavily used), and
shell.
There is more vocal criticism of OO in the Unix world than orthodoxy
permits elsewhere; Unix programmers know when
  <em>not</em>
  to use OO; and when they do use OO languages, they spend more
effort on trying to keep their object designs uncluttered.  As the
author of
  <em>The Elements of Networking Style</em> once
observed in a slightly different context <sup><a href="#Padlipsky" title="[Padlipsky]">[Padlipsky]</a></sup>:
“If you know what you're doing, three layers is enough; if you
don't, even seventeen levels won't help”.
</p>
<p>
  One reason that OO has succeeded most where it has (GUIs,
simulation, graphics) may be because it's relatively difficult to get
the ontology of types wrong in those domains.  In GUIs and graphics, for
example, there is generally a rather natural mapping between
manipulable visual objects and classes.  If you find yourself
proliferating classes that have no obvious mapping to what goes
on in the display, it is correspondingly easy to notice that the glue
has gotten too thick.
</p>
<p>
  One of the central challenges of design in the Unix style is how
to combine the virtue of detachment (simplifying and generalizing
problems from their original context) with the virtue of thin glue and
shallow, flat, transparent hierarchies of code and
design.
</p>
<p>
  We'll return to some of these points and apply them when we
discuss object-oriented languages in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>.
</p>



<!-- FILE: ch04s06.html -->
<h3 id="ch04s06"><a href="#ch04s06">§</a>Coding for Modularity</h3>
<p>
  Modularity is expressed in good code, but it primarily comes
from good design.  Here are some questions to ask about any code you 
work on that might help you improve its modularity:
</p>
 <div>
  <ul>
   <li>
    <p>
     How many global variables does it have?  Global variables are
modularity poison, an easy way for components to leak information to
each other in careless and promiscuous ways.<sup><a href="#ftn.id2900865" id="id2900865">[48]</a></sup>
    </p>
   </li>
   <li>
    <p>
     Is the size of your individual modules in Hatton's sweet spot?  If your
answer is “No, many are larger”, you may have a long-term
maintenance problem.  Do you know what your own sweet spot is?  Do
you know what it is for other programmers you are cooperating with?
If not, best be conservative and stick to sizes near the low end of
Hatton's range.
    </p>
   </li>
   <li>
    <p>
     Are the individual functions in your modules too large?  This
is not so much a matter of line count as it is of internal complexity.  If you
can't informally describe a function's contract with its callers in
one line, the function is probably too large.<sup><a href="#ftn.id2900903" id="id2900903">[49]</a></sup>
    </p>
    <blockquote>
     <p>
      Personally I tend to break up a subprogram when there are too many
local variables.  Another clue is [too many] levels of indentation.
I rarely look at length.
     </p>
     <span>
      – Ken Thompson
     </span>
    </blockquote>
   </li>
   <li>
    <p>
     Does your code have internal APIs — that is, collections
of function calls and data structures that you can describe to others
as units, each sealing off some layer of function from the rest of the
code?  A good API makes sense and is understandable without looking at
the implementation behind it.  The classic test is this: Try to
describe it to another programmer over the phone.  If you fail, it
is very probably too complex, and poorly designed.
    </p>
   </li>
   <li>
    <p>
     Do any of your APIs have more than seven entry points?  Do any
of your classes have more than seven methods each?  Do your data
structures have more than seven members?
    </p>
   </li>
   <li>
    <p>
     What is the distribution of the number of entry points per
module across the project?<sup><a href="#ftn.id2900990" id="id2900990">[50]</a></sup>
     Does it seem uneven?  Do the modules with lots of entry points really
need that many? Module complexity tends to rise as the square of the
number of entry points, too — yet another reason simple APIs are
better than complicated ones.
    </p>
   </li>
  </ul>
 </div>
<p>
  You might find it instructive to compare these with our
checklist of questions about
transparency,
and
discoverability
  in
  <a href="#transparencychapter" title="Chapter 6. Transparency">
   Chapter 6</a>.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2900865" id="ftn.id2900865">[48]</a></sup>
  Globals
also mean your code cannot be reentrant; that is, multiple instances in the
same process are likely to step on each
other.
</p>

<p><sup><a href="#id2900903" id="ftn.id2900903">[49]</a></sup>
  Many
years ago, I learned from Kernighan &amp; Plauger's
  <em>The Elements of Programming Style</em> a useful
rule.  Write that one-line comment immediately after the prototype of
your function.  For
  <span class="emphasis">
   <em>every</em>
  </span>
  function, without
exception.
</p>

<p><sup><a href="#id2900990" id="ftn.id2900990">[50]</a></sup>
  A cheap way to collect this
information is to analyze the tags files generated by a utility like
etags(1)
or
ctags(1).
</p>
</div>


<!-- FILE: textualitychapter.html -->
<h3 id="textualitychapter"><a href="#textualitychapter">§</a>Chapter 5. Textuality</h3>
 <blockquote class="epigraph">
  <p>
   It's a well-known fact that computing devices such as the abacus
were invented thousands of years ago. But it's not well known that the
first use of a common computer protocol occurred in the Old
Testament. This, of course, was when Moses aborted the Egyptians'
process with a control-sea.
  </p>
  <span>
   – Tom Galloway
rec.arts.comics, February 1992
  </span>
 </blockquote>
<p>
  In this chapter, we'll look at what the Unix tradition has to
tell us about two different kinds of design that are closely related:
the design of file formats for retaining application data in permanent
storage, and the design of application protocols for passing data
and commands between cooperating programs, possibly over a
network.
</p>
<p>
  What unifies these two kinds of design is that they both involve
the serialization of in-memory data structures.  For the internal
operation of computer programs, the most convenient representation of
a complex data structure is one in which all fields have the machine's
native data format (e.g. two's-complement binary for integers) and all
pointers are actual memory addresses (as opposed, say, to being named
references).  But these representations are not well suited to storage
and transmission; memory addresses in the data structure lose their
meaning outside memory, and emitting raw native data formats causes
interoperability problems passing data between machines with different
conventions (big- vs. little-endian, say, or 32-bit vs. 64-bit).
</p>
<p>
  For transmission and storage, the traversable, quasi-spatial
layout of data structures like linked lists needs to be flattened or
serialized into a byte-stream representation from which the structure
can later be recovered.  The serialization (save) operation is
sometimes called
  <em>marshaling</em> and its inverse
(load) operation
  <em>unmarshaling</em>.  These terms
are usually applied with respect to objects in an
OO
  language like C++
  or Python
  or Java, but could be used with equal justice
of operations like loading a graphics file into the internal storage
of a graphics editor and saving it out after modifications.
</p>
<p>
  A significant percentage of what C
  and C++
  programmers maintain is ad-hoc code for
marshaling and unmarshaling operations — even when the
serialized representation chosen is as simple as a binary structure
dump (a common technique under non-Unix environments).  Modern
languages like Python
  and Java
  tend to have built-in unmarshal and
marshal functions that can be applied to any object or byte-stream
representing an object, and that reduce this labor substantially.
</p>
<p>
  But these naïve methods are often unsatisfactory for
various reasons, including both the machine-interoperability problems
we mentioned above and the negative trait of being opaque to other
tools.  When the application is a network protocol, economy may demand
that an internal data structure (such as, say, a message with source
and destination addresses) be serialized not into a single blob of
data but into a series of attempted transactions or messages which the
receiving machine may reject (so that, for example, a large message can
be rejected if the destination address is invalid).
</p>
<p>
  Interoperability,
transparency,
extensibility,
and storage or transaction economy: these are the important themes in
designing file formats and application protocols.  Interoperability
and transparency demand that we focus such designs on clean data
representations, rather than putting convenience of implementation or
highest possible performance first.  Extensibility also favors textual
protocols, since binary ones are often harder to extend or subset
cleanly.  Transaction economy sometimes pushes in the opposite
direction — but we shall see that putting that criterion first
is a form of premature
optimization
  that it is often wise to resist.
</p>
<p>
  Finally, we must note a difference between data file formats and
the run-control files that are often used to set the startup options
of Unix programs.  The most basic difference is that (with sporadic
exceptions like GNU Emacs's configuration interface) programs don't
normally modify their own run-control files — the information
flow is one-way, from file read at startup time to application
settings.  Data-file formats, on the other hand, associate properties
with named resources and are both read and written by their
applications. Configuration files are generally hand-edited and small,
whereas data files are program-generated and can become arbitrarily
large.
</p>
<p>
  Historically, Unix has related but different sets of conventions for these two kinds of representation.  The
  conventions for run control files are surveyed in <a href="#configurationchapter" title="Chapter 10. Configuration">
  Chapter 10</a>; only conventions for data files are examined in this chapter.
</p>



<!-- FILE: ch05s01.html -->
<h3 id="ch05s01"><a href="#ch05s01">§</a>The Importance of Being Textual</h3>
<p>
  Pipes and sockets will pass binary data as well as text. But
there are good reasons the examples we'll see in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  are textual: reasons that hark back
to Doug McIlroy's
  advice quoted in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>. Text streams are a valuable universal
format because they're easy for human beings to read, write, and edit
without specialized tools.  These formats are (or can be designed to
be) transparent.
</p>
<p>
  Also, the very limitations of text streams help enforce
encapsulation. By discouraging elaborate representations with rich,
densely encoded structure, text streams also discourage programs from
being promiscuous with each other about their internal states and help
enforce encapsulation.  We'll return to this point at the end of
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  when we discuss RPC.
</p>
<p>
  When you feel the urge to design a complex binary file format,
or a complex binary application protocol, it is generally wise to
lie down until the feeling passes. If performance is what you're
worried about, implementing compression on the text protocol stream
either at some level below or above the application protocol will
give you a cleaner and perhaps better-performing design than a 
binary protocol (text compresses well, and quickly).
</p>
 <blockquote>
  <p>
   A bad example of binary formats in Unix history was the way
device-independent
   <em>troff</em> read a binary file
containing device information, supposedly for speed.  The initial
implementation generated that binary file from a text description in a
somewhat unportable way.  Faced with a need to port
   <em>ditroff</em> <em>quickly</em>
   to a new
machine, rather than reinvent the binary goo, I ripped it out and just
had
   <em>ditroff</em> read the text file.  With carefully
crafted file-reading code, the speed penalty was negligible.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  Designing a textual protocol tends to future-proof your system.
One specific reason is that ranges on numeric fields aren't implied by
the format itself. Binary formats usually specify the number of bits
allocated to a given value, and extending them is difficult.  For
example, IPv4 only allows 32 bits for an address.  To extend address
size to 128 bits (as done by IPv6) requires a major
revamping.<sup><a href="#ftn.id2901165" id="id2901165">[51]</a></sup>
  In contrast, if you need a larger value
in a text format, just write it.  It may be that a given program can't
receive values in that range, but it's usually easier to modify the
program than to modify all the data stored in that format.
</p>
<p>
  The only good justification for a binary protocol is if you're
going to be manipulating large enough data sets that you're genuinely
worried about getting the most bit-density out of your media, or if
you're very concerned about the time or instruction budget required to
interpret the data into an in-core structure.  Formats for large
images and multimedia are sometimes an example of the former, and
network protocols with hard latency requirements sometimes an 
example of the latter.
</p>
 <blockquote>
  <p>
   The reciprocal problem with SMTP or HTTP-like text protocols is
that they tend to be expensive in bandwidth and slow to parse.  The
smallest X request is 4 bytes: the smallest HTTP request is about 100
bytes.  X requests, including amortized overhead of transport, can be
executed in the order of 100 instructions; at one point, an
Apache
   [web server]
developer proudly indicated they were down to 7000 instructions.  For
graphics, bandwidth becomes everything on output; hardware is designed
such that these days the graphics-card bus is
   <em>the</em>
   bottleneck for small operations, so any protocol had better be very
tight if it is not to be a worse bottleneck.  This is the extreme
case.
  </p>
  <span>
   – Jim Gettys
  </span>
 </blockquote>
<p>
  These concerns are valid in other extreme cases as well as in X
— for example, in the design of graphics file formats intended
to hold very large images. But they are usually just another case of
premature-optimization
  fever.  Textual formats don't necessarily have much lower bit density
than binary ones; they do after all use seven out of eight bits per
byte. And what you gain by not having to parse text, you generally
lose the first time you need to generate a test load, or to eyeball a
program-generated example of your format and figure out what's in
there.
</p>
<p>
  In addition, the kind of thinking that goes into designing tight
binary formats tends to fall down on making them cleanly extensible.
The X designers experienced this:
</p>
 <blockquote>
  <p>
   Against the current X framework is the fact we didn't design enough of
a structure to make it easier to ignore trivial extensions to the protocol;
we can do this some of the time, but a bit better framework would have been
good.
  </p>
  <span>
   – Jim Gettys
  </span>
 </blockquote>
<p>
  When you think you have an extreme case that justifies a binary
file format or protocol, you need to think very carefully about
extensibility
  and leaving room in the design for growth.
</p>
<h4 id="id2901332"><a href="#id2901332">§</a>Case Study: Unix Password File Format</h4>
<p>
  On many operating systems, the per-user data required to
validate logins and start a user's session is an opaque binary
database. Under Unix, by contrast, it's a text file with records one
per line and colon-separated fields.
</p>
<p>
  Example 5.1 consists of some randomly-chosen example lines:
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 5.1. Password file example.
   </b>
  </p>
  <pre class="programlisting">
games:*:12:100:games:/usr/games:
gopher:*:13:30:gopher:/usr/lib/gopher-data:
ftp:*:14:50:FTP User:/home/ftp:
esr:0SmFuPnH5JlNs:23:23:Eric S. Raymond:/home/esr:
nobody:*:99:99:Nobody:/:
</pre>
 </div>
<p>
  Without even knowing anything about the semantics of the fields,
we can notice that it would be hard to pack the data much tighter in
a binary format. The colon sentinel characters would have to have
functional equivalents taking at least as much space (usually
either count bytes or NULs). The per-user records would either have
to have terminators (which could hardly be shorter than a single
newline) or else be wastefully padded out to a fixed length.
</p>
<p>
  Actually the prospects for saving space through binary encoding
pretty much vanish if you know the actual semantics of the data.  The
numeric user ID (3rd) and group ID (4th) fields are integers, thus on
most machines a binary representation would be at least 4 bytes, and
longer than the text for values up to 999.  But let's agree to ignore
this for now and suppose the best case that the numeric fields have a
0-255 range.
</p>
<p>
  We could tighten up the numeric fields (3rd and 4th) by
collapsing the numerics to single bytes, and the password strings
(2nd) to an 8-bit encoding. On this example, that would give about an
8% size decrease.
</p>
<p>
  That 8% of putative inefficiency buys us a lot. It avoids
putting an arbitrary limit on the range of the numeric fields. It
gives us the ability to modify the password file with any old text
editor of our choice, rather than having to build a specialized tool
to edit a binary format (though in the case of the password file
itself, we have to be extra careful about concurrent edits). And it
gives us the ability to do ad-hoc searches and filters and reports on
the user account information with text-stream tools such as
grep(1).
</p>
<p>
  We do have to be a bit careful about not embedding a colon in
any of the textual fields.  Good practice is to tell the file write
code to precede embedded colons with an escape character, and then to
tell the file read code to interpret it. Unix tradition favors
backslash for this use.
</p>
<p>
  The fact that structural information is conveyed by field
position rather than an explicit tag makes this format faster 
to read and write, but a bit rigid.  If the set of properties
associated with a key is expected to change with any frequency, 
one of the tagged formats described below might be a better choice.
</p>
<p>
  Economy is not a major issue with password files to begin with,
as they're normally read seldom<sup><a href="#ftn.id2901458" id="id2901458">[52]</a></sup>
  and infrequently modified.  Interoperability
is not an issue, since various data in the file (notably user and
group numbers) are not portable off the originating machine.  For
password files, it's therefore quite clear that going where the
transparency
criterion
  leads was the right thing.
</p>
<h4 id="id2901494"><a href="#id2901494">§</a>Case Study: .newsrc Format</h4>
<p>
  Usenet
  news is
a worldwide distributed bulletin-board system that anticipated today's
P2P networking by two decades.  It uses a message format very similar
to that of RFC 822 electronic-mail messages, except that instead of
being directed to personal recipients messages are sent to topic
groups.  Articles posted at any participating site are broadcast to
each site that it has registered as a neighbor, and eventually
flood-fill to all news sites.
</p>
<p>
  Almost all Usenet news readers understand the
  <code>.newsrc</code> file, which records which Usenet messages
have been seen by the calling user.  Though it is named like a
run-control file, it is not only read at startup but typically updated
at the end of the newsreader run.  The
  <code>.newsrc</code> format has been fixed since the first newsreaders around 1980.
   Example 5.2 is a representative section from a <code>.newsrc</code> file.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 5.2. A
    <code>.newsrc</code> example.
   </b>
  </p>
  <pre class="programlisting">
rec.arts.sf.misc! 1-14774,14786,14789
rec.arts.sf.reviews! 1-2534
rec.arts.sf.written: 1-876513
news.answers! 1-199359,213516,215735
news.announce.newusers! 1-4399
news.newusers.questions! 1-645661
news.groups.questions! 1-32676
news.software.readers! 1-95504,137265,137274,140059,140091,140117
alt.test! 1-1441498
</pre>
 </div>
<p>
  Each line sets properties for the newsgroup named in the first
field. The name is immediately followed by a character that indicates 
whether the owning user is currently subscribed to the group or not; a colon
indicates subscription, and an exclamation mark indicates
nonsubscription. The remainder of the line is a sequence of
comma-separated article numbers or ranges of article numbers,
indicating which articles the user has seen.
</p>
<p>
  Non-Unix programmers might have automatically tried to design a
fast binary format in which each newsgroup status was described by
either a long but fixed-length binary record, or a sequence of
self-describing binary packets with internal length fields.  The main
point of such a binary representation would be to express ranges with
binary data in paired word-length fields, in order to avoid the
overhead of parsing all the range expressions at startup.
</p>
<p>
  Such a layout could be read and written faster than a textual
format, but it would have other problems.  A naïve implementation
in fixed-length records would have placed artificial length limits on
newsgroup names and (more seriously) on the maximum number of ranges
of seen-article numbers.  A more sophisticated binary-packet format
would avoid the length limits, but could not be edited with the user's
eyeballs and fingers — a capability that can be quite useful
when you want to reset just some of the read bits in an individual
newsgroup.  Also, it would not necessarily be portable to different
machine types.
</p>
<p>
  The designers of the original newsreader chose
transparency
  and interoperability over
economy.  The case for going in the other direction was not completely
ridiculous;
  <code>.newsrc</code> files can get very large, and
one modern reader (GNOME's Pan) uses a speed-optimized private format
to avoid startup lag.  But to other implementers, textual
representation looked like a good tradeoff in 1980, and has looked
better as machines increased in speed and storage dropped in
price.
</p>
<h4 id="png"><a href="#png">§</a>Case Study: The PNG Graphics File Format</h4>
<p>
  PNG (Portable Network Graphics) is a file format for bitmap
graphics.
  It is like GIF,
and unlike JPEG, in that it uses lossless compression and is optimized
for applications such as line art and icons rather than photographic
images.  Documentation and open-source reference libraries of high
quality are available at the
  <a href="http://www.libpng.org/pub/png/">
   Portable Network Graphics
website</a>.
</p>
<p>
  PNG is an excellent example of a thoughtfully designed binary
format.  A binary format is appropriate since graphics files may
contain very large amounts of data, such that storage size and
Internet download time would go up significantly if the pixel data
were stored textually.  Transaction economy was the prime
consideration, with
transparency
  sacrificed.<sup><a href="#ftn.id2901736" id="id2901736">[53]</a></sup>
  The designers were, however, careful about
interoperability; PNG specifies byte orders, integer word lengths,
endianness, and (lack of) padding between fields.
</p>
<p>
  A PNG file consists of a sequence of chunks, each in a
self-describing format beginning with the chunk type name and the
chunk length.  Because of this organization, PNG does not need a
release number.  New chunk types can be added at any time; the case of
the first letter in the chunk
type name informs PNG-using software whether or not each chunk can be
safely ignored.
</p>
<p>
  The PNG file header also repays study.  It has been 
cleverly designed to make various common kinds of file corruption
(e.g., by 7-bit transmission links, or mangling of CR and LF
characters) easy to detect.
</p>
<p>
  The PNG standard is precise, comprehensive, and well written. It
could serve as a model for how to write file format standards.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2901165" id="ftn.id2901165">[51]</a></sup>
  There is a legend that some early airline
reservation systems allocated exactly one byte for a plane's passenger
count.  Supposedly they became very confused by the arrival of the
Boeing 747, the first plane that could carry more than 255
passengers.
</p>

<p><sup><a href="#id2901458" id="ftn.id2901458">[52]</a></sup>
  Password files are
normally read once per user session at login time, and after that
occasionally by file-system utilities like
ls(1)
that must map from numeric user and group IDs to
names.
</p>

<p><sup><a href="#id2901736" id="ftn.id2901736">[53]</a></sup>
  Confusingly, PNG supports a different kind
of transparency — transparent pixels in the
PNG image.
</p>
</div>


<!-- FILE: ch05s02.html -->
<h3 id="ch05s02"><a href="#ch05s02">§</a>Data File Metaformats</h3>
<p>
  A data file metaformat is a set of syntactic and lexical
conventions that is either formally standardized or sufficiently well
established by practice that there are standard service libraries to
handle marshaling and unmarshaling it.
</p>
<p>
  Unix has evolved or adopted metaformats suitable for a wide range
of applications. It is good practice to use one of these (rather than
an idiosyncratic custom format) wherever possible.  The benefits begin
with the amount of custom parsing and generation code that you may be
able to avoid writing by using a service library.  But the most
important benefit is that developers and even many users will instantly 
recognize these formats and feel comfortable with them, which reduces
the friction costs of learning new programs.
</p>
<p>
  In the following discussion, when we refer to “traditional
Unix tools” we are intending the combination of
grep(1),
sed(1),
awk(1),
tr(1),
and
cut(1)
for doing text searches and transformations.
Perl
  and other
scripting languages
  tend to have good native support for
parsing the line-oriented formats that these tools encourage.
</p>
<p>
  Here, then, are the standard formats that can serve you as models.
</p>
<h4 id="id2901882"><a href="#id2901882">§</a>DSV Style</h4>
<p>
  DSV stands for
  <em>Delimiter-Separated Values</em>.  Our first case study in textual metaformats was
the
  <code>/etc/passwd</code> file, which is a DSV format with
colon as the value separator.  Under Unix, colon is the default
separator for DSV formats in which the field values may contain
whitespace.
</p>
<p>
  <code>/etc/passwd</code> format (one record 
per line, colon-separated fields) is very traditional under Unix
and frequently used for tabular data.  Other classic examples 
include the
  <code>/etc/group</code> file describing security 
groups and the
  <code>/etc/inittab</code> file used to control
startup and shutdown of Unix service programs at different run levels
of the operating system.
</p>
<p>
  Data files in this style are expected to support inclusion of
colons in the data fields by backslash escaping.  More generally,
code that reads them is expected to support record continuation by
ignoring backslash-escaped newlines, and to allow embedding
nonprintable character data by C-style backslash escapes.
</p>
<p>
  This format is most appropriate when the data is tabular,
keyed by a name (in the first field), and records are typically
short (less than 80 characters long).  It works well with 
traditional Unix tools.
</p>
<p>
  One occasionally sees field separators other than the colon,
such as the pipe character | or even an ASCII NUL.  Old-school Unix
practice used to favor tabs, a preference reflected in the defaults
for
cut(1)
and
paste(1);
but this has gradually changed as format designers became aware of the
many small irritations that ensue from the fact that tabs and spaces
are not visually distinguishable.
</p>
<p>
  This format is to Unix what CSV (comma-separated value) format 
is under Microsoft Windows and elsewhere outside the Unix world.
CSV (fields separated by commas, double quotes used to escape 
commas, no continuation lines) is rarely found under Unix.
</p>
<p>
  In fact, the Microsoft version of CSV is a textbook example of
how
  <em>not</em>
  to design a textual file format. Its
problems begin with the case in which the separator character (in this
case, a comma) is found inside a field. The Unix way would be to
simply escape the separator with a backslash, and have a double escape
represent a literal backslash.  This design gives us a single special case
(the escape character) to check for when parsing the file, and only a
single action when the escape is found (treat the following character
as a literal). The latter conveniently not only handles the separator
character, but gives us a way to handle the escape character and
newlines for free. CSV, on the other hand, encloses the entire field
in double quotes if it contains the separator.  If the field contains
double quotes, it must also be enclosed in double quotes, and the
individual double quotes in the field must themselves be repeated
twice to indicate that they don't end the field.
</p>
<p>
  The bad results of proliferating special cases are twofold.
First, the complexity of the parser (and its vulnerability to bugs) is
increased.  Second, because the format rules are complex and
underspecified, different implementations diverge in their handling of
edge cases.  Sometimes continuation lines
  <em>are</em>
  supported, by starting the last field of the line with an unterminated
double quote — but only in some products!  Microsoft has
incompatible versions of CSV files between its own applications, and
in some cases between different versions of the same application
(Excel being the obvious example here).
</p>
<h4 id="id2902039"><a href="#id2902039">§</a>RFC 822 Format</h4>
<p>
  The RFC 822 metaformat derives from the textual format of
Internet electronic mail messages; RFC 822 is the principal Internet RFC
describing this format (since superseded by RFC 2822).  MIME
(Multipurpose Internet Media Extension)
  provides
a way to embed typed binary data within RFC-822-format messages.  (Web
searches on either of these names will turn up the relevant
standards.)
</p>
<p>
  In this metaformat, record attributes are stored one per line,
named by tokens resembling mail header-field names and terminated with
a colon followed by whitespace.  Field names do not contain
whitespace; conventionally a dash is substituted instead. The
attribute value is the entire remainder of the line, exclusive of
trailing whitespace and newline.  A physical line that begins with tab
or whitespace is interpreted as a continuation of the current logical
line. A blank line may be interpreted either as a record terminator or
as an indication that unstructured text follows.
</p>
<p>
  Under Unix, this is the traditional and preferred textual
metaformat for attributed messages or anything that can be closely
analogized to electronic mail.  More generally, it's appropriate for
records with a varying set of fields in which the hierarchy of data is
flat (no recursion or tree structure).
</p>
<p>
  Usenet news
  uses
it; so do the HTTP 1.1 (and later) formats used by the World Wide Web.
It is very convenient for editing by humans.  Traditional Unix search
tools are still good for attribute searches, though finding record
boundaries will be a little more work than in a record-per-line
format.
</p>
<p>
  One weakness of RFC 822 format is that when more than one RFC
822 message or record is put in a file, the record boundaries may not
be obvious — how is a poor literal-minded computer to know where
the unstructured text body of a message ends and the next header
begins?  Historically, there have been several different conventions
for delimiting messages in mailboxes.  The oldest and most widely
supported, leading each message with a line that begins with the
string
  <code>"From "</code> and sender information, is not
appropriate for other kinds of records; it also requires that lines in
message text beginning with
  <code>"From "</code> be escaped
(typically with
  <code>&gt;</code>) — a practice which not infrequently leads
to confusion.
</p>
<p>
  Some mail systems use delimiter lines consisting of control
characters unlikely to appear in messages, such as several ASCII 01
(control-A) characters in succession. The MIME standard gets around
the problem by including an explicit message length in the header, but
this is a fragile solution which is very likely to break if messages
are ever manually edited.  For a somewhat better solution, see the
record-jar style described later in this chapter.
</p>
<p>
  For examples of RFC 822 format, look in your mailbox.
</p>
<h4 id="id2902164"><a href="#id2902164">§</a>Cookie-Jar Format</h4>
<p>
  Cookie-jar format is used by the
fortune(1)
program for its database of random quotes.  It is appropriate for
records that are just bags of unstructured text.  It simply uses newline
followed by
  <code>%%</code> (or sometimes newline followed by <code>%</code>) as a record separator. Example 5.3
  is an example section from a file of email signature quotes:
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 5.3. A fortune file example.
   </b>
  </p>
  <pre class="programlisting">
"Among the many misdeeds of British rule in India, history will look
upon the Act depriving a whole nation of arms as the blackest."
        -- Mohandas Gandhi, "An Autobiography", pg 446
%
The people of the various provinces are strictly forbidden to have 
in their possession any swords, short swords, bows, spears, firearms,
or other types of arms. The possession of unnecessary implements 
makes difficult the collection of taxes and dues and tends to foment 
uprisings.
        -- Toyotomi Hideyoshi, dictator of Japan, August 1588
%
"One of the ordinary modes, by which tyrants accomplish their 
purposes without resistance, is, by disarming the people, and making 
it an offense to keep arms."
        -- Supreme Court Justice Joseph Story, 1840
</pre>
 </div>
<p>
  It is good practice to accept whitespace after
  <code>%</code> when looking
for record delimiters.  This helps cope with human editing mistakes.
It's even better practice to use
  <code>%%</code>, and ignore all text from
  <code>%%</code> to
end-of-line.
</p>
 <blockquote>
  <p>
   The cookie-jar separator was originally
   <code>%%\n</code>.  I wanted
something a bit more visible than
   <code>%</code> would have been.  In fact, any
stuff after the
   <code>%%</code> is treated as a comment (or at least that's how I
wrote it).
  </p>
  <span>
   – Ken Arnold
  </span>
 </blockquote>
<p>
  Simple cookie-jar format is appropriate for pieces of
text that have no natural ordering, distinguishable structure above
word level, or search keys other than their text context.
</p>
<h4 id="id2906931"><a href="#id2906931">§</a>Record-Jar Format</h4>
<p>
  Cookie-jar record separators combine well with the RFC 822
metaformat for records, yielding a format we'll call
‘record-jar’. If you need a textual format that will
support multiple records with a variable repertoire of explicit
fieldnames, one of the least surprising and human-friendliest ways to
do it would look like Example 5.4.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 5.4. Basic data for three planets in a record-jar format.
   </b>
  </p>
  <pre class="programlisting">
Planet: Mercury
Orbital-Radius: 57,910,000 km
Diameter: 4,880 km
Mass: 3.30e23 kg
%%
Planet: Venus
Orbital-Radius: 108,200,000 km
Diameter: 12,103.6 km
Mass: 4.869e24 kg
%%
Planet: Earth
Orbital-Radius: 149,600,000 km
Diameter: 12,756.3 km
Mass: 5.972e24 kg
Moons: Luna
</pre>
 </div>
<p>
  Of course, the record delimiter could be a blank line, but a
line consisting of "
  <code>%%\n</code> " is more explicit and less likely to be
introduced by accident during editing (two printable characters are
better than one because it can't be generated by a single-character
typo).  In a format like this it is good practice to simply ignore
blank lines.
</p>
<p>
  If your records have an unstructured text part, your record-jar
format is closely approaching a mailbox format. In this case, it's
important that you have a well-defined way to escape the record
delimiter so it can appear in text; otherwise, your record reader is
going to choke on an ill-formed text part someday.  Some technique
analogous to byte-stuffing (described later in this chapter) is
indicated.
</p>
<p>
  Record-jar format is appropriate for sets of field-attribute 
associations that are like DSV files, but have a variable repertoire
of fields, and possibly unstructured text associated with them.
</p>
<h4 id="id2907018"><a href="#id2907018">§</a>XML</h4>
<p>
  XML is a very simple syntax resembling HTML —
angle-bracketed tags and ampersand-led literal sequences.  It is about
as simple as a plain-text markup can be and yet express recursively
nested data structures.  XML is just a low-level syntax; it requires
a document type definition (such as XHTML) and associated application
logic to give it semantics.
</p>
<p>
  XML is well suited for complex data formats (the sort of things
for which the old-school Unix tradition would use an RFC-822-like stanza
format) though overkill for simpler ones.  It is especially
appropriate for formats that have a complex nested or recursive
structure of the sort that the RFC 822 metaformat does not handle well.
For a good introduction to the format, see
  <em>XML in a Nutshell</em><sup><a href="#Harold-Means" title="[Harold-Means]">[Harold-Means]</a></sup>.
</p>
 <blockquote>
  <p>
   Among the hardest things to get right in designing any text file
format are issues of quoting, whitespace and other low-level syntax
details.  Custom file formats often suffer from slightly broken syntax
that doesn't quite match other similar formats.  Using a standard format
such as XML, which is verifiable and parsed by a standard library,
eliminates most of these issues.
  </p>
  <span>
   – Keith Packard
  </span>
 </blockquote>
<p>
   Example 5.5 is a simple example of an XML-based configuration file.  It is part of the <em>kdeprint</em> tool shipped
   with the open-source KDE office suite hosted under Linux.  It describes options for an image-to-PostScript filtering
   operation, and how to map them into arguments for a filter command.  For another instructive example, see the
   discussion of
  <em>Glade</em> in <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">Chapter 8</a>. </p>
 <div class="example">
  <p class="title">
   <b>
    Example 5.5. An XML example.
   </b>
  </p>
  <pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;kprintfilter name="imagetops"&gt;
    &lt;filtercommand 
           data="imagetops %filterargs %filterinput %filteroutput" /&gt;
    &lt;filterargs&gt;
        &lt;filterarg name="center" 
                   description="Image centering" 
                   format="-nocenter" type="bool" default="true"&gt;
            &lt;value name="true" description="Yes" /&gt;
            &lt;value name="false" description="No" /&gt;
        &lt;/filterarg&gt;
        &lt;filterarg name="turn" 
                   description="Image rotation" 
                   format="-%value" type="list" default="auto"&gt;
            &lt;value name="auto" description="Automatic" /&gt;
            &lt;value name="noturn" description="None" /&gt;
            &lt;value name="turn" description="90 deg" /&gt;
        &lt;/filterarg&gt;
        &lt;filterarg name="scale" 
                   description="Image scale" 
                   format="-scale %value" 
                   type="float" 
                        min="0.0" max="1.0" default="1.000" /&gt;
        &lt;filterarg name="dpi" 
                   description="Image resolution" 
                   format="-dpi %value" 
                   type="int" min="72" max="1200" default="300" /&gt;
    &lt;/filterargs&gt;
    &lt;filterinput&gt;
        &lt;filterarg name="file" format="%in" /&gt;
        &lt;filterarg name="pipe" format="" /&gt;
    &lt;/filterinput&gt;
    &lt;filteroutput&gt;
        &lt;filterarg name="file" format="&gt; %out" /&gt;
        &lt;filterarg name="pipe" format="" /&gt;
    &lt;/filteroutput&gt;
&lt;/kprintfilter&gt;
</pre>
 </div>
<p>
  One advantage of XML is that it is often possible to
detect ill-formed, corrupted, or incorrectly generated data through a
syntax check, without knowing the semantics of the data.
</p>
<p>
  The most serious problem with XML is that it doesn't play well
with traditional Unix tools.  Software that wants to read an XML
format needs an XML parser; this means bulky, complicated programs.
Also, XML is itself rather bulky; it can be difficult to see the
data amidst all the markup.
</p>
<p>
  One application area in which XML is clearly winning is in
markup formats for document files (we'll have more to say about this
in
  <a href="#documentationchapter" title="Chapter 18. Documentation">
   Chapter 18</a>).
Tagging in such documents tends to be relatively sparse among large
blocks of plain text; thus, traditional Unix tools still work fairly
well for simple text searches and transformations.
</p>
<p>
  One interesting bridge between these worlds is PYX format
— a line-oriented translation of XML that can be hacked with
traditional line-oriented Unix text tools and then losslessly
translated back to XML.  A Web search for “Pyxie” will
turn up resources.  The xmltk toolkit takes the opposite tack,
providing stream-oriented tools analogous to
grep(1)
and
sort(1)
for filtering XML documents; Web search for
“xmltk” to find it.
</p>
<p>
  XML can be a simplifying choice or a complicating one.  There is
a lot of hype surrounding it, but don't become a fashion victim by either
adopting or rejecting it uncritically. Choose carefully and bear the KISS
principle in mind.
</p>
<h4 id="id2907263"><a href="#id2907263">§</a>Windows INI Format</h4>
<p>
  Many Microsoft Windows programs use a textual data format that looks like Example 5.6. This example associates
  optional resources named
  <code>account</code>, <code>directory</code>, <code>numeric_id</code>, and <code>developer</code> with named projects
  <code>python</code>, <code>sng</code>, <code>fetchmail</code>, and <code>py-howto</code>.  The DEFAULT entry supplies
  values that will be used when a named entry fails to supply them.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 5.6. A
    <code>.INI</code> file example.
   </b>
  </p>
  <pre class="programlisting">
[DEFAULT]
account = esr

[python]
directory = /home/esr/cvs/python/
developer = 1

[sng]
directory = /home/esr/WWW/sng/
numeric_id = 1012
developer = 1

[fetchmail]
numeric_id = 18364

[py-howto]
account = eric
directory = /home/esr/cvs/py-howto/
developer = 1
</pre>
 </div>
<p>
  This style of data-file format is not native to Unix, but some
Linux programs (notably Samba, the suite of tools for accessing
Windows file shares from Linux) support it under Windows's influence.
This format is readable and not badly designed, but like XML it
doesn't play well with
grep(1)
or conventional Unix scripting tools.
</p>
<p>
  The .INI format is appropriate if your data naturally falls into
its two-level organization of name-attribute pairs clustered under
named records or sections.  It's not good for data with a fully
recursive treelike structure (XML is more appropriate for that), 
and it would be overkill for a simple list of name-value
associations (use DSV format for that).
</p>
<h4 id="id2907428"><a href="#id2907428">§</a>Unix Textual File Format Conventions</h4>
<p>
  There are long-standing Unix traditions about how textual data
formats ought to look.  Most of these derive from one or more of the
standard Unix metaformats we've just described.  It is wise to follow these
conventions unless you have strong and specific reasons to do otherwise.
</p>
<p>
  In
  <a href="#configurationchapter" title="Chapter 10. Configuration">
   Chapter 10</a>
  we
will discuss a different set of conventions used for program
run-control files, but you should notice that it will share some of
these same rules (especially about the lexical level, the rules by
which characters are assembled into tokens).
</p>
 <div>
  <ul>
   <li>
    <p>
     <em>
      One record per newline-terminated line, if
possible.
</em>
     This makes it easy to extract records with
text-stream tools.  For data interchange with other operating systems, 
it's wise to make your file-format parser indifferent to whether 
the line ending is LF or CR-LF. It's also conventional to ignore
trailing whitespace in such formats; this protects against common
editor bobbles.
    </p>
   </li>
   <li>
    <p>
     <em>Less than 80 characters per line, if possible.</em>
     This
makes the format browseable in an ordinary-sized terminal window.
If many records must be longer than 80 characters, consider a
stanza format (see below).
    </p>
   </li>
   <li>
    <p>
     <em>
      Use
      <code>#</code> as an introducer for comments.
</em>
     It is good to have a way to embed annotations and comments in
data files.  It's best if they're actually part of the file
structure, and so will be preserved by tools that know its format.
For comments that are not preserved during parsing,
     <code>#</code> is the 
conventional start character.
    </p>
   </li>
   <li>
    <p>
     <em>Support the backslash convention.</em>
     The least
surprising way to support embedding nonprintable control characters
is by parsing C-like backslash escapes —
     <code>\n</code> for a newline,
     <code>\r</code> for a carriage return,
     <code>\t</code> for a tab,
     <code>\b</code> for backspace,
     <code>\f</code> for formfeed,
     <code>\e</code> for ASCII escape (27),
     <code>\nnn</code> or
     <code>\onnn</code> or
     <code>\0nnn</code> for the character with octal
value
     <code>nnn</code>,
     <code>\xnn</code> for the character with hexadecimal value
     <code>nn</code>,
     <code>\dnnn</code> for the character with decimal value
     <code>nnn</code>,
     <code>\\</code> for a literal backslash.  A newer convention, but one worth following,
is the use of
     <code>\unnnn</code> for a hexadecimal
Unicode literal.
    </p>
   </li>
   <li>
    <p>
     <em>
      In one-record-per-line formats, use colon or any run
of whitespace as a field separator.
</em>
     The colon convention
seems to have originated with the Unix password file. If your fields
must contain instances of the separator(s), use a backslash as the
prefix to escape them.
    </p>
   </li>
   <li>
    <p>
     <em>
      Do not allow the distinction between tab and
whitespace to be significant.
</em>
     This is a recipe for serious
headaches when the tab settings on your users' editors are different;
more generally, it's confusing to the eye.  Using tab alone as a field
separator is especially likely to cause problems; allowing any run of
tabs and spaces to be a field separator, on the other hand, works
well.
    </p>
   </li>
   <li>
    <p>
     <em>Favor hex over octal.</em>
     Hex-digit pairs and
quads are easier to eyeball-map into bytes and today's 32- and 64-bit
words than octal digits of three bits each; also marginally more
efficient.  This rule needs emphasizing because some older Unix tools
such as
od(1)
violate it; that's a legacy from the instruction field sizes in the
machine languages of older PDP minicomputers.
    </p>
   </li>
   <li>
    <p>
     <em>
      For complex records, use a ‘stanza’ format:
multiple lines per record, with a record separator line of
      <code>%%\n</code> or
      <code>%\n</code>.
</em>
     The separators make useful visual boundaries for human
beings eyeballing the file.
    </p>
   </li>
   <li>
    <p>
     <em>
      In stanza formats, either have one record field per
line or use a record format resembling RFC 822 electronic-mail headers,
with colon-terminated field-name keywords leading fields.
</em>
     The second choice is appropriate when fields are often either absent
or longer than 80 characters, or when records are sparse (e.g., often
with empty fields).
    </p>
   </li>
   <li>
    <p>
     <em>In stanza formats, support line continuation.</em>
     When interpreting the file, either discard backslash followed by
whitespace or interpret newline followed by whitespace equivalently to a single
space, so that a long logical line can be folded into short (easily
editable!) physical lines. It's also conventional to ignore
trailing whitespace in these formats; this convention protects against common
editor bobbles.
    </p>
   </li>
   <li>
    <p>
     <em>
      Either include a version number or design the format
as self-describing chunks independent of each other.
</em>
     If
there is even the faintest possibility that the format will have to be
changed or extended, include a version number so your code can
conditionally do the right thing on all versions.  Alternatively,
design the format as self-describing chunks so that you can add new
chunk types without instantly breaking old code.
    </p>
   </li>
   <li>
    <p>
     <em>Beware of floating-point round-off problems.</em>
     Conversion of floating-point numbers from binary to text format and
back can lose precision, depending on the quality of the conversion
library you are using.  If the structure you are
marshaling/unmarshaling contains floating point, you should test the
conversion in both directions.  If it looks like conversion in
either direction is subject to roundoff errors, be prepared to dump
the floating-point field as raw binary instead, or a string encoding
thereof.  If you're coding in C or some language that has access to
C printf/scanf, the C99
     <code>%a</code> specifier may solve this problem.
    </p>
   </li>
   <li>
    <p>
     <em>
      Don't bother compressing or binary-encoding just part of
the file.
</em>
     See below...
    </p>
   </li>
  </ul>
 </div>
<h4 id="id2907903"><a href="#id2907903">§</a>The Pros and Cons of File Compression</h4>
<p>
  Many modern Unix projects, such as OpenOffice.org and AbiWord,
now use XML compressed with
zip(1)
or
gzip(1)
as a data file format.  Compressed XML combines space economy with some of the
advantages of a textual format — notably, it avoids the problem
that binary formats must often allocate space for information that may
not be used in particular cases (e.g., for unusual options or large
ranges).  But there is some dispute about this, dispute which turns on some
of the central tradeoffs discussed in this chapter.
</p>
<p>
  On the one hand, experiments have shown that documents in a
compressed XML file are usually significantly smaller than the
Microsoft Word's native file format, a binary format that one might
imagine would take less space.  The reason relates to a fundamental of
the Unix philosophy: Do one thing well.  Creating a single tool
to do the compression job well is more effective than ad-hoc
compression on parts of the file, because the tool can look across all
the data and exploit
  <em>all</em>
  repetition in the
information.
</p>
<p>
  Also, by separating the representation design from the
particular compression method used, you leave open the possibility of
using different compression methods in the future with no more than
minimal changes to the actual file parsing — perhaps, with no
changes at all.
</p>
<p>
  On the other hand, compression does some damage to transparency.
While a human being can estimate from context whether uncompressing
the file is likely to show him anything useful, tools such as
file(1)
cannot as of mid-2003 see through the wrapping.
</p>
<p>
  Some would advocate a less structured compression format —
straight
gzip(1)-compressed
XML data, say, without the internal structure and self-identifying
header chunk provided by
zip(1). While
using a format similar to that of 
zip(1)
solves the identification problem, it means that decoding such
files will be tricky for programs written in the simpler scripting
languages.
</p>
<p>
  Any of these solutions (straight text, straight binary, or
compressed text) may be optimal depending on the relative weight you
give to storage economy, discoverability, or making browsing tools
as simple as possible to write.  The point of the preceding discussion
is not to advocate any one of these approaches over the others, but
rather to suggest how you can think about the options and design
tradeoffs clearly.
</p>
<p>
  This having been said, the truly Unixy solution would probably
be to fix
file(1)
to see file prefixes through the compression — and, failing
that, to write a shellscript wrapper around
file(1)
that would interpret compression as a direction to apply
gunzip(1)
and take a second look.
</p>



<!-- FILE: ch05s03.html -->
<h3 id="ch05s03"><a href="#ch05s03">§</a>Application Protocol Design</h3>
<p>
  In
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>,
we'll discuss the advantages of breaking complicated applications up
into cooperating processes speaking an application-specific command
set or protocol with each other.  All the good reasons for data file
formats to be textual apply to these application-specific protocols as
well.
</p>
<p>
  When your application protocol is textual and easily parsed
by eyeball, many good things become easier.  Transaction dumps become
much easier to interpret. Test loads become easier to write.
</p>
<p>
  Server processes are often invoked by harness programs such as
inetd(8)
in such a way that the server sees commands on standard input and
ships responses to standard output.  We describe this “CLI
server” pattern in more detail in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>.
</p>
<p>
  A CLI server with a command set that is designed for simplicity has
the valuable property that a human tester will be able to type
commands direct to the server process to probe the software's
behavior.
</p>
<p>
  Another issue to bear in mind is the end-to-end design
principle.  Every protocol designer should read the classic
  <em>End-to-End Arguments in System Design</em> <sup><a href="#Saltzer" title="[Saltzer]">[Saltzer]</a></sup>. There are often serious questions about which
level of the protocol stack should handle features like security and
authentication; this paper provides some good conceptual tools for
thinking about them. Yet a third issue is designing application
protocols for good performance.  We'll cover that issue in more detail
in
  <a href="#optimizationchapter" title="Chapter 12. Optimization">
   Chapter 12</a>.
</p>
<p>
  The traditions of Internet application protocol design evolved
separately from Unix before 1980.<sup><a href="#ftn.id2908167" id="id2908167">[54]</a></sup>
  But since the 1980s these traditions have become thoroughly
naturalized into Unix practice.
</p>
<p>
  We'll illustrate the Internet style by looking at three
application protocols that are both among the most heavily used, and
are widely regarded among Internet hackers as paradigmatic: SMTP,
POP3, and IMAP.  All three address different aspects of mail transport
(one of the net's two most important applications, along with the
World Wide Web), but the problems they address (passing messages,
setting remote state, indicating error conditions) are generic to
non-email application protocols as well and are normally addressed
using similar techniques.
</p>
<h4 id="id2908194"><a href="#id2908194">§</a>Case Study: SMTP, the Simple Mail Transfer Protocol</h4>
<p>
   Example 5.7 is an example transaction in SMTP (Simple Mail Transfer Protocol), which is described by RFC 2821. In the
   example, <em>C:</em> lines are sent by a mail transport agent (MTA) sending mail, and <em>S:</em> lines are returned
   by the MTA receiving it. Text <em> emphasized like this </em> is comments, not part of the actual transaction.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 5.7. An SMTP session example.
   </b>
  </p>
  <pre class="programlisting">
<em>C: &lt;client connects to service port 25&gt;</em>
<em>C:</em> HELO snark.thyrsus.com               <em>sending host identifies self</em>
<em>S:</em> 250 OK Hello snark, glad to meet you  <em>receiver acknowledges</em>
<em>C:</em> MAIL FROM: &lt;esr@thyrsus.com&gt;         <em>identify sending user</em>
<em>S:</em> 250 &lt;esr@thyrsus.com&gt;... Sender ok   <em>receiver acknowledges</em>
<em>C:</em> RCPT TO: cor@cpmy.com                <em>identify target user</em>
<em>S:</em> 250 root... Recipient ok             <em>receiver acknowledges</em>
<em>C:</em> DATA
<em>S:</em> 354 Enter mail, end with "." on a line by itself
<em>C:</em> Scratch called.  He wants to share
<em>C:</em> a room with us at Balticon.
<em>C:</em>.                                    <em>end of multiline send</em>
<em>S:</em> 250 WAA01865 Message accepted for delivery
<em>C:</em> QUIT                                 <em>sender signs off</em>
<em>S:</em> 221 cpmy.com closing connection      <em>receiver disconnects</em>
<em>C: &lt;client hangs up&gt;</em>
</pre>
 </div>
<p>
  This is how mail is passed among Internet machines.  Note the
following features: command-argument format of the requests, responses
consisting of a status code followed by an informational message, the
fact that the payload of the DATA command is terminated by a line
consisting of a single dot.
</p>
<p>
  SMTP is one of the two or three oldest application protocols 
still in use on the Internet.   It is simple, effective, and has
withstood the test of time.  The traits we have called out here are 
tropes that recur frequently in other Internet protocols.  If there is
any single archetype of what a well-designed Internet application 
protocol looks like, SMTP is it.
</p>
<h4 id="id2908383"><a href="#id2908383">§</a>Case Study: POP3, the Post Office Protocol</h4>
<p>
  Another one of the classic Internet protocols is POP3, the Post
Office Protocol.  It is also used for mail transport, but where SMTP
is a ‘push’ protocol with transactions initiated by the
mail sender, POP3 is a ‘pull’ protocol with transactions 
initiated by the mail receiver.  Internet users with intermittent
access (like dial-up connections) can let their mail pile up on 
a mail-drop machine, then use a POP3 connection to pull mail
up the wire to their personal machines.
</p>
<p>
   Example 5.8 is an example POP3 session. In the example, <em>C:</em> lines are sent by the client, and <em>S:</em>
   lines by the mail server. Observe the many similarities with SMTP.  This protocol is also textual and line-oriented,
   sends payload message sections terminated by a line consisting of a single dot followed by line terminator, and even
   uses the same exit command, QUIT. Like SMTP, each client operation is acknowledged by a reply line that begins with a
   status code and includes an informational message meant for human eyes.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 5.8. A POP3 example session.
   </b>
  </p>
  <pre class="programlisting">
<em>C: &lt;client connects to service port 110&gt;</em>
<em>S:</em> +OK POP3 server ready &lt;1896.6971@mailgate.dobbs.org&gt;
<em>C:</em> USER bob
<em>S:</em> +OK bob
<em>C:</em> PASS redqueen
<em>S:</em> +OK bob's maildrop has 2 messages (320 octets)
<em>C:</em> STAT
<em>S:</em> +OK 2 320
<em>C:</em> LIST
<em>S:</em> +OK 2 messages (320 octets)
<em>S:</em> 1 120
<em>S:</em> 2 200
<em>S:</em>.
<em>C:</em> RETR 1
<em>S:</em> +OK 120 octets
<em>S: &lt;the POP3 server sends the text of message 1&gt;</em>
<em>S:</em>.
<em>C:</em> DELE 1
<em>S:</em> +OK message 1 deleted
<em>C:</em> RETR 2
<em>S:</em> +OK 200 octets
<em>S: &lt;the POP3 server sends the text of message 2&gt;</em>
<em>S:</em>.
<em>C:</em> DELE 2
<em>S:</em> +OK message 2 deleted
<em>C:</em> QUIT
<em>S:</em> +OK dewey POP3 server signing off (maildrop empty)
<em>C: &lt;client hangs up&gt;</em>
</pre>
 </div>
<p>
  There are a few differences.  The most obvious one is that POP3
uses status tokens rather than SMTP's 3-digit status codes.  Of course
the requests have different semantics.  But the family resemblance
(one we'll have more to say about when we discuss the generic Internet
metaprotocol later in this chapter) is clear.
</p>
<h4 id="id2908582"><a href="#id2908582">§</a>Case Study: IMAP, the Internet Message Access Protocol</h4>
<p>
  To complete our triptych of Internet application protocol examples, we'll look at IMAP, another post office protocol
  designed in a slightly different style.  See Example 5.9; as before, <em>C:</em> lines are sent by the client, and
  <em>S:</em> lines by the mail server.  Text <em>emphasized like this</em> is comments, not part of the actual
  transaction.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 5.9. An IMAP session example.
   </b>
  </p>
  <pre class="programlisting">
<em>C: &lt;client connects to service port 143&gt;</em>
<em>S:</em> * OK example.com IMAP4rev1 v12.264 server ready
<em>C:</em> A0001 USER "frobozz" "xyzzy"
<em>S:</em> * OK User frobozz authenticated
<em>C:</em> A0002 SELECT INBOX
<em>S:</em> * 1 EXISTS
<em>S:</em> * 1 RECENT
<em>S:</em> * FLAGS (\Answered \Flagged \Deleted \Draft \Seen)
<em>S:</em> * OK [UNSEEN 1] first unseen message in /var/spool/mail/esr
<em>S:</em> A0002 OK [READ-WRITE] SELECT completed
<em>C:</em> A0003 FETCH 1 RFC822.SIZE                    <em>Get message sizes</em>
<em>S:</em> * 1 FETCH (RFC822.SIZE 2545)
<em>S:</em> A0003 OK FETCH completed
<em>C:</em> A0004 FETCH 1 BODY[HEADER]                   <em>Get first message header</em>
<em>S:</em> * 1 FETCH (RFC822.HEADER {1425}
<em>&lt;server sends 1425 octets of message payload&gt;</em>
<em>S:</em>)
<em>S:</em> A0004 OK FETCH completed
<em>C:</em> A0005 FETCH 1 BODY[TEXT]                     <em>Get first message body</em>
<em>S:</em> * 1 FETCH (BODY[TEXT] {1120}
<em>&lt;server sends 1120 octets of message payload&gt;</em>
<em>S:</em>)
<em>S:</em> * 1 FETCH (FLAGS (\Recent \Seen))
<em>S:</em> A0005 OK FETCH completed
<em>C:</em> A0006 LOGOUT
<em>S:</em> * BYE example.com IMAP4rev1 server terminating connection
<em>S:</em> A0006 OK LOGOUT completed
<em>C: &lt;client hangs up&gt;</em>
</pre>
 </div>
<p>
  IMAP delimits payloads in a slightly different way.  Instead of
ending the payload with a dot, the payload length is sent just before
it.  This increases the burden on the server a little bit (messages
have to be composed ahead of time, they can't just be streamed up
after the send initiation) but makes life easier for the client, which
can tell in advance how much storage it will need to allocate to
buffer the message for processing as a whole.
</p>
<p>
  Also, notice that each response is tagged with a sequence label
supplied by the request; in this example they have the form A000n, 
but the client could have generated any token into that slot.  This
feature makes it possible for IMAP commands to be streamed to the
server without waiting for the responses; a state machine in the 
client can then simply interpret the responses and payloads as
they come back.  This technique cuts down on latency.
</p>
<p>
  IMAP (which was designed to replace POP3) is an excellent
example of a mature and powerful Internet application protocol design,
one well worth study and emulation.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2908167" id="ftn.id2908167">[54]</a></sup>
  One relic of this pre-Unix history is that Internet
protocols normally use CR-LF as a line terminator rather than
Unix's bare LF.
</p>
</div>


<!-- FILE: ch05s04.html -->
<h3 id="ch05s04"><a href="#ch05s04">§</a>Application Protocol Metaformats</h3>
<p>
  Just as data file metaformats have evolved to simplify serialization
for storage, application protocol metaformats have evolved to simplify
serialization for transactions across networks.  The tradeoffs are a
little different in this case; because network bandwidth is more expensive
than storage, there is more of a premium on transaction economy.
Still, the transparency and interoperability benefits of textual
formats are sufficiently strong that most designers have resisted
the temptation to optimize for performance at the cost of readability.
</p>
<h4 id="id2908835"><a href="#id2908835">§</a>The Classical Internet Application Metaprotocol</h4>
<p>
  Marshall Rose's RFC 3117,
  <em>On the Design of Application Protocols</em>,<sup><a href="#ftn.id2908849" id="id2908849">[55]</a></sup>
  provides an excellent overview of the
design issues in Internet application protocols.  It makes explicit
several of the tropes in classical Internet application protocols that
we observed in our examination of SMTP, POP, and IMAP, and provides an
instructive taxonomy of such protocols.  It is recommended
reading.
</p>
<p>
  The classical Internet metaprotocol is
textual.  It uses single-line requests and responses, except for
payloads which may be multiline.  Payloads are shipped either with a
preceding length in octets or with a terminator that is the line
  <code>".\r\n"</code>. In the latter case the payload is
  <em id="byte_stuffing">byte-stuffed</em>; all lines that start with a period get
another period prepended, and the receiver side is responsible for
both recognizing the termination and stripping away the stuffing.
Response lines consist of a status code followed by a human-readable
message.
</p>
<p>
  One final advantage of this classical style is that it is
readily extensible.  The parsing and state-machine framework doesn't
need to change much to accommodate new requests, and it is easy to
code implementations so that they can parse unknown requests and
return an error or simply ignore them.  SMTP, POP3, and IMAP have all
been extended in minor ways fairly often during their lifetimes, with
minimal interoperability problems.  Naïvely designed binary
protocols are, by contrast, notoriously brittle.
</p>
<h4 id="id2908915"><a href="#id2908915">§</a>HTTP as a Universal Application Protocol</h4>
<p>
  Ever since the World Wide Web reached critical mass around 1993, 
application protocol designers have shown an increasing tendency to
layer their special-purpose protocols on top of HTTP, using web servers
as generic service platforms.
</p>
<p>
  This is a viable option because, at the transaction layer, HTTP is very simple and general.  An HTTP request is a
  message in an RFC-822/MIME-like format; typically, the headers contain identification and authentication information,
  and the first line is a method call on some resource specified by a Universal Resource Indicator (URI).  The most
  important methods are GET (fetch the resource), PUT (modify the resource) and POST (ship data to a form or back-end
  process). The most important form of URI is a URL or Uniform Resource Locator, which identifies the resource by
  service type, host name, and a location on the host.  An HTTP response is simply an RFC-822/MIME message and can
  contain arbitrary content to be interpreted by the client.
</p>
<p>
  Web servers handle the transport and request-multiplexing layers
of HTTP, as well as standard service types like http and ftp.  It is
relatively easy to write web server plugins that will handle custom
service types, and to dispatch on other elements of the URI format.
</p>
<p>
  Besides avoiding a lot of lower-level details, this method means
the application protocol will tunnel through the standard HTTP service
port and not need a
TCP/IP
  service port of
its own.  This can be a distinct advantage; most firewalls leave port 80
open, but trying to punch another hole through can be fraught with
both technical and political difficulties.
</p>
<p>
  With this advantage comes a risk.  It means that your web server 
and its plugins grow more complex, and cracks in any of that code can
have large security implications.  It may become more difficult to
isolate and shut down problem services.  The usual tradeoffs between 
security and convenience apply.
</p>
<p>
  RFC 3205,
  <em>On the Use of HTTP As a Substrate</em>,<sup><a href="#ftn.id2909002" id="id2909002">[56]</a></sup>
  has good design advice for anyone
considering using HTTP as the underlayer of an application
protocol, including a summary of the tradeoffs and problems involved.
</p>
<h5 id="id2909019"><a href="#id2909019">§</a>Case Study: The CDDB/freedb.org Database</h5>
<p>
  Audio CDs consist of a sequence of music tracks in a digital
format called CDDA-WAV.  They were designed to be played by very simple
consumer-electronics devices a few years before general-purpose
computers developed enough raw speed and sound capability to decode
them on the fly.  Because of this, there is no provision in the 
format for even simple metainformation such as the album and track
titles.  But modern computer-hosted CD players want this information so
the user can assemble and edit play lists.
</p>
<p>
  Enter the Internet.  There are (at least two) repositories that
provide a mapping between a hash code computed from the track-length
table on a CD and artist/album-title/track-title records.  The
original was
  <code>cddb.org</code>, but
another site called
  <code>freedb.org</code> which is probably now more
complete and widely used.  Both sites rely on their users for the
enormous task of keeping the database current as new CDs come out;
  <code>freedb.org</code> arose from a
developer revolt after CDDB elected to take all that user-contributed
information proprietary .
</p>
<p>
  Queries to these services could have been implemented as a
custom application protocol on top of TCP/IP, but that would have
required steps such as getting a new TCP/IP port number assigned and
fighting to get a hole for it punched through thousands of firewalls.
Instead, the service is implemented over HTTP as a simple CGI query
(as if the CD's hash code had been supplied by a user filling in a Web
form).
</p>
<p>
  This choice makes all the existing infrastructure of HTTP and
Web-access libraries in various programming languages available to
support programs for querying and updating this database.  As a
result, adding such support to a software CD player is nearly trivial,
and effectively every software CD player knows how to use them.
</p>
<h5 id="id2909113"><a href="#id2909113">§</a>Case Study: Internet Printing Protocol</h5>
<p>
  Internet Printing Protocol (IPP) is a successful, widely implemented
standard for the control of network-accessible printers.  Pointers to
RFCs, implementations, and much other related material are available
at the IETF's
  <a href="http://www.pwg.org/ipp/">
   Printer Working
Group</a>
  site.
</p>
<p>
  IPP uses HTTP 1.1 as a transport layer.  All IPP requests are
passed via an HTTP POST method call; responses are ordinary HTTP
responses. (Section 4.2 of RFC 2568,
  <em>Rationale for the Structure of the Model and Protocol for the Internet Printing Protocol</em>, does an excellent job of explaining this
choice; it repays study by anyone considering writing a new application
protocol.)
</p>
<p>
  From the software side, HTTP 1.1 is widely deployed.  It already
solves many of the transport-level problems that would otherwise
distract protocol developers and implementers from concentrating on
the domain semantics of printing.  It is cleanly extensible, so there
is room for IPP to grow.  The CGI programming model for handling the
POST requests is well understood and development tools are widely
available.
</p>
<p>
  Most network-aware printers already embed a web server, because
that's the natural way to make the status of the printer remotely 
queryable by human beings.  Thus, the incremental cost of adding IPP
service to the printer firmware is not large.  (This is an argument
that could be applied to a remarkably wide range of other
network-aware hardware, including vending machines and coffee makers<sup><a href="#ftn.id2909179" id="id2909179">[57]</a></sup>
  and hot tubs!)
</p>
<p>
  About the only serious drawback of layering IPP over HTTP is
that the protocol is completely driven by client requests.  Thus there
is no space in the model for printers to ship asynchronous alert
messages back to clients.  (However, smarter clients could run a
trivial HTTP server to receive such alerts formatted as HTTP requests
from the printer.)
</p>
<h4 id="id2909217"><a href="#id2909217">§</a>BEEP: Blocks Extensible Exchange Protocol</h4>
<p>
  BEEP (formerly BXXP) is a generic protocol machine that competes
with HTTP for the role of universal underlayer for application
protocols.  There is a niche open because there is not as yet
any other more established metaprotocol that is appropriate for truly
peer-to-peer applications, as opposed to the client-server
applications that HTTP handles well.  A
  <a href="http://www.beepcore.org/beepcore/docs/sl-beep.jsp">
   project
website</a>
  provides access to standards and open-source
implementations in several languages.
</p>
<p>
  BEEP has features to support both client-server and peer-to-peer
modes.  The authors designed the BEEP protocol and support library so
that picking the right options abstracts away messy issues like data
encoding, flow control, congestion-handling, support of end-to-end
encryption, and assembling a large response composed of multiple
transmissions,
</p>
<p>
  Internally, BEEP peers exchange sequences of self-describing
binary packets not unlike chunk types in
PNG.  The design is tuned
more for economy and less for
transparency
  than the classical Internet protocols or HTTP, and might be a better
choice when data volumes are large.  BEEP also avoids the HTTP problem
that all requests have to be client-initiated; it would be better in
situations in which a server needs to send asynchronous status messages
back to the client.
</p>
<p>
  BEEP is still new technology in mid-2003, and has only a few
demonstration projects.  But the BEEP papers are good analytical
surveys of best practice in protocol design; even if BEEP itself fails
to gain widespread adoption, the papers will retain considerable tutorial
value.
</p>
<h4 id="id2909294"><a href="#id2909294">§</a>XML-RPC, SOAP, and Jabber</h4>
<p>
  There is a developing trend in application protocol design
toward using XML within
MIME
  to structure
requests and payloads.  BEEP peers use this format for channel
negotiations.  Three major protocols are going the XML route
throughout: XML-RPC and SOAP (Simple Object Access Protocol) for
remote procedure calls, and Jabber for instant messaging and presence.
All three are XML document types.
</p>
<p>
  XML-RPC is very much in the Unix spirit (its author observes
that he learned how to program in the 1970s by reading the original
source code for Unix). It's deliberately minimalist but nevertheless
quite powerful, offering a way for the vast majority of RPC
applications that can get by on passing around scalar
boolean/integer/float/string datatypes to do their thing in a way that
is lightweight and easy to understand and monitor. XML-RPC's type
ontology is richer than that of a text stream, but still simple and
portable enough to act as a valuable check on interface
complexity. Open-source implementations are available. An excellent
  <a href="http://www.xmlrpc.com/">
   XML-RPC home page</a>
  points to
specifications and multiple open-source implementations.
</p>
<p>
  SOAP is a more heavyweight RPC protocol with a richer type
ontology that includes arrays and C-like structs.  It was inspired by
XML-RPC, but has been plausibly accused of being an overdesigned
victim of the second-system effect.  As of mid-2003 the SOAP
standard is still a work in progress, but a trial implementation in
Apache
  is tracking the
drafts.  Open-source client modules in Perl, Python, Tcl, and Java
  are readily discoverable by a Web
search.  The W3C draft specification is
  <a href="http://www.w3.org/TR/SOAP/">
   available on the Web</a>.
</p>
<p>
  XML-RPC and SOAP, considered as remote procedure call methods,
have some associated risks that we discuss at the end of
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>.
</p>
<p>
  Jabber is a peer-to-peer protocol designed to support instant
messaging and presence.  What makes it interesting as an application
protocol is that it supports passing around XML forms and live
documents. Specifications, documentation, and open-source
implementations are available at the
  <a href="http://www.jabber.org/about/overview.html">
   Jabber
Software Foundation</a>
  site.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2908849" id="ftn.id2908849">[55]</a></sup>
  See
  <a href="ftp://ftp.rfc-editor.org/in-notes/rfc3117.txt">
   RFC
3117</a>.
</p>

<p><sup><a href="#id2909002" id="ftn.id2909002">[56]</a></sup>
  See
  <a href="http://www.faqs.org/rfcs/rfc3205.html">
   RFC
3205</a>.
</p>

<p><sup><a href="#id2909179" id="ftn.id2909179">[57]</a></sup>
  See
  <a href="http://www.ietf.org/rfc/rfc2324.txt">
   RFC 2324</a>
  and
  <a href="http://www.ietf.org/rfc/rfc2325.txt">
   RFC 2325</a>.
</p>
</div>


<!-- FILE: transparencychapter.html -->
<h3 id="transparencychapter"><a href="#transparencychapter">§</a>Chapter 6. Transparency</h3>
 <blockquote class="epigraph">
  <p>
   Beauty is more important in
computing than anywhere else in technology because software is so
complicated. Beauty is the ultimate defense against complexity.
  </p>
  <span>
   – David Gelernter
Machine Beauty: Elegance and the Heart of Technology (1998)
  </span>
 </blockquote>
<p>
  In the previous chapter we discussed the importance of
textual data formats and application protocols, representations that
are easy for human beings to examine and interact with.  These promote
qualities in design that are much valued in the Unix tradition but
seldom if ever talked about explicitly:
  <em>transparency</em> and
  <em>discoverability</em>.
</p>
<p>
  Software systems are transparent when they don't have murky
corners or hidden depths.  Transparency is a passive quality.  A
program is transparent when it is possible to form a simple mental
model of its behavior that is actually predictive for all or most
cases, because you can see through the machinery to what is actually
going on.
</p>
<p>
  Software systems are discoverable when they include features
that are designed to help you build in your mind a correct mental
model of what they do and how they work.  So, for example, good
documentation helps discoverability to a user.  Good choice of
variable and function names helps discoverability to a
programmer. Discoverability
  is an active quality. To achieve it in your software you cannot merely
fail to be obscure, you have to go out of your way to be helpful.<sup><a href="#ftn.id2911508" id="id2911508">[58]</a></sup>
</p>
<p>
  Transparency and discoverability are important for both users
and software developers. But they're important in different ways.
Users like these properties in a UI because they mean an easier
learning curve.  UI transparency and discoverability are a large part
of what people mean when they say a UI is ‘intuitive’;
most of the rest is the Rule of Least Surprise.  We'll examine the
properties that make user interfaces pleasant and effective in more
depth in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>.
</p>
<p>
  Software developers like these qualities in the code itself (the
part users don't see) because they so often need to understand it well
enough to modify and debug it.  Also, a program designed so that its
internal data flows are readily comprehensible is more likely to be
one that does not fail because of bad interactions that the designer
didn't notice, and more likely to be able to evolve forward gracefully
(including accommodating change when new maintainers pick up the
baton).
</p>
<p>
  Transparency is a major component of what David
Gelernter
  refers to as “beauty” in this chapter's epigraph.  Unix
programmers, borrowing from mathematicians, often use the more
specific term “elegance” for the quality Gelernter speaks
of.  Elegance is a combination of power and simplicity.  Elegant code
does much with little.  Elegant code is not only correct but visibly,
  <em>transparently</em>
  correct.  It does not merely
communicate an algorithm to a computer, but also conveys insight and
assurance to the mind of a human that reads it.  By seeking elegance
in our code, we build better code.  Learning to write transparent code
is a first, long step toward learning how to write elegant code
— and taking care to make code discoverable helps us learn how
to make it transparent.  Elegant code is both transparent and
discoverable.
</p>
<p>
  It may be easier to appreciate the difference between
transparency and discoverability with a pair of extreme examples.  The
Linux
  kernel source is remarkably transparent (given the intrinsic
complexity of what it does) but not at all discoverable —
acquiring the minimum knowledge needed to live in the code and
understand the idiom of the developers is difficult, but once you do
the whole makes sense.<sup><a href="#ftn.id2911617" id="id2911617">[59]</a></sup>
  On the other hand, the
Emacs Lisp libraries are discoverable but not transparent.  It's easy
to acquire enough knowledge to tweak just one thing, but quite
difficult to comprehend the whole system.
</p>
<p>
  In this chapter, we'll examine features of Unix designs that
promote transparency and discoverability not just in UIs but in the
parts users don't normally see.  We'll develop some useful rules you
can apply to your coding and development practice.  Later on, in
  <a href="#opensourcechapter" title="Chapter 19. Open Source">
   Chapter 19</a>
  we'll see how good release-engineering
practices (like having a
  <code>README</code> file with
appropriate content) can make your source code as discoverable as your
design.
</p>
<p>
  If you need a practical reminder why these qualities are
important, remember that the sanity you save by writing transparent,
discoverable systems may well be that of your own future self.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2911508" id="ftn.id2911508">[58]</a></sup>
  An economically-minded friend comments: “Discoverability is
about reducing barriers to entry; transparency is about reducing the 
cost of living in the code”.
</p>

<p><sup><a href="#id2911617" id="ftn.id2911617">[59]</a></sup>
  The Linux kernel makes a number
of attempts at discoverability, including the Documentation
subdirectory in the Linux kernel source tarball and quite a number of
tutorial websites and books.  These attempts are frustrated by the
speed at which the kernel changes; the documentation has a chronic
tendency to fall behind.
</p>
</div>


<!-- FILE: ch06s01.html -->
<h3 id="ch06s01"><a href="#ch06s01">§</a>Studying Cases</h3>
<p>
  Normal practice in this book has been to intersperse case studies with
philosophy.  But in this chapter we'll begin by looking at several
Unix designs that exhibit transparency and discoverability, and
attempt to draw lessons from them only after all have been
presented.  Each major point of the analysis in the latter half of this
chapter draws on several of these, and the arrangement avoids forward
references to case studies the reader hasn't seen yet.
</p>
<h4 id="audacity"><a href="#audacity">§</a>Case Study: audacity</h4>
<p>
  First, we'll look at an example of transparency in UI design.  It
is
  <em>audacity</em>, an open-source editor for
sound files that runs on Unix systems, Mac OS X, and Windows.
Sources, downloadable binaries, documentation, and screen shots are
available at the
  <a href="http://audacity.sourceforge.net/">
   project site</a>.
</p>
<p>
  This program supports cutting, pasting, and editing of audio
samples. It supports multitrack editing and mixing.  The UI is
superbly simple; the sound waveforms are shown in the
  <em>audacity</em> window. The image of the
waveform can be cut and pasted; operations on that image are directly
reflected in the audio sample as soon as they are performed.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 6.1. Screen shot of
    <em>audacity</em>.
   </b>
  </p>
  <div class="center">
   <img alt="Screen shot of audacity." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  Multitrack editing is supported in the simplest possible way;
the screen splits into multiple per-track displays in a spatial
relationship that conveys their concurrency and makes it easy to 
match features by inspection.  Tracks can be dragged right or
left with the mouse to change their relative timing.
</p>
<p>
  Several features of this UI are subtly excellent and worthy of
emulation: the large, easily visible and clickable operation 
buttons with distinguishing colors, the presence of an undo command
that removes most of the risk from experimentation, the volume slider
that makes softness/loudness visually obvious in its shape.
</p>
<p>
  But these are details.  The central virtue of this program is
that it has a superbly transparent and natural user interface, one that
erects as few barriers between the user and the sound file as
possible.
</p>
<h4 id="fetchmail_v"><a href="#fetchmail_v">§</a>Case Study: fetchmail's -v option</h4>
<p>
  <em>fetchmail</em> is a network gateway program. Its main purpose is to translate between
POP3 or IMAP remote-mail protocols and the Internet's native SMTP
protocol for email exchange. It is in extremely widespread use on Unix
machines that use intermittent SLIP or PPP connections to Internet
service providers, and as such probably touches an appreciable
fraction of the Internet's mail traffic.
</p>
<p>
  <em>fetchmail</em> has no fewer than 60
command-line options (which, as we'll establish later in this book, is
probably too many), and a number of other options that are settable
from the run-control file but not from the command line.  Of all
these, the most important — by far — is
  <code>-v</code>, the verbose option.
</p>
<p>
  When
  <code>-v</code> is on,
  <em>fetchmail</em> dumps each one of its POP, IMAP, and SMTP transactions to standard output as they happen.  A
  developer can actually see the code doing protocol with remote mailservers and the mail transport program it forwards
  to, in real time.  Users can send session transcripts with their bug reports. Example 6.1 shows a representative
  session transcript.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 6.1. An example
    <em>fetchmail</em> <code>-v</code> transcript.
   </b>
  </p>
  <pre class="programlisting">
fetchmail: 6.1.0 querying hurkle.thyrsus.com (protocol IMAP) 
              at Mon, 09 Dec 2002 08:41:37 -0500 (EST): poll started
fetchmail: running ssh %h /usr/sbin/imapd 
              (host hurkle.thyrsus.com service imap)
fetchmail: IMAP&lt; * PREAUTH [42.42.1.0] IMAP4rev1 v12.264 server ready
fetchmail: IMAP&gt; A0001 CAPABILITY
fetchmail: IMAP&lt; * CAPABILITY IMAP4 IMAP4REV1 NAMESPACE IDLE SCAN 
              SORT MAILBOX-REFERRALS LOGIN-REFERRALS AUTH=LOGIN 
              THREAD=ORDEREDSUBJECT
fetchmail: IMAP&lt; A0001 OK CAPABILITY completed
fetchmail: IMAP&gt; A0002 SELECT "INBOX"
fetchmail: IMAP&lt; * 2 EXISTS
fetchmail: IMAP&lt; * 1 RECENT
fetchmail: IMAP&lt; * OK [UIDVALIDITY 1039260713] UID validity status
fetchmail: IMAP&lt; * OK [UIDNEXT 23982] Predicted next UID
fetchmail: IMAP&lt; * FLAGS (\Answered \Flagged \Deleted \Draft \Seen)
fetchmail: IMAP&lt; * OK [PERMANENTFLAGS 
               (\* \Answered \Flagged \Deleted \Draft \Seen)] 
               Permanent flags
fetchmail: IMAP&lt; * OK [UNSEEN 2] first unseen in /var/spool/mail/esr
fetchmail: IMAP&lt; A0002 OK [READ-WRITE] SELECT completed
fetchmail: IMAP&gt; A0003 EXPUNGE
fetchmail: IMAP&lt; A0003 OK Mailbox checkpointed, no messages expunged
fetchmail: IMAP&gt; A0004 SEARCH UNSEEN
fetchmail: IMAP&lt; * SEARCH 2
fetchmail: IMAP&lt; A0004 OK SEARCH completed
2 messages (1 seen) for esr at hurkle.thyrsus.com.
fetchmail: IMAP&gt; A0005 FETCH 1:2 RFC822.SIZE
fetchmail: IMAP&lt; * 1 FETCH (RFC822.SIZE 2545)
fetchmail: IMAP&lt; * 2 FETCH (RFC822.SIZE 8328)
fetchmail: IMAP&lt; A0005 OK FETCH completed
skipping message esr@hurkle.thyrsus.com:1 (2545 octets) not flushed
fetchmail: IMAP&gt; A0006 FETCH 2 RFC822.HEADER
fetchmail: IMAP&lt; * 2 FETCH (RFC822.HEADER {1586}
reading message esr@hurkle.thyrsus.com:2 of 2 (1586 header octets)
fetchmail: SMTP&lt; 220 snark.thyrsus.com ESMTP Sendmail 8.12.5/8.12.5; 
               Mon, 9 Dec
2002 08:41:41 -0500</pre>
  <pre class="programlisting">fetchmail: SMTP&gt; EHLO localhost
fetchmail: SMTP&lt; 250-snark.thyrsus.com 
               Hello localhost [127.0.0.1], pleased to meet you
fetchmail: SMTP&lt; 250-ENHANCEDSTATUSCODES
fetchmail: SMTP&lt; 250-8BITMIME
fetchmail: SMTP&lt; 250-SIZE
fetchmail: SMTP&gt; MAIL FROM:&lt;mutt-dev-owner@mutt.org&gt; SIZE=8328
fetchmail: SMTP&lt; 250 2.1.0 &lt;mutt-dev-owner@mutt.org&gt;... Sender ok
fetchmail: SMTP&gt; RCPT TO:&lt;esr@localhost&gt;
fetchmail: SMTP&lt; 250 2.1.5 &lt;esr@localhost&gt;... Recipient ok
fetchmail: SMTP&gt; DATA
fetchmail: SMTP&lt; 354 Enter mail, end with "." on a line by itself
#
fetchmail: IMAP&lt; )
fetchmail: IMAP&lt; A0006 OK FETCH completed
fetchmail: IMAP&gt; A0007 FETCH 2 BODY.PEEK[TEXT]
fetchmail: IMAP&lt; * 2 FETCH (BODY[TEXT] {6742}
 (6742 body octets) *********************.**************************.
********************************.************************.***********
**********.***********************.***************
fetchmail: IMAP&lt; )
fetchmail: IMAP&lt; A0007 OK FETCH completed
fetchmail: SMTP&gt;. (EOM)
fetchmail: SMTP&lt; 250 2.0.0 gB9ffWo08245 Message accepted for delivery
 flushed
fetchmail: IMAP&gt; A0008 STORE 2 +FLAGS (\Seen \Deleted)
fetchmail: IMAP&lt; * 2 FETCH (FLAGS (\Recent \Seen \Deleted))
fetchmail: IMAP&lt; A0008 OK STORE completed
fetchmail: IMAP&gt; A0009 EXPUNGE
fetchmail: IMAP&lt; * 2 EXPUNGE
fetchmail: IMAP&lt; * 1 EXISTS
fetchmail: IMAP&lt; * 0 RECENT
fetchmail: IMAP&lt; A0009 OK Expunged 1 messages
fetchmail: IMAP&gt; A0010 LOGOUT
fetchmail: IMAP&lt; * BYE hurkle IMAP4rev1 server terminating connection
fetchmail: IMAP&lt; A0010 OK LOGOUT completed
fetchmail: 6.1.0 querying hurkle.thyrsus.com (protocol IMAP) 
               at Mon, 09 Dec 2002 08:41:42 -0500: poll completed
fetchmail: SMTP&gt; QUIT
fetchmail: SMTP&lt; 221 2.0.0 snark.thyrsus.com closing connection
fetchmail: normal termination, status 0
</pre>
 </div>
<p>
  The
  <code>-v</code> option makes what
  <em>fetchmail</em> is doing discoverable (by letting you
see the protocol exchanges).  This is
  <em>immensely</em>
  useful.  I considered it so important that I wrote special code to
mask account passwords out of
  <code>-v</code> transaction dumps so
that they could be passed around and posted without anyone having to
remember to edit sensitive information out of them.
</p>
<p>
  This turned out to be a good call.  At least eight out of ten
problems reported get diagnosed within seconds of a knowledgeable
person's eyes seeing a session transcript.  There are several
knowledgeable people on the fetchmail mailing list — in fact,
because most bugs are easy to diagnose, I seldom have to
handle them myself.
</p>
<p>
  Over the years,
  <em>fetchmail</em> has
acquired a reputation as a rather bulletproof program.  It can be
misconfigured, but it very seldom outright breaks.  Betting that this
has nothing to do with the fact that the exact circumstances of eight
out of ten bugs are rapidly discoverable would not be smart.
</p>
<p>
  We can learn from this example.  The lesson is this:  Don't
let your debugging tools be mere afterthoughts or treat them as
throwaways.  They are your windows into the code; don't just knock
crude holes in the walls, finish and glaze them.  If you plan to 
keep the code maintained, you're always going to need to let light
into it.
</p>
<h4 id="id2909841"><a href="#id2909841">§</a>Case Study: GCC</h4>
<p>
  GCC, the GNU C compiler used on most modern Unixes, is perhaps
an even better example of engineering for transparency.  GCC is
organized as a sequence of processing stages knit together by a 
driver program.  The stages are: preprocessor, parser, code 
generator, assembler, and linker.
</p>
<p>
  Each of the first three stages takes in a readable textual
format and emits a readable textual format (the assembler has to emit
and the linker to accept binary formats, pretty much by definition).
With various command-line options of the
gcc(1)
driver, you can see not just the results after C preprocessing, after
assembly generation, and after object code generation — but you
can also monitor the results of many intermediate steps in parsing and
code generation.
</p>
 <blockquote>
  <p>
   This is exactly the structure of cc, the first (PDP-11) C
compiler.
  </p>
  <span>
   – Ken Thompson
  </span>
 </blockquote>
<p>
  There are many benefits of this organization.  One that is
particularly important for GCC is regression
testing.<sup><a href="#ftn.id2909913" id="id2909913">[60]</a></sup>
  Because most
of the various intermediate formats are textual, deviations from
expected results in a regression test are easily spotted and analyzed
using simple textual diff operations on the intermediate results;
there is no need for specialist dump-analysis tools that may well
harbor their own bugs, and in any case would represent an additional
maintenance burden.
</p>
<p>
  The design pattern to extract from this example is that the
driver program has monitoring switches that merely (but sufficiently)
expose the textual data flows among the components.  As with
  <em>fetchmail's</em> <code>-v</code> option,
these options are not afterthoughts; they are designed in for
discoverability.
</p>
<h4 id="id2909954"><a href="#id2909954">§</a>Case Study: kmail</h4>
<p>
  <em>kmail</em> is the GUI mailreader
distributed with the KDE environment.  The
  <em>kmail</em> UI is tastefully and well designed,
with many good features including automatic display of enclosed images
in a MIME
  multipart and
support for PGP key encryption/decryption.  It is friendly to
end-users — my beloved but nontechie wife uses and
enjoys it.
</p>
<p>
  Many mail user agents make one gesture in the direction of
discoverability
  by having a command that toggles display of all the mail headers,
as opposed to a select few like From and Subject.  The UI of
  <em>kmail</em> takes this a long step
further.
</p>
<p>
  A running
  <em>kmail</em> displays status
notifications in a one-line subwindow at the bottom of its window, in
small type over a steel-gray background clearly modeled on the
Netscape/Mozilla status bar.  When you open a mailbox, for example,
the status bar displays counts of total and unread messages.  The
visual presentation is unobtrusive; it is easy to ignore the
notifications, but also easy to focus on them if you want to.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 6.2. Screen shot of
    <em>kmail</em>.
   </b>
  </p>
  <div class="center">
   <img alt="Screen shot of kmail." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  The
  <em>kmail</em> GUI is good user-interface
design. It's informative, but not distracting; it gets around the
reason we adduce in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>
  that the best policy for Unix tools
operating normally is usually silence.  The authors showed excellent
taste in borrowing the look and feel of the browser status bar.
</p>
<p>
  But the extent of the
  <em>kmail</em> developers' tastefulness will not become clear until you have to
troubleshoot an installation that is having trouble sending mail.  If
you watch closely during the send, you will observe that each line of
the SMTP transaction with the remote mail transport is echoed into the
  <em>kmail</em> status bar as it happens.
</p>
<p>
  The
  <em>kmail</em> developers neatly avoid a
trap that often makes GUI programs like
  <em>kmail</em> a terrible pain in a troubleshooter's
fundament.  Most design teams with kmail's objectives would have
suppressed those messages entirely, fearing that they would give Aunt
Tillie a touch of the vapors that would drive her back to the
meretricious pseudo-simplicity of a Windows box.
</p>
<p>
  Instead, they designed for transparency — they made the
transaction messages show, but also made them visually easy to ignore.
By getting the presentation right, they managed to please both Aunt
Tillie and her geeky nephew Melvin who fixes her computer problems.
This was brilliant; it's a technique other GUI interfaces could and
should emulate.
</p>
<p>
  Ultimately, of course, the visibility of those messages is good
for Aunt Tillie, because they mean Melvin is far less likely to throw
up his hands in frustration while trying to solve her email
problems.
</p>
<p>
  The lesson here is clear.  Dumbing down your UI is only the
half-smart thing to do.  The really smart thing is to find a way 
to leave the details accessible, but make them unobtrusive.
</p>
<h4 id="id2910193"><a href="#id2910193">§</a>Case Study: SNG</h4>
<p>
  The program
  <em>sng</em> translates between
PNG
  format and an
all-text representation of it (SNG or Scriptable Network Graphics
format) that can be examined and modified with an ordinary text
editor.  Run on a PNG file, it produces an SNG file; run on an SNG
file, it recovers the equivalent PNG.  The transformation is 100%
faithful and lossless in both directions.
</p>
<p>
  In syntactic style, SNG resembles CSS (Cascading Style Sheets),
another language for controlling presentation of graphics; this makes
at least a gesture in the direction of the Rule of Least
Surprise. Here is a test example:
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 6.2. An SNG Example.
   </b>
  </p>
  <pre class="programlisting">
#SNG: This is a synthetic SNG test file

# Our first test is a paletted (type 3) image.
IHDR: {
        width: 16;
        height: 19;
        bitdepth: 8;
        using color: palette; 
        with interlace;
}

# Sample bit depth chunk
sBIT: {
  red: 8;
  green: 8;
  blue: 8;
}

# An example palette: three colors, one of which 
# we will render transparent 
PLTE: {
   (0,     0, 255)
   (255,   0,   0)
   "dark slate gray",
}</pre>
  <pre class="programlisting"># Suggested palette
sPLT {
   name: "A random suggested palette";
   depth: 8;
   (0,     0, 255), 255, 7;
   (255,   0,   0), 255, 5;
   ( 70,  70,  70), 255, 3;
}

# The viewer will actually use this...
IMAGE: {
   pixels base64
2222222222222222
2222222222222222
0000001111100000
0000011111110000
0000111001111000
0001110000111100
0001110000111100
0000110001111000
0000000011110000
0000000111100000
0000001111000000
0000001111000000
0000000000000000
0000000110000000
0000001111000000
0000001111000000
0000000110000000
2222222222222222
2222222222222222
}

tEXt: {                                # Ordinary text chunk
  keyword: "Title";
  text: "Sample SNG script";
}

# Test file ends here
</pre>
 </div>
<p>
  The point of this tool is to enable users to edit various
obscure PNG
  chunk types
that are not necessarily supported by conventional graphics editors.
Rather than writing special-purpose code to grovel through the PNG
binary format, the user can simply flip an image into an all-text
representation, edit that, and massage it back.  Another potential
application is in making images amenable to version control; under
most version-control systems, text files are much easier to manage
than binary blobs, and diff operations on SNG representations actually
have some possibility of yielding useful information.
</p>
<p>
  The gains here go beyond the time not spent writing
special-purpose code for manipulating binary PNGs, however. The code
of the
  <em>sng</em> program itself is not especially
transparent, but it promotes transparency in larger systems of
programs by making the entire contents of PNGs
discoverable.
</p>
<h4 id="id2910334"><a href="#id2910334">§</a>Case Study: The Terminfo Database</h4>
<p>
  The terminfo database is a collection of descriptions of
video-display terminals.  Each entry describes the escape sequences 
that perform various manipulations on the terminal screen, such as
inserting or deleting lines, erasing from the cursor position to end
of line or screen, or beginning and ending screen highlights such
as reverse video, underline, or blink.
</p>
<p>
  The terminfo database is primarily used by the
curses(3)
libraries.  These underlie the “roguelike” interface
style we discuss in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>, and some very widely used programs such
as
mutt(1),
lynx(1),
and
slrn(1).
Though the terminal emulators such as
xterm(1)
that run on today's bitmapped displays all have capabilities that are
minor variations on those of the ANSI X3.64 standard and the venerable
VT100 terminal, there is still enough variation that hardwiring ANSI
capabilities into applications would be a bad idea.  Terminfo is also
worth studying because problems that are logically similar to the one
it addressed arise constantly in managing other kinds of peripheral
hardware that doesn't have a standard way to report their own
capabilities.
</p>
<p>
  The design of terminfo benefits from experience with an earlier capability format called termcap.  The database of
  termcap descriptions lived in a textual format in one big file, <code>/etc/termcap</code>; though this format is now
  obsolete, your Unix system almost certainly includes a copy.
</p>
<p>
  Normally, the key used to look up your terminal type entry is
the environment variable
  <code>TERM</code>, which for purposes of
this case study is set by magic.<sup><a href="#ftn.id2910448" id="id2910448">[61]</a></sup>
  Applications that
use terminfo (or termcap) pay a small penalty in startup lag; when the
curses(3)
library initializes itself, it has to look up the entry corresponding
to
  <code>TERM</code> and load the entry into memory.
</p>
<p>
  Experience with termcap showed that the startup penalty was
dominated by the time required to parse the textual representation of
capabilities. Accordingly, terminfo entries are binary structure dumps
that can be marshaled and unmarshaled more quickly.  There is a master
textual format for the entire database, the terminfo capability file.
That file (or individual entries) can be compiled to binary form with
the terminfo compiler
tic(1);
binary entries can be decompiled to the editable text format by
infocmp(1).
</p>
<p>
  The design superficially contradicts the advice we gave in
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>
  against binary
caches, but this is actually the extreme case in which that's a good
tactic.  Edits to the text masters are very rare — in fact,
Unixes normally ship with the terminfo database precompiled and the
text master serving primarily as documentation.  Thus, the
synchronization and inconsistency problems that would normally
militate against this approach almost never arise.
</p>
<p>
  The designers of terminfo could have optimized for speed
in a second way.  The entire database of binary entries could have
been put in some kind of big opaque database file.  What they actually did
instead was more clever and more in the Unix spirit.  Terminfo entries
live in a directory hierarchy, usually on modern Unixes under
  <code>/usr/share/terminfo</code>.  Consult the
terminfo(5)
man page to find the location on your system.
</p>
<p>
  If you look in the terminfo directory, you'll see subdirectories
named by single printable characters.  Under each of these are the
entries for each terminal type that has a name beginning with that
letter.  The goal of this organization was to avoid having to do a
linear search of a very large directory; under more modern Unix
file systems, which represent directories with B-trees or other
structures optimized for fast lookup, the subdirectories won't be
necessary.
</p>
 <blockquote>
  <p>
   I found that even on a fairly modern Unix, splitting a big directory up
into subdirectories can improve performance substantially.  It was tens
of thousands of files, an authorized-user database for a big educational
institution, on a late-model DEC Alpha running DEC's Unix.  (Subdirectories
named by first and last letter of name — e.g., "johnson" would be in
directory "j_n" — worked best of the schemes we tested.  Using the first
two letters wasn't nearly as good, because there were a lot of
systematically-generated names which differed only toward the end.)
This may just say that sophisticated directory indexing is still not as
common as it should be... but even so, that makes an organization which
works well without it more portable than one which requires it.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  Thus, the cost of opening a terminfo entry is two file system
lookups and a file open.  But since mining the same entry from one
big database would have required a lookup and open for the database,
the incremental cost for terminfo's organization is at most one
file system lookup.  Actually, it's less than that; it's the cost
difference between one file system lookup and whatever retrieval method
the one big database would have used.  This is probably marginal, and
quite tolerable once per application at startup time.
</p>
<p>
  Terminfo uses the file system itself as a simple hierarchical
database.  This is a superb bit of constructive laziness, obeying the
Rule of Economy and the Rule of Transparency.  It means that all the
ordinary tools for navigating, examining and modifying the file system
can be used to navigate, examine, and modify the terminfo database; no
special ones (other than
tic(1)
and
infocmp(1)
for packing and unpacking the individual records) need to be written
and debugged.  It also means that work on speeding up database access
would be work on speeding up the file system itself, tuning that would
benefit many more applications than just users of
curses(3).
</p>
<p>
  There is one additional advantage of this organization that
doesn't come up in the terminfo case; you get to use Unix's
permissions mechanism rather than having to invent your own
access-control layer with its own bugs.  This falls out as a
consequence of adopting the “everything is a file”
philosophy of Unix rather than trying to fight it.
</p>
<p>
  The terminfo directory layout is rather space-inefficient
on most Unix file systems.  The entries are usually between 400 and
1400 bytes long, but file systems normally allocate a minimum of 4K 
for every nonempty disk file. The designers accepted this cost
for the same reason they chose a packed binary format, to
cut the startup latency of terminfo-using programs to a minimum.  Disk 
capacity for constant price has exploded over a thousandfold since,
tending to vindicate that decision.
</p>
<p>
  The contrast with the formats used by the Microsoft Windows
  registry files is instructive.  Registries are property databases used
by both Windows itself and applications.  Each registry lives in one
big file.  Registries contain a mix of text and binary data that
requires specialized editing tools.  The one-big-file approach leads,
among other things, to the notorious ‘registry creep’
phenomenon; average access time rises without bound as new entries are
added.  Because there is no standard API for editing the registry
provided by the system, applications use ad-hoc code to edit it
themselves, making it notoriously subject to corruption that can lock
up the entire system.
</p>
<p>
  Using the Unix file system as a database is a tactic other
applications with simple database requirements might do well to emulate.
Good reasons not to do it are more likely to have to do with the
database keys not naturally looking like filenames than they are with
any performance problems.  In any case, it's the sort of good fast
hack that can be very useful in prototyping.
</p>
<h4 id="id2914115"><a href="#id2914115">§</a>Case Study: Freeciv Data Files</h4>
<p>
  Freeciv is an open-source strategy game inspired by Sid Meier's
classic
  <em>Civilization II</em>.  In it, each player
begins with a wandering band of neolithic nomads and builds a
civilization. Player civilizations may explore and colonize the world,
fight wars, engage in trade, and research technological advances.
Some players may actually be artificial intelligences; solitaire play
against these can be challenging.  One wins either by conquering the
world or by being the first player to reach a technology level sufficient
to get a starship to Alpha Centauri.  Sources and documentation are
available at the
  <a href="http://www.freeciv.org/">
   project
site</a>.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 6.3. Main window of a Freeciv game.
   </b>
  </p>
  <div class="center">
   <img alt="Main window of a Freeciv game." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  In
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  we'll exhibit the Freeciv strategy game as an example of client-server
partitioning, with the server maintaining shared state and the client
concentrating on GUI presentation.  But this game has another notable
architectural feature; much of the game's fixed data, rather than
being wired into the server code, is expressed in a property registry
read in by the game server at startup time.
</p>
<p>
  The game's registry files are written in a textual data-file
format that assembles text strings (with associated text and numeric
properties) into various internal lists of important data (such as
nations and unit types) in the game server.  The minilanguage has an
include directive, so game data can be broken up into semantic units
(different files) that are each separately editable.  This design
choice has been carried through to such an extent that it's possible
to define new nations and new unit types simply by creating new
declarations in the data files, without touching the server code at
all.
</p>
<p>
  The Freeciv server's startup parsing has an interesting feature
that creates something of a conflict between two of Unix's design
rules, and is therefore worth closer examination.  The server ignores
property names it doesn't know how to use. This makes it possible to
declare properties that the server doesn't yet use without breaking
the startup parsing. It means that development of the game data
(policy) and the server engine (mechanism) can be cleanly separated.
On the other hand, it also means startup parsing won't catch simple
misspellings of attribute names.  This quiet failure seems to violate
the Rule of Repair.
</p>
<p>
  To resolve this conflict, notice that it's the server's job to
  <em>use</em>
  the registry data, but the task of carefully
error-checking that data could be handed off to another program to be run
by human editors each time the registry is modified.  One Unix
solution would be a separate auditing program that analyzes either
a machine-readable specification of the ruleset format or the source
of the server code to determine the set of properties it uses, parses
the Freeciv registry to determine the set of properties it provides,
and prepares a difference report.<sup><a href="#ftn.id2914267" id="id2914267">[62]</a></sup>
</p>
<p>
  The aggregate of all Freeciv data files is functionally similar
to a Windows registry, and even uses a syntax resembling the textual
portions of registries.  But the creep and corruption problems we
noted with the Windows registry don't crop up here because no program
(either within or outside the Freeciv suite)
  <em>writes</em>
  to these files.  It's a read-only
registry edited only by the game's maintainers.
</p>
<p>
  The performance impact of data-file parsing is minimized because
for each file the operation is performed only once, at either 
client or server startup time.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2909913" id="ftn.id2909913">[60]</a></sup>
  Regression testing is a method for detecting
bugs introduced as software is modified.  It consists of periodically
checking the output of the changing software for some fixed test input
against a snapshot of output captured at an earlier stage of the process
and known (or assumed) to be correct.
</p>

<p><sup><a href="#id2910448" id="ftn.id2910448">[61]</a></sup>
  Actually,
  <code>TERM</code> is set by the system at login time.  For actual
terminals on serial lines, the mapping from tty lines to
  <code>TERM</code> values is set from a system configuration file at
boot time; the details vary among Unixes.  Terminal emulators like
xterm(1)
set this variable themselves.
</p>

<p><sup><a href="#id2914267" id="ftn.id2914267">[62]</a></sup>
  The ur-ancestor of 
such validator programs under Unix was
  <em>lint</em>, a validator for C code separate from
the C compiler. Though GCC has absorbed its functions, old Unix hands
are still apt to refer to the process of running a validator as
‘linting’, and the name survives in utilities such as
  <em>xmllint</em>.
</p>
</div>


<!-- FILE: ch06s02.html -->
<h3 id="ch06s02"><a href="#ch06s02">§</a>Designing for Transparency and Discoverability</h3>
<p>
  To design for transparency and discoverability, you need to
apply every tactic for keeping your code simple, and also concentrate
on the ways in which your code is a communication to other human
beings.  The first questions to ask, after “Will this design
work?” are “Will it be readable to other people?  Is it
elegant?” We hope it is clear by now that these questions are
not fluff and that elegance is not a luxury.  These qualities in the
human reaction to software are essential for reducing its bugginess
and increasing its long-term maintainability.
</p>
<h4 id="zen_of_transparency"><a href="#zen_of_transparency">§</a>The Zen of Transparency</h4>
<p>
  One
pattern that emerges from the examples we've examined so far in this
chapter is this: If you want transparent code, the most effective
route is simply not to layer too much abstraction over what you
are manipulating with the code.
</p>
<p>
  In
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>
  's
section on the value of detachment, our advice was to abstract and
simplify and generalize, to try and detach from the particular,
accidental conditions under which a design problem was posed.  The
advice to abstract does not actually contradict the advice against
excessive abstractions we're developing here, because there is a
difference between getting free of assumptions and forgetting the
problem you're trying to solve.  This is part of what we were driving
at when we developed the idea that glue layers need to be kept
thin.
</p>
<p>
  One of the main lessons of Zen is that we ordinarily see the
world through a haze of preconceptions and fixed ideas that proceed
from our desires.  To achieve enlightenment, we must follow the Zen
teaching not merely to let go of desire and attachment, but to
experience reality exactly as it is — without the preconceptions
and the fixed ideas getting in the way.
</p>
<p>
  This is excellent pragmatic advice for software designers.  It's
part of what's implicit in the classic Unix advice to be minimalist.
Software designers are clever people who form ideas (abstractions)
about the application domains they deal with.  They organize the
software they write around those ideas.  Then, when debugging, they
often find they have great trouble seeing through those ideas to what
is actually going on.
</p>
<p>
  Any Zen master would recognize this problem instantly, yell
“Three pounds of flax!”, and probably clout the student a
good one.<sup><a href="#ftn.id2914429" id="id2914429">[63]</a></sup>
  Consciously
designing for transparency is a slightly less mystical way of
addressing it.
</p>
<p>
  In
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>
  we
criticized object-oriented programming in terms likely to prove a bit
shocking to programmers who were raised on the 1990s gospel of
OO. Object-oriented design doesn't have
to be over-complicated design, but we've observed that too often it
is.  Too many OO designs are spaghetti-like tangles of is-a and has-a
relationships, or feature thick layers of glue in which many of the
objects seem to exist simply to hold places in a steep-sided pyramid
of abstractions.  Such designs are the opposite of transparent; they
are (notoriously) opaque and difficult to debug.
</p>
<p>
  As we've previously noted, Unix programmers are the original
zealots about modularity, but tend to go about it in a quieter way.
Keeping glue layers thin is part of it; more generally, our tradition
teaches us to build lower, hugging the ground with algorithms and
structures that are designed to be simple and transparent.
</p>
<p>
  As with Zen art, the simplicity of good Unix code depends on
exacting self-discipline and a high level of craft, neither of which
are necessarily apparent on casual inspection.  Transparency is hard
work, but worth the effort for more than merely artistic reasons.
Unlike Zen art, software requires debugging — and usually needs
continuing maintenance, forward-porting, and adaptation throughout
its lifetime.  Transparency is therefore more than an esthetic
triumph; it is a victory that will be reflected in lower costs
throughout the software's life cycle.
</p>
<h4 id="id2914509"><a href="#id2914509">§</a>Coding for Transparency and Discoverability</h4>
<p>
  Transparency and
discoverability,
like modularity, are primarily properties of designs, not code.  It is
not sufficient to get right the low-level elements of style, such as
indenting code in a clear and consistent way or having good
variable-naming conventions.  These qualities have much more to do
with code properties that are less obvious to inspection.  Here are a
few to think about:
</p>
 <div>
  <ul>
   <li>
    <p>
     What is the maximum static depth of your procedure-call
hierarchy?  That is, leaving out recursions, how many levels of call
might a human have to model mentally to understand the operation of
the code?  Hint: If it's more than four, beware.
    </p>
   </li>
   <li>
    <p>
     Does the code have invariant properties<sup><a href="#ftn.id2914557" id="id2914557">[64]</a></sup>
     that are both strong and visible?  Invariant
properties help human beings reason about code and detect problem
cases.
    </p>
   </li>
   <li>
    <p>
     Are the function calls in your APIs individually orthogonal, or
do they have too many magic flags and mode bits that have a single call doing
multiple tasks?  Avoiding mode flags entirely can lead to a cluttered
API with too many nigh-identical functions, but the obverse error (lots of
easily-forgotten and confusable mode flags) is even more common.
    </p>
   </li>
   <li>
    <p>
     Are there a handful of prominent data structures or a single
global scoreboard that captures the high-level state of the system?
Is this state easy to visualize and inspect, or is it diffused among
many individual global variables or objects that are hard to
find?
    </p>
   </li>
   <li>
    <p>
     Is there a clean, one-to-one mapping between data structures
or classes in your program and the entities in the world that they 
represent?
    </p>
   </li>
   <li>
    <p>
     Is it easy to find the portion of the code responsible for any
given function? How much attention have you paid to the readability
not just of individual functions and modules but of the whole codebase?
    </p>
   </li>
   <li>
    <p>
     Does the code proliferate special cases or avoid them?  Every
special case could interact with every other special case; all those
potential collisions are bugs waiting to happen. But even more
importantly, special cases make the code harder to understand.
    </p>
   </li>
   <li>
    <p>
     How many magic numbers (unexplained constants) does the code have in
it?  Is it easy to discover the implementation's limits (such as
critical buffer sizes) by inspection?
    </p>
   </li>
  </ul>
 </div>
<p>
  It's best for code to be simple.  But if it answers these sorts
of questions well, it can be very complex without putting an
impossible cognitive burden on a human maintainer.
</p>
<p>
  The reader might find it instructive to compare these with our
checklist questions about modularity in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>.
</p>
<h4 id="id2914680"><a href="#id2914680">§</a>Transparency and Avoiding Overprotectiveness</h4>
<p>
  Close kin to the programmer tendency to build overelaborate
castles of abstractions is a tendency to overprotect others from the
low-level details.  While it's not bad practice to hide those details
in the program's normal mode of operation
(
  <em>fetchmail</em> 's
  <code>-v</code> switch is
off by default), they should be discoverable.  There's an important
difference between hiding them and making them inaccessible.
</p>
<p>
  Programs that
  <em>cannot</em>
  reveal what they are
doing make troubleshooting far more difficult. Thus, experienced Unix
users actually take the presence of debugging and instrumentation
switches as a good sign, and their absence as possibly a bad one.
Absence suggests an inexperienced or careless developer; presence
suggests one with enough wisdom to follow the Rule of
Transparency.
</p>
<p>
  The temptation to overprotect is especially strong in GUI
applications targeted for end users, like mail readers.  One reason 
Unix developers have been cool toward GUI interfaces is that, in
their designers' haste to make them ‘user-friendly’ each one
often becomes frustratingly opaque to anyone who has to solve user problems
— or, indeed, interact with it anywhere outside the narrow
range predicted by the user-interface designer.
</p>
<p>
  Worse, programs that are opaque about what they are doing tend
to have a lot of assumptions baked into them, and to be frustrating or
brittle or both in any use case not anticipated by the designer.
Tools that look glossy but shatter under stress are not good long-term
value.
</p>
<p>
  Unix tradition pushes for programs that are flexible for a 
broader range of uses and troubleshooting situations, including the
ability to present as much state and activity information to the user
as the user indicates he is willing to handle.  This is good for
troubleshooting; it is also good for growing smarter, more
self-reliant users.
</p>
<h4 id="id2914758"><a href="#id2914758">§</a>Transparency and Editable Representations</h4>
<p>
  Another theme that emerges from these examples is the value of
programs that flip a problem out of a domain in which transparency is
hard into one in which it is easy.  Audacity,
sng(1)
and the
tic(1)/infocmp(1)
pair all have this property.  The objects they manipulate are not
readily conformable to the hand and eye; audio files are not visual
objects, and although images expressed in
PNG
  format are visual,
the complexities of PNG annotation chunks are not.  All three
applications turn manipulation of their binary file formats into a
problem to which human beings can more readily apply intuition and
competences gained from everyday experience.
</p>
<p>
  A rule all these examples follow is that they degrade the
representation as little as possible — in fact, they translate
it reversibly and losslessly.  This property is very important, and
worth implementing even if there is no obvious application demand for
that kind of 100% fidelity.  It gives potential users confidence that
they can experiment without degrading their data.
</p>
<p>
  All the advantages of textual data-file formats that we
discussed in
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>
  also apply to the textual formats that
sng(1),
infocmp(1)
and their kin generate.  One important application for
sng(1)
is robotic generation of
PNG
  image annotations by
scripts — because
sng(1)
exists, such scripts are easier to write.
</p>
<p>
  Whenever you face a design problem that involves editing some
kind of complex binary object, the Unix tradition encourages asking
first off whether you can write a tool analogous to
sng(1)
or the
tic(1)/infocmp(1)
pair that can do a lossless mapping to an editable textual format and
back. There is no established term for programs of this kind, but
we'll call them
  <em>textualizers</em>.
</p>
<p>
  If the binary object is dynamically generated or very large,
then it may not be practical or possible to capture all the state with
a textualizer.  In that case, the equivalent task is to write a
browser. The paradigm example is
fsdb(1),
the file-system debugger supported under various Unixes; there is a
Linux equivalent called
debugfs(1).
The
psql(1)
used to browse PostgreSQL databases, and the
smbclient(1)
program that can be used to query Windows file shares on a
SAMBA-equipped Linux machine, are two more.  All five are simple CLI
programs that could be driven by scripts and test harnesses.
</p>
<p>
  Writing a textualizer or browser is a valuable exercise for at
least four reasons:
</p>
 <div>
  <ul>
   <li>
    <p>
     <em>You gain an excellent learning experience.</em>
     There may be other ways that are as good to learn about the structure
of the object, but none that are obviously better.
    </p>
   </li>
   <li>
    <p>
     <em>
      You gain the ability to dump the contents of the structure for
inspection and debugging.
</em>
     Because such a tool makes dumping
easy, you'll do it more. You'll get more information, probably leading
to more insight.
    </p>
   </li>
   <li>
    <p>
     <em>
      You gain the ability to easily generate test loads and unusual 
cases.
</em>
     This means you are more likely to probe the
odd corners of the object's state space — and to break the
associated software, so you can fix it before your users break it.
    </p>
   </li>
   <li>
    <p>
     <em>You gain code you may be able to reuse.</em>
     If you're
careful about how you write the browser/textualizer and keep the CLI
interpreter properly separated from the marshaling/unmarshaling library,
you may find you have code that can be reused for your actual
application.
    </p>
   </li>
  </ul>
 </div>
<p>
  After you've done this, you may well discover that it's possible
to apply the “separated engine and interface” pattern
(see
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>) using
your textualizer/debugger as the engine.  All the usual benefits of
this pattern will apply.
</p>
 <blockquote>
  <p>
   It is desirable, although often difficult, for a textualizer to
be able to read and write even a damaged binary object.  For one
thing, it lets you generate damaged test cases to stress-test
software; for another, it can make emergency repairs a whole lot
easier.  It may be hard to handle cases in which the
   <em>structure</em>
   of the object is messed up, but at
least you should handle cases in which the
   <em>content</em>
   of the structure is nonsense, e.g., by showing nonsense values in hex
and converting the hex back to the values.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<h4 id="id2915107"><a href="#id2915107">§</a>Transparency, Fault Diagnosis, and Fault Recovery</h4>
<p>
  Yet another benefit of transparency, related to ease of
debugging, is that transparent systems are easier to perform recovery
actions on after a bug bites — and, often, more resistant to
damage from bugs in the first place.
</p>
<p>
  In comparing the terminfo database with Windows registries
we noted that registries are notoriously subject to being corrupted
by buggy application code.  This can make the entire system unusable.  
Even if it doesn't, recovery can be difficult if the corruption
confuses the specialized registry-editing tools.
</p>
<p>
  Our Unix case studies illustrate ways that designing for
transparency can prevent this class of problem.  Because the terminfo
database is not one big file, botching one terminfo entry does not
make the whole terminfo data set unusable.  Fully textual one-big-file
formats like termcap are usually parsed with methods which (unlike
block reads of binary structure dumps) can recover from single-point
errors.  Syntax errors in an SNG file can be corrected by hand without
requiring specialized editors that might refuse to load a damaged PNG
image.
</p>
<p>
  Going back to the
  <em>kmail</em> case study,
that program makes fault diagnosis easier because it obeys the Rule of
Repair: SMTP failures are noisy, usefully so.
You don't have to decode a layer of obfuscatory messages
generated by
  <em>kmail</em> itself to see
what the interaction with the SMTP server looks like.  All you have to
do is look in the right place, because
  <em>kmail</em> is being transparent and not throwing
away information about the error state.  (It helps that SMTP itself is
textual and includes human-readable status messages in its
transactions.)
</p>
<p>
  Discoverability tools like textualizers and browsers also make
fault diagnosis easier.  We've already touched on one reason: they
make inspecting the state of the system easier.  But there is another
effect at work as well; textualized versions of data tend to have
useful redundancies (such as using whitespace for visual separation as
well as explicit delimiters for parsing). These are present to make
them easier to read for humans, but also have the effect of making them
more resistant to being irreparably trashed by point failures.  A
corrupted chunk in a PNG file is seldom recoverable, but the human
capacity for pattern recognition and reasoning from context might be
able to repair the equivalent SNG form.
</p>
<p>
  Over and over again, the Rule of Robustness is clear.
Simplicity plus transparency lowers costs, reduces everybody's stress,
and frees people to concentrate on new problems rather than cleaning
up after old mistakes.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2914429" id="ftn.id2914429">[63]</a></sup>
  See the koan called
  <em>Tozan's Three Pounds</em>
  in the
  <em>Gateless Gate</em> <sup><a href="#Mumon" title="[Mumon]">[Mumon]</a></sup>.
</p>

<p><sup><a href="#id2914557" id="ftn.id2914557">[64]</a></sup>
  An
invariant is a property of a software design that is preserved by
every operation in it.  For example, in most databases it is an
invariant that no two records may have the same key. In a
C
  <a class="indexterm" id="id2914565"></a>
  program that
correctly manipulates strings, every string buffer must contain a
terminating NUL byte on exit from each string function.  In an
inventory system, no parts count can hold a number less than
zero.
</p>
</div>


<!-- FILE: ch06s03.html -->
<h3 id="ch06s03"><a href="#ch06s03">§</a>Designing for Maintainability</h3>
<p>
  Software is maintainable to the extent that people who are not
its author can successfully understand and modify it. Maintainability
demands more than code that works; it demands code that follows
the Rule of Clarity and communicates successfully to human beings
as well as the computer.
</p>
<p>
  Unix programmers have a lot of implicit knowledge available to
them about what makes for maintainable code, because Unix hosts source
code that goes back decades.  For reasons we'll discuss in
  <a href="#portabilitychapter" title="Chapter 17. Portability">
   Chapter 17</a>, Unix programmers learn a tendency to
scrap and rebuild rather than patching grubby code (see Rob Pike's
meditation on this subject in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>).  Thus, any sources that have survived
more than a decade of evolutionary pressure have been selected for
maintainability. These old, successful, well-established projects with
maintainable code are the community's models for practice.
</p>
<p>
  A question Unix programmers — and especially Unix
programmers in the open-source world — learn to ask about tools
they are evaluating for use is: “Is this code live, dormant, or
dead?”  Live code has an active developer community attached
to it.  Dormant code has often become dormant because the pain of
maintaining it exceeded its utility to its originators.  Dead code has
been dormant for so long that it would be easier to reimplement an
equivalent from scratch.  If you want your code to live, investing
effort to make it maintainable (and therefore attractive to future
maintainers) will be one of the most effective ways you can spend your
time.
</p>
<p>
  Code that is designed to be both transparent and
discoverable
  has gone a long way toward being maintainable.  But there are other
practices we can observe in the model projects in this chapter that
are worth emulating.
</p>
<p>
  One very important practice is an application of the Rule of
Clarity: choosing simple algorithms.  In
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>
  we quoted Ken Thompson: “When in
doubt, use brute force”.  Thompson
  understood the full cost of complicated
algorithms — not just that they're more bug-prone when initially
implemented, but that they're harder for maintainers down the line to
understand.
</p>
<p>
  Another important practice is the inclusion of hacker's guides.
It has always been highly approved behavior for source code
distributions to include guide documents informally describing the key
data structures and algorithms in the code. In fact, Unix programmers
have often been better about producing hacker's guides than they are
about writing end-user documentation.
</p>
<p>
  The open-source community has seized on and elaborated this
custom.  Besides being advice to future maintainers, hacker's guides
for open-source projects are also designed to make it easy for casual
contributors to add features or fix bugs.  The Design Notes file
shipped with
  <em>fetchmail</em> is representative.  The Linux
  kernel sources include literally dozens
of these.
</p>
<p>
  In
  <a href="#opensourcechapter" title="Chapter 19. Open Source">
   Chapter 19</a>
  we'll
describe conventions that Unix developers have evolved for making
source code distributions easy to examine and easy to build running
code from. These practices, too, promote maintainability.
</p>



<!-- FILE: multiprogramchapter.html -->
<h3 id="multiprogramchapter"><a href="#multiprogramchapter">§</a>Chapter 7. Multiprogramming</h3>
 <blockquote class="epigraph">
  <p>
   If we believe in data structures, we must believe in independent
(hence simultaneous) processing. For why else would we collect items
within a structure?  Why do we tolerate languages that give us the one
without the other?
  </p>
  <span>
   – Alan Perlis
Epigrams in Programming, in ACM SIGPLAN (Vol 17 #9, 1982)
  </span>
 </blockquote>
<p>
  The most characteristic program-modularization technique of Unix
is splitting large programs into multiple cooperating processes.  This
has usually been called ‘multiprocessing’ in the Unix world,
but in this book we revive the older term
‘multiprogramming’ to avoid confusion with
multiprocessor hardware implementations.
</p>
<p>
  Multiprogramming is a particularly murky area of design, one in
which there are few guidelines to good practice.  Many programmers
with excellent judgment about how to break up code into subroutines
nevertheless wind up writing whole applications as monster
single-process monoliths that founder on their own internal
complexity.
</p>
<p>
  The Unix style of design applies the do-one-thing-well approach
at the level of cooperating programs as well as cooperating routines
within a program, emphasizing small programs connected by well-defined
interprocess communication or by shared files. Accordingly, the Unix operating
system encourages us to break our programs into simpler subprocesses,
and to concentrate on the interfaces between these subprocesses. It
does this in at least three fundamental ways:
</p>
 <div>
  <ul>
   <li>
    <p>
     by making process-spawning cheap;
    </p>
   </li>
   <li>
    <p>
     by providing methods (shellouts, I/O redirection, pipes,
message-passing, and sockets) that make it relatively easy for
processes to communicate;
    </p>
   </li>
   <li>
    <p>
     by encouraging the use of simple, transparent, textual
data formats
     that can be passed through
pipes and sockets.
    </p>
   </li>
  </ul>
 </div>
<p>
  Inexpensive process-spawning and easy process control are
critical enablers for the Unix style of programming. On an operating
system such as VAX VMS, where starting processes is expensive
and slow and requires special privileges, one must build monster
monoliths because one has no choice. Fortunately the trend in the Unix
family has been toward lower
fork(2)
overhead rather than higher. Linux, in particular, is famously efficient
this way, with a process-spawn faster than thread-spawning on many
other operating systems.<sup><a href="#ftn.id2918458" id="id2918458">[65]</a></sup>
</p>
<p>
  Historically, many Unix programmers have been encouraged to
think in terms of multiple cooperating processes by experience with
shell programming.  Shell makes it relatively easy to set up groups of
multiple processes connected by
pipes, running either
in background or foreground or a mix of the two.
</p>
<p>
  In the remainder of this chapter, we'll look at the
implications of cheap process-spawning and discuss how and when to
apply pipes, sockets, and other interprocess communication (IPC)
methods to partition your design into cooperating processes. (In the
next chapter, we'll apply the same separation-of-functions philosophy
to interface design.)
</p>
<p>
  While the benefit of breaking programs up into cooperating
processes is a reduction in global complexity, the cost is that we
have to pay more attention to the design of the protocols which are
used to pass information and commands between processes.  (In software
systems of all kinds, bugs collect at interfaces.)
</p>
<p>
  In
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>
  we
looked at the lower level of this design problem — how to lay
out application protocols that are transparent, flexible and
extensible.  But there is a second, higher level to the problem which
we blithely ignored.  That is the problem of designing state machines
for each side of the communication.
</p>
<p>
  It is not hard to apply good style to the syntax of application
protocols, given models like SMTP or BEEP or XML-RPC.  The real
challenge is not protocol syntax but protocol
  <em>logic</em>
  —designing a protocol that is both
sufficiently expressive and deadlock-free. Almost as importantly, the
protocol has to be
  <em>seen</em>
  to be expressive and
deadlock-free; human beings attempting to model the behavior of the
communicating programs in their heads and verify its correctness must
be able to do so.
</p>
<p>
  In our discussion, therefore, we will focus on the kinds of
protocol logic one naturally uses with each kind of interprocess
communication.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2918458" id="ftn.id2918458">[65]</a></sup>
  See, for example, the results
quoted in
  <em>Improving Context Switching Performance of Idle Tasks under Linux</em><sup><a href="#Appleton" title="[Appleton]">[Appleton]</a></sup>.
</p>
</div>


<!-- FILE: ch07s01.html -->
<h3 id="ch07s01"><a href="#ch07s01">§</a>Separating Complexity Control from Performance Tuning</h3>
<p>
  First, though, we need to dispose of a few red herrings. Our
discussion is
  <em>not</em>
  going to be about using
concurrency to improve performance. Putting that concern before
developing a clean architecture that minimizes global complexity is
premature optimization,
the root of all evil (see
  <a href="#optimizationchapter" title="Chapter 12. Optimization">
   Chapter 12</a>
  for further discussion).
</p>
<p>
  A closely related red herring is threads (that is, multiple
concurrent processes sharing the same memory-address space). Threading is a
performance hack.  To avoid a long diversion here, we'll
examine threads in more detail at the end of this chapter; the
summary is that they do not reduce global complexity but rather
  <em>increase</em>
  it, and should therefore be avoided 
save under dire necessity.
</p>
<p>
  Respecting the Rule of Modularity, on the other hand, is
  <em>not</em>
  a red herring; doing so can make your
programs — and your life — simpler. All the reasons for
process partitioning are continuous with the reasons for module
partitioning that we developed in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>.
</p>
<p>
  Another important reason for breaking up programs into
cooperating processes is for better security.  Under Unix, programs
that must be run by ordinary users, but must have write access to
security-critical system resources, get that access through a feature
called the
  <em>setuid bit</em>.<sup><a href="#ftn.id2915417" id="id2915417">[66]</a></sup>
  Executable files are the smallest unit
of code that can hold a setuid bit; thus, every line of code in a
setuid executable must be trusted.  (Well-written setuid programs,
however, take all necessary privileged actions first and then drop
their privileges back to user level for the remainder of their
existence.)
</p>
<p>
  Usually a setuid program only needs its privileges for one or a
small handful of operations.  It is often possible to break up such a
program into cooperating processes, a smaller one that needs setuid
and a larger one that does not.  When we can do this, only the code in
the smaller program has to be trusted.  It is in significant part
because this kind of partitioning and delegation is possible that Unix
has a better security track record<sup><a href="#ftn.id2915447" id="id2915447">[67]</a></sup>
  than its competitors.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2915417" id="ftn.id2915417">[66]</a></sup>
  A setuid
program runs not with the privileges of the user calling it, but with
the privileges of the owner of the executable. This feature can be
used to give restricted, program-controlled access to things like the
password file that nonadministrators should not be allowed to modify
directly.
</p>

<p><sup><a href="#id2915447" id="ftn.id2915447">[67]</a></sup>
  That is, a better
record measured in security breaches per total machine hours of
Internet exposure.
</p>
</div>


<!-- FILE: ch07s02.html -->
<h3 id="ch07s02"><a href="#ch07s02">§</a>Taxonomy of Unix IPC Methods</h3>
<p>
  As in single-process program architectures, the simplest
organization is the best.  The remainder of this chapter will present
IPC techniques roughly in order of escalating complexity of
programming them.  Before using a later, more complex technique, you
should prove by demonstration — with prototypes and benchmark
results — that no earlier and simpler technique will do.  Often
you will surprise yourself.
</p>
<h4 id="id2915475"><a href="#id2915475">§</a>Handing off Tasks to Specialist Programs</h4>
<p>
  In the simplest form of interprogram cooperation enabled by
inexpensive process spawning, a program runs another to accomplish a
specialized task. Because the called program is often specified as a
Unix shell command through the
system(3)
call, this is often called
  <em>shelling out</em>
  to the
called program. The called program inherits the user's keyboard and
display and runs to completion. When it exits, the calling program
resumes control of the keyboard and display and resumes
execution.<sup><a href="#ftn.id2915505" id="id2915505">[68]</a></sup>
  Because the calling program does not
communicate with the called program during the callee's execution,
protocol design is not an issue in this kind of cooperation,
except in the trivial sense that the caller may pass command-line
arguments to the callee to change its behavior.
</p>
<p>
  The classic Unix case of shelling out is calling an editor from
within a mail or news program. In the Unix tradition one does
  <em>not</em>
  bundle purpose-built editors into programs
that require general text-edited input. Instead, one allows the user
to specify an editor of his or her choice to be called when editing
needs to be done.
</p>
<p>
  The specialist program usually communicates with its parent through the
file system, by reading or modifying file(s) with specified
location(s); this is how editor or mailer shellouts work.
</p>
<p>
  In a common variant of this pattern, the specialist program may
accept input on its standard input, and be called with the
C
  library entry
point
  <code>popen(..., "w")</code> or as part of a
shellscript.  Or it may send output to its standard output, and be
called with
  <code>popen(..., "r")</code> or as part of a
shellscript.  (If it both reads from standard input and writes to
standard output, it does so in a batch mode, completing all reads
before doing any writes.)  This kind of child process is not usually
referred to as a shellout; there is no standard jargon for it, but it
might well be called a ‘bolt-on’.
</p>
<p>
  They key point about all these cases is that the specialist
programs don't handshake with the parent while they are running.  They
have an associated protocol only in the trivial sense that whichever
program (master or slave) is accepting input from the other has to be
able to parse it.
</p>
<h5 id="id2915594"><a href="#id2915594">§</a>Case Study: The mutt Mail User Agent</h5>
<p>
  The
  <em>mutt</em> mail user agent is the modern
representative of the most important design tradition in Unix email
programs. It has a simple screen-oriented interface with
single-keystroke commands for browsing and reading mail.
</p>
<p>
  When you use
  <em>mutt</em> as a mail composer (either by calling it
with an address as a command-line argument or by using one of the
reply commands), it examines the process environment variable
  <code>EDITOR</code>, and then generates a temporary file name. The
value of the
  <code>EDITOR</code> variable is called as a command
with the tempfile name as an argument.<sup><a href="#ftn.id2915659" id="id2915659">[69]</a></sup>
  When that command terminates,
  <em>mutt</em> resumes on the assumption that the
temporary file contains the desired mail text.
</p>
<p>
  Almost all Unix mail- and netnews-composition programs observe
the same convention. Because they do, composer implementers don't
need to write a hundred inevitably diverging editors, and users
don't need to learn a hundred divergent interfaces.  Instead, users
can carry their chosen editors with them.
</p>
<p>
  An important variant of this strategy shells out to a small proxy
program that passes the specialist job to an already-running instance
of a big program, like an editor or a Web browser.  Thus, developers
who normally have an instance of
  <em>emacs</em> running on their X display can set
  <code>EDITOR=emacsclient</code>, and have a buffer pop open in
their
  <em>emacs</em> when they request editing in
  <em>mutt</em>.  The point of this is not really to
save memory or other resources, it's to enable the user to unify all
editing in a single
  <em>emacs</em> process (so that,
for example, cut and paste among buffers can carry along internal
  <em>emacs</em> state information like font
highlighting).
</p>
<h4 id="plumbing"><a href="#plumbing">§</a>Pipes, Redirection, and Filters</h4>
<p>
  After Ken Thompson
  and Dennis
Ritchie, the
single most important formative figure of early Unix was probably Doug
McIlroy. His
invention of the
  <em>pipe</em>
  construct reverberated
through the design of Unix, encouraging its nascent do-one-thing-well
philosophy and inspiring most of the later forms of IPC in the Unix
design (in particular, the socket abstraction used for
networking).
</p>
<p>
  Pipes depend on the convention that every program has initially
available to it (at least) two I/O data streams: standard input and
standard output (numeric file descriptors 0 and 1 respectively).
Many programs can be written as
  <em>filters</em>, which read
sequentially from standard input and write only to standard
output.
</p>
<p>
  Normally these streams are connected to the user's keyboard and
display, respectively. But Unix shells universally support
  <em>redirection</em>
  operations which connect these
standard input and output streams to files. Thus, typing
</p>
 <pre class="programlisting">
ls &gt;foo
</pre>
<p>
  sends the output of the directory lister
ls(1)
to a file named ‘foo’. On the other hand, typing:
</p>
 <pre class="programlisting">
wc &lt;foo
</pre>
<p>
  causes the word-count utility
wc(1)
to take its standard input from the file ‘foo’, and
deliver a character/word/line count to standard output.
</p>
<p>
  The pipe operation connects the standard output of one program
to the standard input of another. A chain of programs connected in
this way is called a
  <em>pipeline</em>. If we write
</p>
 <pre class="programlisting">
ls | wc
</pre>
<p>
  we'll see a character/word/line count for the current directory
listing. (In this case, only the line count is really likely to be
useful.)
</p>
 <blockquote>
  <p>
   One favorite pipeline was “<code>bc | speak</code>”—a 
talking desk calculator.  It knew number names up to a
vigintillion.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  It's important to note that all the stages in a pipeline run
concurrently.  Each stage waits for input on the output of the
previous one, but no stage has to exit before the next can run.  This
property will be important later on when we look at interactive uses
of pipelines, like sending the lengthy output of a command to
more(1).
</p>
<p>
  It's easy to underestimate the power of combining pipes and
redirection.  As an instructive example,
  <em>The Unix Shell As a 4GL</em><sup><a href="#Schaffer-Wolf" title="[Schaffer-Wolf]">[Schaffer-Wolf]</a></sup> shows that with these
facilities as a framework, a handful of simple utilities can be
combined to support creating and manipulating relational databases
expressed as simple textual tables.
</p>
<p>
  The major weakness of pipes is that they are unidirectional.
It's not possible for a pipeline component to pass control information
back up the pipe other than by terminating (in which case the previous
stage will get a
  <code>SIGPIPE</code> signal on the
next write).  Accordingly, the protocol for passing data is simply the
receiver's input format.
</p>
<p>
  So far, we have discussed anonymous pipes
created by the shell. There is a variant called a
  <em id="named_pipes">
   named
pipe
</em>
  which is a special kind of file. If two programs open the file, one for reading and the other for writing, a named
  pipe acts like a pipe-fitting between them. Named pipes are a bit of a historical relic; they have been largely
  displaced from use by named <em>sockets</em>, which we'll discuss below. (For more on the history of this relic, see
  the discussion of <a href="#messages" title="System V IPC">System V IPC</a> below.)
</p>
<h5 id="id2916058"><a href="#id2916058">§</a>Case Study: Piping to a Pager</h5>
<p>
  Pipelines have many uses. For one example, Unix's process lister
ps(1)
lists processes to standard output without caring that a long listing
might scroll off the top of the user's display too quickly for the
user to see it.  Unix has another program,
more(1),
which displays its standard input in screen-sized chunks, prompting
for a user keystroke after displaying each screenful.
</p>
<p>
  Thus, if the user types “<code>ps | more </code>”, piping the output of
ps(1)
to the input of
more(1),
successive page-sized pieces of the list of processes will be
displayed after each keystroke.
</p>
<p>
  The ability to combine programs like this can be extremely
useful. But the real win here is not cute combinations; it's that
because both pipes and
more(1)
exist,
  <em>other programs can be simpler</em>. Pipes mean
that programs like
ls(1)
(and other programs that write to standard out) don't have to grow
their own pagers — and we're saved from a world of a thousand
built-in pagers (each, naturally, with its own divergent look and
feel). Code bloat is avoided and global complexity reduced.
</p>
<p>
  As a bonus, if anyone needs to customize pager behavior, it can
be done in
  <em>one</em>
  place, by changing
  <em>one</em>
  program.  Indeed, multiple pagers can exist,
and will all be useful with every application that writes to standard
output.
</p>
<p>
  In fact, this has actually happened. On modern Unixes,
more(1)
has been largely replaced by
less(1),
which adds the capability to scroll back in the displayed file rather
than just forward.<sup><a href="#ftn.id2916197" id="id2916197">[70]</a></sup>
  Because
less(1)
is decoupled from the programs that use it, it's possible to simply
alias ‘more’ to ‘less’ in your shell, set the
environment variable
  <code>PAGER</code> to ‘less’ (see
  <a href="#configurationchapter" title="Chapter 10. Configuration">
   Chapter 10</a>), and get
all the benefits of a better pager with all properly-written Unix
programs.
</p>
<h5 id="id2916247"><a href="#id2916247">§</a>Case Study: Making Word Lists</h5>
<p>
  A more interesting example is one in which pipelined programs
cooperate to do some kind of data transformation for which, in less
flexible environments, one would have to write custom code.
</p>
<p>
  Consider the pipeline
</p>
 <pre class="programlisting">
tr -c '[:alnum:]' '[\n*]' | sort -iu | grep -v '^[0-9]*$'
</pre>
<p>
  The first command translates non-alphanumerics on standard input
to newlines on standard output. The second sorts lines on standard
input and writes the sorted data to standard output, discarding all
but one copy of spans of adjacent identical lines.  The third
discards all lines consisting solely of digits.  Together, these
generate a sorted wordlist to standard output from text on standard
input.
</p>
<h5 id="id2916289"><a href="#id2916289">§</a>Case Study: pic2graph</h5>
<p>
  Shell source code for the program pic2graph(1) ships with the <em>groff</em> suite of text-formatting tools from the
  Free Software Foundation.  It translates diagrams written in the PIC language to bitmap images. Example 7.1 shows the
  pipeline at the heart of this code.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 7.1. The
    <em>pic2graph</em> pipeline.
   </b>
  </p>
  <pre class="programlisting">
(echo ".EQ"; echo $eqndelim; echo ".EN"; echo ".PS";cat;echo ".PE")|\
     groff -e -p $groffpic_opts -Tps &gt;${tmp}.ps \
     &amp;&amp; convert -crop 0x0 $convert_opts ${tmp}.ps ${tmp}.${format} \
     &amp;&amp; cat ${tmp}.${format}
</pre>
 </div>
<p>
  The
pic2graph(1)
implementation illustrates how much one pipeline can do purely by
calling preexisting tools.  It starts by massaging its input into an
appropriate form, continues by feeding it through
groff(1)
to produce PostScript, and finishes by converting the PostScript to a
bitmap.  All these details are hidden from the user, who simply sees
PIC source go in one end and a bitmap ready for inclusion in a Web
page come out the other.
</p>
<p>
  This is an interesting example because it illustrates how
pipes
  and filtering can
adapt programs to unexpected uses.  The program that interprets PIC,
pic(1),
was originally designed only to be used for embedding diagrams in
typeset documents.  Most of the other programs in the toolchain it was
part of are now semiobsolescent.  But PIC remains handy for new uses,
such as describing diagrams to be embedded in HTML.  It gets a renewed
lease on life because tools like
pic2graph(1)
can bundle together all the machinery needed to convert the output of
pic(1)
into a more modern format.
</p>
<p>
  We'll examine pic(1) more closely, as a minilanguage design, in <a href="#minilanguageschapter" title="Chapter 8.
	  Minilanguages">Chapter 8</a>.
</p>
<h5 id="id2916464"><a href="#id2916464">§</a>Case Study: bc(1) and dc(1)</h5>
<p>
  Part of the classic Unix toolkit dating back to Version 7 is a
pair of calculator programs. The
dc(1)
program is a simple calculator that accepts text lines consisting of
reverse-Polish notation (RPN) on standard input and emits calculated
answers to standard output. The
bc(1)
program accepts a more elaborate infix syntax resembling conventional
algebraic notation; it includes as well the ability to set and read
variables and define functions for elaborate formulas.
</p>
<p>
  While the modern GNU implementation of
bc(1)
is standalone, the classic version passed commands to
dc(1)
over a pipe. In this division of labor,
bc(1)
does variable substitution and function expansion and translates infix
notation into reverse-Polish — but doesn't actually do
calculation itself, instead passing RPN translations of input
expressions to
dc(1)
for evaluation.
</p>
<p>
  There are clear advantages to this separation of function. It
means that users get to choose their preferred notation, but the logic
for arbitrary-precision numeric calculation (which is moderately
tricky) does not have to be duplicated. Each of the pair of programs
can be less complex than one calculator with a choice of notations
would be. The two components can be debugged and mentally modeled
independently of each other.
</p>
<p>
  In
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>
  we
will reexamine these programs from a slightly different example, as
examples of domain-specific minilanguages.
</p>
<h5 id="id2921380"><a href="#id2921380">§</a>Anti-Case Study: Why Isn't fetchmail a Pipeline?</h5>
<p>
  In Unix terms,
  <em>fetchmail</em> is an
uncomfortably large program that bristles with options.  Thinking
about the way mail transport works, one might think it would be
possible to decompose it into a pipeline. Suppose for a moment it were
broken up into several programs: a couple of fetch programs to get
mail from POP3 and IMAP sites, and a local SMTP injector.  The
pipeline could pass Unix mailbox format.  The present elaborate
  <em>fetchmail</em> configuration could be replaced
by a shellscript containing command lines.  One could even insert
filters in the pipeline to block spam.
</p>
 <pre class="programlisting">
#!/bin/sh
imap jrandom@imap.ccil.org | spamblocker | smtp jrandom
imap jrandom@imap.netaxs.com | smtp jrandom
# pop ed@pop.tems.com | smtp jrandom
</pre>
<p>
  This would be very elegant and Unixy.  Unfortunately, it can't
work.  We touched on the reason earlier; pipelines are
unidirectional.
</p>
<p>
  One of the things the fetcher program
(
  <em>imap</em> or
  <em>pop</em>)
would have to do is decide whether to send a delete request for each
message it fetches.  In
  <em>fetchmail</em> 's present
organization, it can delay sending that request to the POP or IMAP
server until it knows that the local SMTP listener has accepted
responsibility for the message.  The pipelined, small-component
version would lose that property.
</p>
<p>
  Consider, for example, what would happen if the
  <em>smtp</em> injector fails because the SMTP
listener reports a disk-full condition. If the fetcher has already
deleted the mail, we lose.  This means the fetcher cannot delete mail
until it is notified to do so by the
  <em>smtp</em> injector.  This in turn raises a host of questions. How would they
communicate?  What message, exactly, would the injector pass back?
The global complexity of the resulting system, and its vulnerability
to subtle bugs, would almost certainly be higher than that of a
monolithic program.
</p>
<p>
  Pipelines are a marvelous tool, but not a universal one.
</p>
<h4 id="id2921506"><a href="#id2921506">§</a>Wrappers</h4>
<p>
  The opposite of a shellout is a
  <em>wrapper</em>. A
wrapper creates a new interface for a called program, or specializes
it.  Often, wrappers are used to hide the details of elaborate shell
pipelines.  We'll
discuss interface wrappers in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>. Most specialization wrappers are quite
simple, but nevertheless very useful.
</p>
<p>
  As with shellouts, there is no associated protocol because the
programs do not communicate during the execution of the callee; but
the wrapper usually exists to specify arguments that modify the
callee's behavior.
</p>
<h5 id="id2921550"><a href="#id2921550">§</a>Case Study: Backup Scripts</h5>
<p>
  Specialization wrappers are a classic use of the Unix shell and
other scripting languages. One kind of specialization wrapper
that is both common and representative is a backup script. It may be a
one-liner as simple as this:
</p>
 <pre class="programlisting">
tar -czvf /dev/st0 "$@"
</pre>
<p>
  This is a wrapper for the
tar(1)
tape archiver utility which simply supplies one fixed argument (the
tape device
  <code>/dev/st0</code>) and passes to tar all the other arguments
supplied by the user (“
  <code>$@</code> ”).<sup><a href="#ftn.id2921610" id="id2921610">[71]</a></sup>
</p>
<h4 id="id2921634"><a href="#id2921634">§</a>Security Wrappers and Bernstein Chaining</h4>
<p>
  One common use of wrapper scripts is as
  <em>security wrappers</em>.  A security script may call a gatekeeper program
to check some sort of credential, then conditionally execute another
based on the status value returned by the gatekeeper.
</p>
<p>
  Bernstein chaining is a specialized security-wrapper technique
first invented by Daniel J. Bernstein, who has employed it in a number
of his packages. (A similar pattern appears in commands like
nohup(1)
and
su(1),
but the conditionality is absent.)  Conceptually, a Bernstein chain is
like a pipeline, but
each successive stage replaces the previous one rather than running
concurrently with it.
</p>
<p>
  The usual application is to confine security-privileged
applications to some sort of gatekeeper program, which can then hand
state to a less privileged one.  The technique pastes several programs
together using execs, or possibly a combination of forks and
execs. The programs are all named on one command line. Each program
performs some function and (if successful) runs
exec(2)
on the rest of its command line.
</p>
<p>
  Bernstein's
  <em>rblsmtpd</em> package is a
prototypical example. It serves to look up a host in the antispam DNS
zone of the Mail Abuse Prevention System. It does this by doing a DNS
query on the IP address passed into it in the
  <code>TCPREMOTEIP</code> environment variable.  If the query is
successful, then
  <em>rblsmtpd</em> runs its own SMTP
that discards the mail. Otherwise the remaining command-line arguments
are presumed to constitute a mail transport agent that knows the SMTP
protocol, and are handed to
exec(2)
to be run.
</p>
<p>
  Another example can be found in Bernstein's
  <em>qmail</em> package. It contains a program called
  <em>condredirect</em>. The first parameter is an
email address, and the remainder a gatekeeper program and
arguments.
  <em>condredirect</em> forks and execs the
gatekeeper with its arguments. If the gatekeeper exits successfully,
  <em>condredirect</em> forwards the email
pending on stdin to the specified email address.  In this case,
opposite to that of
  <em>rblsmtpd</em>, the security
decision is made by the child; this case is a bit more like a
classical shellout.
</p>
<p>
  A more elaborate example is the
  <em>qmail</em> POP3 server. It consists of three programs,
  <em>qmail-popup</em>,
  <em>checkpassword</em>, and
  <em>qmail-pop3d</em>.
  <em>Checkpassword</em> comes from a separate package
cleverly called
  <em>checkpassword</em>, and
unsurprisingly it checks the password. The POP3 protocol has an
authentication phase and mailbox phase; once you enter the mailbox
phase you cannot go back to the authentication phase. This is a
perfect application for Bernstein chaining.
</p>
<p>
  The first parameter of
  <em>qmail-popup</em> is
the hostname to use in the POP3 prompts. The rest of its parameters
are forked and passed to
exec(2),
after the POP3 username and password have been fetched. If the program
returns failure, the password must be wrong, so
  <em>qmail-popup</em> reports that and waits for a
different password. Otherwise, the program is presumed to have
finished the POP3 conversation, so
  <em>qmail-popup</em> exits.
</p>
<p>
  The program named on
  <em>qmail-popup</em> 's
command line is expected to read three null-terminated strings from
file descriptor 3.<sup><a href="#ftn.id2921897" id="id2921897">[72]</a></sup>
  These are the username, password, and response to
a cryptographic challenge, if any.  This time it's
  <em>checkpassword</em> which accepts as parameters
the name of
  <em>qmail-pop3d</em> and its
parameters. The
  <em>checkpassword</em> program exits
with failure if the password does not match; otherwise it changes to
the user's uid, gid, and home directory, and executes the rest of its
command line on behalf of that user.
</p>
<p>
  Bernstein chaining is useful for situations in which the
application needs setuid or setgid privileges to initialize a
connection, or to acquire some credential, and then drop those
privileges so that following code does not have to be trusted.
Following the exec, the child program cannot set its real user ID back
to root. It's also more flexible than a single process, because you
can modify the behavior of the system by inserting another program
into the chain.
</p>
<p>
  For example,
  <em>rblsmtpd</em> (mentioned
above) can be inserted into a Bernstein chain, in between tcpserver
(from the
  <em>ucspi-tcp</em> package) and the real
SMTP server, typically
  <em>qmail-smtpd</em>. However, it works with
inetd(8)
and <code>sendmail -bs</code> as well.
</p>
<h4 id="id2922002"><a href="#id2922002">§</a>Slave Processes</h4>
<p>
  Occasionally, child programs both accept data from and return
data to their callers through
pipes
  connected to
standard input and output, interactively. Unlike simple shellouts and
what we have called ‘bolt-ons’ above, both master and
slave processes need to have internal state machines to handle a
protocol between them without deadlocking or racing.  This is a
drastically more complex and more difficult-to-debug organization than
a simple shellout.
</p>
<p>
  Unix's
popen(3)
call can set up either an input pipe or an output pipe for a shellout,
but not both for a slave process — this seems intended to
encourage simpler programming. And, in fact, interactive master-slave
communication is tricky enough that it is normally only used when
either (a) the implied protocol is utterly trivial, or (b) the slave
process has been designed to speak an application protocol along the
lines we discussed in
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>.  We'll return to this issue, and ways
to cope with it, in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>.
</p>
<p>
  When writing a master/slave pair, it is good practice for the
master to support a command-line switch or environment variable that
allows callers to set their own slave command.  Among other things,
this is useful for debugging; you will often find it handy during 
development to invoke the real slave process from within a harness
that monitors and logs transactions between slave and master.
</p>
<p>
  If you find that master/slave interactions in your program are
becoming nontrivial, it may be time to think about going the rest of
the way to a more peer-to-peer organization, using techniques like
sockets or shared memory.
</p>
<h5 id="id2922085"><a href="#id2922085">§</a>Case Study: scp and ssh</h5>
<p>
  One common case in which the implied protocol really is trivial is
progress meters.  The
scp(1)
secure-copy command calls
ssh(1)
as a slave process, intercepting enough information from ssh's
standard output to reformat the reports as an ASCII animation of a
progress bar.<sup><a href="#ftn.id2922127" id="id2922127">[73]</a></sup>
</p>
<h4 id="id2922148"><a href="#id2922148">§</a>Peer-to-Peer Inter-Process Communication</h4>
<p>
  All the communication methods we've discussed so far have a sort
of implicit hierarchy about them, with one program effectively
controlling or driving another and zero or limited feedback passing in
the opposite direction. In communications and networking we frequently
need channels that are
  <em>peer-to-peer</em>, usually (but
not necessarily) with data flowing freely in both directions. We'll
survey peer-to-peer communications methods under Unix here, and
develop some case studies in later chapters.
</p>
<h5 id="id2922172"><a href="#id2922172">§</a>Tempfiles</h5>
<p>
  The use of tempfiles as communications drops between
cooperating programs is the oldest IPC technique there is.  Despite
drawbacks, it's still useful in shellscripts, and in one-off programs
where a more elaborate and coordinated method of communication would
be overkill.
</p>
<p>
  The most obvious problem with using tempfiles as an IPC
technique is that it tends to leave garbage lying around if processing
is interrupted before the tempfile can be deleted. A less obvious risk
is that of collisions between multiple instances of a program using
the same name for a tempfile. This is why it is conventional for
shellscripts that make tempfiles to include $$ in their names; this
shell variable expands to the process-ID of the enclosing shell and
effectively guarantees that the filename will be unique (the same 
trick is supported in Perl).
</p>
<p>
  Finally, if an attacker knows the location to which a tempfile
will be written, it can overwrite on that name and possibly either read
the producer's data or spoof the consumer process by inserting
modified or spurious data into the file.<sup><a href="#ftn.id2922208" id="id2922208">[74]</a></sup>
  This is a security risk.  If the processes involved have root
privileges, this is a very serious risk.  It can be mitigated by setting
the permissions on the tempfile directory carefully, but such
arrangements are notoriously likely to spring leaks.
</p>
<p>
  All these problems aside, tempfiles still have a niche because
they're easy to set up, they're flexible, and they're less vulnerable
to deadlocks or race conditions than more elaborate methods. And
sometimes, nothing else will do.  The calling conventions of your
child process may require that it be handed a file to operate on.  Our
first example of a shellout to an editor demonstrates this
perfectly.
</p>
<h5 id="id2922239"><a href="#id2922239">§</a>Signals</h5>
<p>
  The simplest and crudest way for two processes on the same
machine to communicate with each other is for one to send the other a
  <em>signal</em>. Unix signals are a form of soft
interrupt; each one has a default effect on the receiving process
(usually to kill it). A process can declare a
  <em>
   signal
handler
</em>
  that overrides the default action for the signal; the
handler is a function that is executed asynchronously when the signal
is received.
</p>
<p>
  Signals were originally designed into Unix as a way for the
operating system to notify programs of certain errors and critical
events, not as an IPC facility. The
  <code>SIGHUP</code> signal,
for example, is sent to every program started from a given terminal
session when that session is terminated. The
  <code>SIGINT</code> signal is sent to whatever process is currently attached to the
keyboard when the user enters the currently-defined interrupt
character (often control-C). Nevertheless, signals can be useful for
some IPC situations (and the POSIX-standard signal set includes two
signals,
  <code>SIGUSR1</code> and
  <code>SIGUSR2</code>,
intended for this
use). They are often
employed as a control channel for
  <em>daemons</em>
  (programs that run constantly, invisibly, in background), a way for an
operator or another program to tell a daemon that it needs to either
reinitialize itself, wake up to do work, or write
internal-state/debugging information to a known location.
</p>
 <blockquote>
  <p>
   I insisted
   <code>SIGUSR1</code> and
   <code>SIGUSR2</code> be invented for BSD. People
were grabbing system signals to mean what they needed them to mean for IPC,
so that (for example) some programs that segfaulted would not coredump
because
   <code>SIGSEGV</code> had been hijacked.
  </p>
  <p>
   This is a general principle — people will want to hijack
any tools you build, so you have to design them to either be
un-hijackable or to be hijacked cleanly.  Those are your only choices.
Except, of course, for being ignored—a highly reliable way to
remain unsullied, but less satisfying than might at first appear.
  </p>
  <span>
   – Ken Arnold
  </span>
 </blockquote>
<p>
  A technique often used with signal IPC is the so-called
  <em>pidfile</em>. Programs that will need to be signaled
will write a small file to a known location (often in
  <code>/var/run</code> or the invoking user's home directory)
containing their process ID or PID. Other programs can read that file
to discover that PID. The pidfile may also function as an implicit
  <em>lock file</em>
  in cases where no more than one
instance of the daemon should be running simultaneously.
</p>
<p>
  There are actually two different flavors of signals.  In the
older implementations (notably V7, System
III, and early
System V), the
handler for a given signal is reset to the default for that signal
whenever the handler fires.  The result of sending two of the same
signal in quick succession is therefore usually to kill the process,
no matter what handler was set.
</p>
<p>
  The BSD 4.x
  versions of Unix changed to
“reliable” signals, which do not reset unless the user
explicitly requests it.  They also introduced primitives to block or
temporarily suspend processing of a given set of signals.  Modern
Unixes support both styles.  You should use the BSD-style
nonresetting entry points for new code, but program defensively in
case your code is ever ported to an implementation that does not
support them.
</p>
<p>
  Receiving N signals does not necessarily invoke the signal
handler N times.  Under the older System V signal model, two or more
signals spaced very closely together (that is, within a single
timeslice of the target process) can result in various race
conditions<sup><a href="#ftn.id2922479" id="id2922479">[75]</a></sup>
  or anomalies. Depending on what
variant of signals semantics the system supports, the second and later
instances may be ignored, may cause an unexpected process kill, or may
have their delivery delayed until earlier instances have been
processed (on modern Unixes the last is most likely).
</p>
<p>
  The modern signals API is portable across all recent Unix
versions, but not to Windows or classic (pre-OS X) MacOS.
</p>
<h5 id="id2922508"><a href="#id2922508">§</a>System Daemons and Conventional Signals</h5>
<p>
  Many well-known system daemons accept
  <code>SIGHUP</code> (originally the signal sent to programs on a serial-line drop, such as
was produced by hanging up a modem connection) as a signal to
reinitialize (that is, reload their configuration files); examples
include Apache
  and the
Linux implementations of
bootpd(8),
gated(8),
inetd(8),
mountd(8),
named(8),
nfsd(8),
and
ypbind(8). In
a few cases,
  <code>SIGHUP</code> is accepted in its original sense
of a session-shutdown signal (notably in Linux
pppd(8)),
but that role nowadays generally goes to
  <code>SIGTERM</code>.
</p>
<p>
  <code>SIGTERM</code> (‘terminate’) is
often accepted as a graceful-shutdown signal (this is as distinct from
  <code>SIGKILL</code>, which does an immediate process
kill and cannot be blocked or handled).
  <code>SIGTERM</code> actions often involve cleaning up
tempfiles, flushing final updates out to databases, and the
like.
</p>
<p>
  When writing daemons, follow the Rule of Least Surprise: use
these conventions, and read the manual pages to look for existing
models.
</p>
<h5 id="fetchmail_signals"><a href="#fetchmail_signals">§</a>Case Study: fetchmail's Use of Signals</h5>
<p>
  The
  <em>fetchmail</em> utility is normally set
up to run as a daemon in background, periodically collecting mail from
all remote sites defined in its run-control file and passing the mail
to the local SMTP listener on port 25 without user
intervention.
  <em>fetchmail</em> sleeps for a
user-defined interval (defaulting to 15 minutes) between collection
attempts, so as to avoid constantly loading the network.
</p>
<p>
  When you invoke <code>fetchmail</code> with no arguments,
it checks to see if you have a
  <em>fetchmail</em> daemon already running (it does this by looking for a pidfile). If no
daemon is running,
  <em>fetchmail</em> starts up
normally using whatever control information has been specified in its
run-control file. If a daemon is running, on the other hand, the new
  <em>fetchmail</em> instance just signals the old one
to wake up and collect mail immediately; then the new instance
terminates. In addition, <code>fetchmail -q</code> sends a
termination signal to any running
  <em>fetchmail</em> daemon.
</p>
<p>
  Thus, typing <code>fetchmail</code> means, in effect,
“poll now and leave a daemon running to poll later; don't bother me
with the detail of whether a daemon was already running or not”.
Observe that the detail of which particular signals are used for
wakeup and termination is something the user doesn't have to know.
</p>
<h5 id="sockets"><a href="#sockets">§</a>Sockets</h5>
<p>
  Sockets
  were developed in the
BSD
  lineage of Unix
as a way to encapsulate access to data networks. Two programs
communicating over a socket typically see a bidirectional byte stream
(there are other socket modes and transmission methods, but they are
of only minor importance). The byte stream is both sequenced (that is,
even single bytes will be received in the same order sent) and
reliable (socket users are guaranteed that the underlying network will
do error detection and retry to ensure delivery). Socket descriptors,
once obtained, behave essentially like file descriptors.
</p>
 <blockquote>
  <p>
   Sockets differ from read/write in one important case.  If
the bytes you send arrive, but the receiving machine fails to ACK, the
sending machine's TCP/IP stack will time out.  So getting an error does
   <em>not</em>
   necessarily mean that the bytes didn't
arrive; the receiver may be using them.  This problem has profound 
consequences for the design of reliable protocols, because you have to be 
able to work properly when you don't know what was received in the 
past.  Local I/O is ‘yes/no’.  Socket I/O is ‘yes/no/maybe’.
And nothing can ensure delivery — the remote machine
might have been destroyed by a comet.
  </p>
  <span>
   – Ken Arnold
  </span>
 </blockquote>
<p>
  At the time a socket is created, you specify a
  <em>protocol family</em>
  which tells the network layer how
the name of the socket is interpreted. Sockets are usually thought of
in connection with the Internet, as a way of passing data between
programs running on different hosts; this is the AF_INET socket
family, in which addresses are interpreted as host-address and
service-number pairs. However, the AF_UNIX (aka AF_LOCAL) protocol
family supports the same socket abstraction for communication between
two processes on the same machine (names are interpreted as the
locations of special files analogous to bidirectional named pipes). As
an example, client programs and servers using the X windowing
system
  typically use AF_LOCAL sockets to communicate.
</p>
<p>
  All modern Unixes support BSD-style
  sockets, and as a
matter of design they are usually the right thing to use for
bidirectional IPC no matter where your cooperating processes are
located.  Performance pressure may push you to use shared memory or
tempfiles or other techniques that make stronger locality assumptions,
but under modern conditions it is best to assume that your code will
need to be scaled up to distributed operation.  More importantly,
those locality assumptions may mean that portions of your system get
chummier with each others' internals than ought to be the case in a
good design.  The separation of address spaces that sockets enforce is
a feature, not a bug.
</p>
<p>
  To use sockets gracefully, in the Unix tradition, start by
designing an
  <em>application protocol</em>
  for use between
them — a set of requests and responses which expresses the
semantics of what your programs will be communicating about in a
succinct way.  We've already discussed the some major issues in the
design of application protocols in
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>.
</p>
<p>
  Sockets are supported in all recent Unixes, under Windows, and
under classic MacOS as well.
</p>
 <h6 id="id2922950">
  Case Study: PostgreSQL
 </h6>
<p>
  PostgreSQL is an open-source database program.  Had it been
implemented as a monster monolith, it would be a single program with
an interactive interface that manipulates database files on disk
directly.  Interface would be welded together with implementation, and
two instances of the program attempting to manipulate the same
database at the same time would have serious contention and locking
issues.
</p>
<p>
  Instead, the PostgreSQL suite includes a server called
  <em>postmaster</em> and at least three client
applications.  One
  <em>postmaster</em> server
process per machine runs in background and has exclusive access to the
database files.  It accepts requests in the SQL query minilanguage through
TCP/IP
  sockets,
and returns answers in a textual format as well.  When the user runs a
PostgreSQL client, that client opens a session to
  <em>postmaster</em> and does SQL transactions with
it.  The server can handle several client sessions at once, and
sequences requests so that they don't interfere with each other.
</p>
<p>
  Because the front end and back end are separate, the server
doesn't need to know anything except how to interpret SQL requests
from a client and send SQL reports back to it.  The clients, on the 
other hand, don't need to know anything about how the database is 
stored.  Clients can be specialized for different needs and have
different user interfaces.
</p>
<p>
  This organization is quite typical for Unix databases — so
much so that it is often possible to mix and match SQL clients and SQL
servers. The interoperability issues are the SQL server's
TCP/IP
  port number,
and whether client and server support the same dialect of SQL.
</p>
 <h6 id="id2923040">
  Case Study: Freeciv
 </h6>
<p>
  In
  <a href="#transparencychapter" title="Chapter 6. Transparency">
   Chapter 6</a>, we
introduced Freeciv as an example of transparent data formats.  But
more critical to the way it supports multiplayer gaming is the
client/server partitioning of the code.  This is a representative
example of a program in which the application needs to be distributed
over a wide-area network and handles communication through TCP/IP
sockets.
</p>
<p>
  The state of a running Freeciv game is maintained by a server
process, the game engine.  Players run GUI clients which exchange
information and commands with the server through a packet protocol.
All game logic is handled in the server.  The details of GUI are
handled in the client; different clients support different interface
styles.
</p>
<p>
  This is a very typical organization for a multiplayer online
game. The packet protocol uses
TCP/IP
  as a transport,
so one server can handle clients running on different Internet hosts.
Other games that are more like real-time simulations (notably
first-person shooters) use raw Internet datagram protocol (UDP) and
trade lower latency for some uncertainty about whether any given
packet will be delivered. In such games, users tend to be issuing
control actions continuously, so sporadic dropouts are tolerable, but
lag is fatal.
</p>
<h5 id="id2923100"><a href="#id2923100">§</a>Shared Memory</h5>
<p>
  Whereas two processes using sockets to communicate may live on
different machines (and, in fact, be separated by an Internet
connection spanning half the globe), shared memory requires producers
and consumers to be co-resident on the same hardware.  But, if your
communicating processes can get access to the same physical memory,
shared memory will be the fastest way to pass information between
them.
</p>
<p>
  Shared memory may be disguised under different APIs, but on
modern Unixes the implementation normally depends on the use of
mmap(2)
to map files into memory that can be shared between processes.
POSIX
  defines a
shm_open(3)
facility with an API that supports using files as shared memory; this
is mostly a hint to the operating system that it need not flush the
pseudofile data to disk.
</p>
<p>
  Because access to shared memory is not automatically serialized
by a discipline resembling read and write calls, programs doing the
sharing must handle contention and deadlock issues themselves,
typically by using semaphore variables located in the shared segment.
The issues here resemble those in multithreading (see the end of this
chapter for discussion) but are more manageable because default is
  <em>not</em>
  to share memory. Thus, problems are better
contained.
</p>
<p>
  On systems where it is available and reliable, the
Apache
  web server's
scoreboard facility uses shared memory for communication between an
Apache master process and the load-sharing pool of Apache images that it
manages. Modern X implementations also use shared memory, to pass
large images between client and server when they are resident on the
same machine,  to avoid the overhead of socket communication.
Both uses are performance hacks justified by experience and testing,
rather than being architectural choices.
</p>
<p>
  The
mmap(2)
call is supported under all modern Unixes, including
Linux
  and the open-source BSD
  versions; this is described in the Single Unix Specification.  It will
not normally be available under Windows, MacOS classic, and other
operating systems.
</p>
<p>
  Before purpose-built
mmap(2)
was available, a common way for two processes to communicate was for
them to open the same file, and then delete that file.  The file
wouldn't go away until all open filehandles were closed, but some old
Unixes took the link count falling to zero as a hint that they could
stop updating the on-disk copy of the file.  The downside was that
your backing store was the file system rather than a swap device,
the file system the deleted file lived on couldn't be unmounted until the
programs using it closed, and attaching new processes to an existing
shared memory segment faked up in this way was tricky at best.
</p>
<p>
  After Version 7 and the split between the BSD and System V lineages,
the evolution of Unix interprocess communication took two different
directions. The BSD direction led to
  <a href="#sockets" title="Sockets">sockets</a>. The AT&amp;T lineage, on the other
hand, developed named pipes (as
  <a href="#named_pipes">previously discussed</a>) and an IPC facility, specifically designed for
passing binary data and based on shared-memory bidirectional message queues.  This is called ‘System V IPC’—or, among
old timers, ‘Indian Hill’ IPC after the AT&amp;T facility where it was first written.
</p>
<p>
  The upper, message-passing layer of System V IPC has largely
fallen out of use.  The lower layer, which consists of shared memory
and semaphores, still has significant applications under circumstances
in which one needs to do mutual-exclusion locking and some global data
sharing among processes running on the same machine.  These System V
shared memory facilities evolved into the POSIX shared-memory API,
supported under Linux, the BSDs, MacOS X and Windows, but not classic
MacOS.
</p>
<p>
  By using these shared-memory and semaphore facilities
(shmget(2),
semget(2),
and friends) one can avoid the overhead of copying data through the
network stack.  Large commercial databases (including Oracle, DB2, Sybase, and
Informix) use this technique heavily.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2915505" id="ftn.id2915505">[68]</a></sup>
  A common error in programming shellouts is to
forget to block signals in the parent while the subprocess runs.
Without this precaution, an interrupt typed to the subprocess can have
unwanted side effects on the parent
process.
</p>

<p><sup><a href="#id2915659" id="ftn.id2915659">[69]</a></sup>
  Actually, the above
is a slight oversimplification.  See the discussion of
  <code>EDITOR</code> and
  <code>VISUAL</code> in
  <a href="#configurationchapter" title="Chapter 10. Configuration">
   Chapter 10</a>
  for the rest of the
story.
</p>
</div>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2916197" id="ftn.id2916197">[70]</a></sup>
  The
less(1)
man page explains the name by observing “Less is
more”.
</p>

<p><sup><a href="#id2921610" id="ftn.id2921610">[71]</a></sup>
  A common error is to use
  <code>$*</code> rather than “
  <code>$@</code> ”. This does bad things when handed a filename with
embedded spaces.
</p>

<p><sup><a href="#id2921897" id="ftn.id2921897">[72]</a></sup>
  <em>qmail-popup</em> 's standard
input and standard output are the socket, and standard error (which
will be file descriptor 2) goes to a log file.  File descriptor 3 is
guaranteed to be the next to be allocated. As an infamous kernel comment
once observed: “You are not expected to understand this”.
</p>

<p><sup><a href="#id2922127" id="ftn.id2922127">[73]</a></sup>
  The friend who suggested this case study comments: “Yes,
you can get away with this technique...if there are just a few
easily-recognizable nuggets of information coming back from the slave
process, and you have tongs and a radiation suit”.
</p>

<p><sup><a href="#id2922208" id="ftn.id2922208">[74]</a></sup>
  A particularly nasty
variant of this attack is to drop in a named Unix-domain socket where
the producer and consumer programs are expecting the tempfile to
be.
</p>

<p><sup><a href="#id2922479" id="ftn.id2922479">[75]</a></sup>
  A ‘race condition’ is a class
of problem in which correct behavior of the system relies on two
independent events happening in the right order, but there is no
mechanism for ensuring that they actually will.  Race conditions
produce intermittent, timing-dependent problems that can be devilishly
difficult to debug.
</p>
</div>


<!-- FILE: ch07s03.html -->
<h3 id="ch07s03"><a href="#ch07s03">§</a>Problems and Methods to Avoid</h3>
<p>
  While BSD-style sockets
  over
TCP/IP
  have become the
dominant IPC method under Unix, there are still live controversies
over the right way to partition by multiprogramming.  Some obsolete
methods have not yet completely died, and some techniques of
questionable utility have been imported from other operating systems
(often in association with graphics or GUI programming).  We'll be
touring some dangerous swamps here; beware the crocodiles.
</p>
<h4 id="id2923376"><a href="#id2923376">§</a>Obsolescent Unix IPC Methods</h4>
<p>
  Unix (born 1969) long predates
TCP/IP
  (born 1980) and
the ubiquitous networking of the 1990s and later.  Anonymous pipes,
redirection, and shellout have been in Unix since very early days, but
the history of Unix is littered with the corpses of APIs tied to
obsolescent IPC and networking models, beginning with the
  <code>mx()</code> facility that appeared in Version 6 (1976)
and was dropped before Version 7 (1979).
</p>
<p>
  Eventually BSD sockets
  won out as IPC was unified with
networking.  But this didn't happen until after fifteen years of
experimentation that left a number of relics behind.  It's useful to
know about these because there are likely to be references to them in
your Unix documentation that might give the misleading impression that
they're still in use. These obsolete methods are described in more detail
in
  <em>Unix Network Programming</em> <sup><a href="#Stevens90" title="[Stevens90]">[Stevens90]</a></sup>.
</p>
 <blockquote>
  <p>
   The real explanation for all the dead IPC facilities in old AT&amp;T
Unixes was politics.  The Unix Support Group was headed by a low-level
manager, while some projects that used Unix were headed by vice
presidents.  They had ways to make irresistible requests, and would
not brook the objection that most IPC mechanisms are
interchangeable.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<h5 id="messages"><a href="#messages">§</a>System V IPC</h5>
<p>
  The System V IPC facilities are message-passing facilities based
on the System V shared memory facility we described earlier.
</p>
<p>
  Programs that cooperate using System V IPC usually define
shared protocols based on exchanging short (up to 8K) binary messages.
The relevant manual pages are
msgctl(2)
and friends.  As this style has been largely superseded by text
protocols passed between sockets, we do not give an example
here.
</p>
<p>
  The System V IPC facilities are present in
Linux
  and other modern Unixes. However, as they are a legacy feature, they
are not exercised very often. The Linux version is still known to have
bugs as of mid-2003.  Nobody seems to care enough to fix them.
</p>
<h5 id="id2923528"><a href="#id2923528">§</a>Streams</h5>
<p>
  Streams networking was invented for Unix Version 8 (1985) by
Dennis Ritchie. A re-implementation called STREAMS (yes,
it is all-capitals in the documentation) first became available in the
3.0 release of System V Unix (1986).  The STREAMS facility provided a
full-duplex interface (functionally not unlike a BSD
socket, and like
sockets, accessible through normal
read(2)
and
write(2)
operations after initial setup) between a user process and a specified
device driver in the kernel.  The device driver might be hardware such
as a serial or network card, or it might be a software-only
pseudodevice set up to pass data between user processes.
</p>
<p>
  An interesting feature of both streams and
STREAMS<sup><a href="#ftn.id2923595" id="id2923595">[76]</a></sup>
  is that it is possible to push
protocol-translation modules into the kernel's processing path, so
that the device the user process ‘sees’ through the
full-duplex channel is actually filtered.  This capability could be
used, for example, to implement a line-editing protocol for a terminal
device.  Or one could implement protocols such as IP or TCP without
wiring them directly into the kernel.
</p>
<p>
  Streams originated as an attempt to clean up a messy feature of the
kernel called ‘line disciplines’ — alternative modes
of processing character streams coming from serial terminals and early
local-area networks.  But as serial terminals faded from view,
Ethernet LANs became ubiquitous, and TCP/IP drove out other protocol
stacks and migrated into Unix kernels, the extra flexibility provided
by STREAMS had less and less utility.  In 2003, System V
Unix
  still
supports STREAMS, as do some System V/BSD
  hybrids such as Digital Unix and
Sun Microsystems' Solaris.
</p>
<p>
  Linux
  and other open-source Unixes have
effectively discarded STREAMS. Linux kernel modules and libraries are
available from the
  <a href="http://www.gcom.com/home/linux/lis/">
   LiS</a>
  project, but (as
of mid-2003) are not integrated into the stock Linux kernel.  They
will not be supported under non-Unix operating systems.
</p>
<h4 id="id2923675"><a href="#id2923675">§</a>Remote Procedure Calls</h4>
<p>
  Despite occasional exceptions such as NFS (Network File System)
and the GNOME project, attempts to import CORBA, ASN.1, and other
forms of remote-procedure-call interface have largely failed —
these technologies have not been naturalized into the Unix
culture.
</p>
<p>
  There seem to be several underlying reasons for this.  One is that RPC interfaces are not readily discoverable; that
  is, it is difficult to query these interfaces for their capabilities, and difficult to monitor them in action without
  building single-use tools as complex as the programs being monitored (we examined some of the reasons for this in <a
  href="#transparencychapter" title="Chapter 6. Transparency"> Chapter 6</a>). They have the same version skew problems
  as libraries, but those problems are harder to track because they're distributed and not generally obvious at link
  time.
</p>
<p>
  As a related issue, interfaces that have richer type signatures
also tend to be more complex, therefore more brittle. Over time, they
tend to succumb to ontology creep as the inventory of types that get
passed across interfaces grows steadily larger and the individual types
more elaborate.  Ontology creep is a problem because structs are more
likely to mismatch than strings; if the ontologies of the programs on
each side don't exactly match, it can be very hard to teach them to
communicate at all, and fiendishly difficult to resolve bugs.  The
most successful RPC applications, such as the Network File System, 
are those in which the application domain naturally has only a
few simple data types.
</p>
<p>
  The usual argument for RPC is that it permits
“richer” interfaces than methods like text streams
— that is, interfaces with a more elaborate and
application-specific ontology of data types. But the Rule of
Simplicity applies!  We observed in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>
  that one of the functions of interfaces
is as choke points that prevent the implementation details of modules
from leaking into each other.  Therefore, the main argument in favor
of RPC is also an argument that it increases global complexity rather
than minimizing it.
</p>
<p>
  With classical RPC, it's too easy to do things in a complicated
and obscure way instead of keeping them simple.  RPC seems to
encourage the production of large, baroque, over-engineered systems with
obfuscated interfaces, high global complexity, and serious
version-skew and reliability problems — a perfect example of
thick glue layers run amok.
</p>
<p>
  Windows COM and DCOM are perhaps the archetypal examples of how
bad this can get, but there are plenty of others.  Apple abandoned
OpenDoc, and both CORBA and the once wildly hyped Java
RMI
  have
receded from view in the Unix world as people have gained field
experience with them.  This may well be because these methods don't
actually solve more problems than they cause.
</p>
<p>
  Andrew S. Tanenbaum and Robbert van Renesse have given us a
detailed analysis of the general problem in
  <em>A Critique of the Remote Procedure Call Paradigm</em><sup><a href="#Tanenbaum-VanRenesse" title="[Tanenbaum-VanRenesse]">[Tanenbaum-VanRenesse]</a></sup>, a paper which should serve as a
strong cautionary note to anyone considering an architecture based on
RPC.
</p>
<p>
  All these problems may predict long-term difficulties for the
relatively few Unix projects that use RPC.  Of these projects, perhaps
the best known is the GNOME desktop effort.<sup><a href="#ftn.id2923816" id="id2923816">[77]</a></sup>
  These problems also contribute to the
notorious security vulnerabilities of exposing NFS servers.
</p>
<p>
  Unix tradition, on the other hand, strongly favors
transparent
  and
discoverable
  interfaces. This is one of the forces behind the Unix culture's
continuing attachment to IPC through textual protocols.  It is often
argued that the parsing overhead of textual protocols is a performance
problem relative to binary RPCs — but RPC interfaces tend to
have latency problems that are far worse, because (a) you can't
readily anticipate how much data marshaling and unmarshaling a given
call will involve, and (b) the RPC model tends to encourage
programmers to treat network transactions as cost-free.  Adding even
one additional round trip to a transaction interface tends to add
enough network latency to swamp any overhead from parsing or
marshaling.
</p>
<p>
  Even if text streams were less efficient than RPC, the
performance loss would be marginal and linear, the kind better
addressed by upgrading your hardware than by expending development
time or adding architectural complexity. Anything you might lose in
performance by using text streams, you gain back in the ability to
design systems that are simpler — easier to monitor, to model,
and to understand.
</p>
<p>
  Today, RPC and the Unix attachment to text streams are
converging in an interesting way, through protocols like XML-RPC and
SOAP. These, being textual and transparent, are more palatable to Unix
programmers than the ugly and heavyweight binary serialization formats
they replace.  While they don't solve all the more general
problems pointed out by Tanenbaum and van Renesse, they do in some
ways combine the advantages of both text-stream and RPC worlds.
</p>
<h4 id="id2923889"><a href="#id2923889">§</a>Threads — Threat or Menace?</h4>
<p>
  Though Unix developers have long been comfortable with
computation by multiple cooperating processes, they do not have a
native tradition of using threads (processes that share their entire
address spaces).  These are a recent import from elsewhere, and the
fact that Unix programmers generally dislike them is not merely
accident or historical contingency.
</p>
<p>
  From a complexity-control point of view, threads are a bad
substitute for lightweight processes with their own address spaces;
the idea of threads is native to operating systems with expensive
process-spawning and weak IPC facilities.
</p>
<p>
  By definition, though daughter threads of a process typically
have separate local-variable stacks, they share the same global
memory. The task of managing contentions and critical regions in this
shared address space is quite difficult and a fertile source of global
complexity and bugs. It can be done, but as the complexity of one's
locking regime rises, the chance of races and deadlocks due to
unanticipated interactions rises correspondingly.
</p>
<p>
  Threads are a fertile source of bugs because they can too easily
know too much about each others' internal states.  There is no
automatic encapsulation, as there would be between processes with
separate address spaces that must do explicit IPC to communicate.
Thus, threaded programs suffer from not just ordinary contention
problems, but from entire new categories of timing-dependent bugs that
are excruciatingly difficult to even reproduce, let alone fix.
</p>
<p>
  Thread developers have been waking up to this problem.  Recent
thread implementations and standards show an increasing concern with
providing thread-local storage, which is intended to limit problems
arising from the shared global address space.  As threading APIs move
in this direction, thread programming starts to look more and more
like a controlled use of shared memory.
</p>
 <blockquote>
  <p>
   Threads often prevent abstraction.  In order to prevent
deadlock, you often need to know how and if the library you are using
uses threads in order to avoid deadlock problems.  Similarly, the use
of threads in a library could be affected by the use of threads at the
application layer.
  </p>
  <span>
   – David Korn
  </span>
 </blockquote>
<p>
  To add insult to injury, threading has performance costs that
erode its advantages over conventional process partitioning.  While
threading can get rid of some of the overhead of rapidly switching
process contexts, locking shared data structures so threads won't step
on each other can be just as expensive.
</p>
 <blockquote>
  <p>
   The X server, able to execute literally millions of ops/second,
is
   <em>not</em>
   threaded; it uses a poll/select loop.
Various efforts to make a multithreaded implementation have come to no
good result.  The costs of locking and unlocking get too high for
something as performance-sensitive as graphics servers.
  </p>
  <span>
   – Jim Gettys
  </span>
 </blockquote>
<p>
  This problem is fundamental, and has also been a continuing issue
in the design of Unix kernels for symmetric multiprocessing.
As your resource-locking gets finer-grained, latency due to locking
overhead can increase fast enough to swamp the gains from locking
less core memory.
</p>
<p>
  One final difficulty with threads is that threading standards
still tend to be weak and underspecified as of
mid-2003. Theoretically conforming libraries for Unix standards
such as POSIX
  threads
(1003.1c) can nevertheless exhibit alarming differences in behavior
across platforms, especially with respect to signals, interactions
with other IPC methods, and resource cleanup times.  Windows and
classic MacOS have native threading models and interrupt facilities
quite different from those of Unix and will often require considerable
porting effort even for simple threading cases.  The upshot is that
you cannot count on threaded programs to be portable.
</p>
<p>
  For more discussion and a lucid contrast with event-driven
programming, see
  <em>Why Threads Are a Bad Idea</em> <sup><a href="#Ousterhout96" title="[Ousterhout96]">[Ousterhout96]</a></sup>.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2923595" id="ftn.id2923595">[76]</a></sup>
  STREAMS was much more complex. Dennis Ritchie
is reputed to have said “Streams means something different when
shouted”.
</p>

<p><sup><a href="#id2923816" id="ftn.id2923816">[77]</a></sup>
  GNOME's main
competitor, KDE, started with CORBA but abandoned it in their 2.0
release. They have been on a quest for lighter-weight IPC methods ever
since.
</p>
</div>


<!-- FILE: ch07s04.html -->
<h3 id="ch07s04"><a href="#ch07s04">§</a>Process Partitioning at the Design Level</h3>
<p>
  Now that we have all these methods, what should we do with them?
</p>
<p>
  The first thing to notice is that tempfiles, the more
interactive sort of master/slave process relationship, sockets, RPC,
and all other methods of bidirectional IPC are at some level
equivalent — they're all just ways for programs to exchange data
during their lifetimes.  Much of what we do in a sophisticated way
using sockets or shared memory we could do in a primitive way using
tempfiles as mailboxes and signals for notification.  The differences
are at the edges, in how programs establish communication, where and
when one does the marshalling and unmarshalling of messages, in what
sorts of buffering problems you may have, and atomicity guarantees you
get on the messages (that is, to what extent you can know that the
result of a single send action from one side will show up as a single
receive event on the other).
</p>
<p>
  We've seen from the PostgreSQL study that one effective way to
hold down complexity is to break an application into a client/server
pair. The PostgreSQL client and server communicate through an application
protocol over sockets, but very little about the design pattern would
change if they used any other bidirectional IPC method.
</p>
<p>
  This kind of partitioning is particularly effective in
situations where multiple instances of the application must manage
access to resources that are shared among all. A single server process
may manage all resource contention, or cooperating peers may each take
responsibility for some critical resource.
</p>
<p>
  Client-server partitioning can also help distribute cycle-hungry
applications across multiple hosts.  Or it may make them suitable for
distributed computing across the Internet (as with Freeciv). We'll
discuss the related
  <em>CLI server</em> pattern in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>.
</p>
<p>
  Because all these peer-to-peer IPC techniques are alike at some
level, we should evaluate them mainly on the amount of
program-complexity overhead they incur, and how much opacity they
introduce into our designs.  This, ultimately, is why BSD sockets have
won over other Unix IPC methods, and why RPC has generally failed to
get much traction.
</p>
<p>
  Threads are fundamentally different.  Rather than supporting
communication among different programs, they support a sort of
timesharing within an instance of a single program.  Rather
than being a way to partition a big program into smaller ones 
with simpler behavior, threading is strictly a performance hack. It
has all the problems normally associated with performance hacks, and
a few special ones of its own.
</p>
<p>
  Accordingly, while we should seek ways to break up large
programs into simpler cooperating processes, the use of threads within
processes should be a last resort rather than a first.  Often, you may
find you can avoid them.  If you can use limited shared memory and
semaphores, asynchronous I/O using
  <code>SIGIO</code>, or
poll(2)/select(2)
rather than threading, do it that way.  Keep it simple; use techniques
earlier on this list and lower on the complexity scale in preference
to later ones.
</p>
<p>
  The combination of threads, remote-procedure-call interfaces, and
heavyweight object-oriented design is especially dangerous.  Used
sparingly and tastefully, any of these techniques can be valuable —
but if you are ever invited onto a project that is supposed to feature
all three, fleeing in terror might well be an appropriate
reaction.
</p>
<p>
  We have previously observed that programming in the real world
is all about managing complexity.  Tools to manage complexity are good
things.  But when the effect of those tools is to proliferate
complexity rather than to control it, we would be better off throwing them
away and starting from zero.  An important part of the Unix wisdom 
is to never forget this.
</p>



<!-- FILE: minilanguageschapter.html -->
<h3 id="minilanguageschapter"><a href="#minilanguageschapter">§</a>Chapter 8. Minilanguages</h3>
 <blockquote class="epigraph">
  <p>
   A good notation has a subtlety and suggestiveness which at times 
makes it almost seem like a live teacher.
  </p>
  <span>
   – Bertrand Russell
The World of Mathematics (1956)
  </span>
 </blockquote>
<p>
  One of the most consistent results from large-scale studies of
error patterns in software is that programmer error rates in defects per 
hundreds of lines are largely independent of the language in which
the programmers are coding.<sup><a href="#ftn.id2930951" id="id2930951">[78]</a></sup>
  Higher-level languages, which allow
you to get more done in fewer lines, mean fewer bugs as well.
</p>
<p>
  Unix has a long tradition of hosting little languages
specialized for a particular application domain, languages that can
enable you to drastically reduce the line count of your programs.
Domain-specific language examples include the numerous Unix
typesetting languages (
  <em>troff</em>,
  <em>eqn</em>,
  <em>tbl</em>,
  <em>pic</em>,
  <em>grap</em>),
shell utilities (
  <em>awk</em>,
  <em>sed</em>,
  <em>dc</em>,
  <em>bc</em>), and software development tools
(
  <em>make</em>,
  <em>yacc</em>,
  <em>lex</em>).  There is a fuzzy boundary between
domain-specific languages and the more flexible sort of application
run-control file (
  <em>sendmail</em>, BIND, X);
another with data-file formats; and another with scripting
languages
  (which we'll survey in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>).
</p>
<p>
  Historically, domain-specific languages of this kind have been
called ‘little languages’ or ‘minilanguages’
in the Unix world, because early examples were small and low in
complexity relative to general-purpose languages (all three terms for
the category are in common use). But if the application domain is
complex (in that it has lots of different primitive operations or
involves manipulation of intricate data structures), an application
language for it may have to be rather more complex than some
general-purpose languages.  We'll keep the traditional term
‘minilanguage’ to emphasize that the wise course
is usually to keep these designs as small and simple as
possible.
</p>
<p>
  The domain-specific little language is an extremely powerful
design idea.  It allows you to define your own higher-level language
to specify the appropriate methods, rules, and algorithms for the task
at hand, reducing global complexity relative to a design that uses
hardwired lower-level code for the same ends.  You can get to a
minilanguage design in at least three ways, two of them good and one
of them dangerous.
</p>
<p>
  One right way to get there is to realize up front that you can
use a minilanguage design to push a given specification of a programming
problem up a level, into a notation that is more compact and
expressive than you could support in a general-purpose language.  As
with code generation and data-driven programming, a minilanguage lets
you take practical advantage of the fact that the defect rate in your
software will be largely independent of the level of the language you
are using; more expressive languages mean shorter programs and fewer
bugs.
</p>
<p>
  The second right way to get to a minilanguage design is to
notice that one of your specification file formats is looking more and
more like a minilanguage — that is, it is developing complex
structures and implying actions in the application you are
controlling.  Is it trying to describe control flow as well as data
layouts?  If so, it may be time to promote that control flow from
being implicit to being explicit in your specification
language.
</p>
<p>
  The wrong way to get to a minilanguage design is to extend your
way to it, one patch and crufty added feature at a time. On this path,
your specification file keeps sprouting more implied control flow and
more tangled special-purpose structures until it has become an ad-hoc
language without your noticing it.  Some legendary nightmares have
been spawned this way; the example every Unix guru will think of (and
shudder over) is the
  <code>sendmail.cf</code> configuration
file associated with the
  <em>sendmail</em> mail
transport.
</p>
<p>
  Sadly, most people do their first minilanguage the wrong way,
and only realize later what a mess it is.  Then the question is: how
to clean it up?  Sometimes the answer implies rethinking the entire
application design. Another notorious example of language-by-feature
creep was the editor
  <em>TECO</em>, which grew first
macros and then loops and conditionals as programmers wanted to use it
to package increasingly complex editing routines. The resulting
ugliness was eventually fixed by a redesign of the entire editor to be
based on an intentional language; this is how Emacs
Lisp
  (which we'll survey below) evolved.
</p>
<p>
  All sufficiently complicated specification files aspire to the
condition of minilanguages.  Therefore, it will often be the case that
your only defense against designing a bad minilanguage is knowing how
to design a good one. This need not be a huge step or involve knowing
a lot of formal language theory; with modern tools, learning a few
relatively simple techniques and bearing good examples in mind as you
design should be sufficient.
</p>
<p>
  In this chapter we'll examine all the kinds of minilanguages
normally supported under Unix, and try to identify the kinds of
situation in which each of them represents an effective design
solution.  This chapter is not meant to be an exhaustive catalog of
Unix languages, but rather to bring out the design principles involved
in structuring an application around a minilanguage.  We'll have much
more to say about languages for general-purpose programming in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>.
</p>
<p>
  We'll need to start by doing a little taxonomy, so we'll
know what we're talking about later on.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2930951" id="ftn.id2930951">[78]</a></sup>
  Les Hatton reports by email on the analysis in his book in
preparation,
  <em>Software Failure</em> : “Provided
you use executable line counts for the density measure, the injected
defect densities vary less between languages than they do between
engineers by about a factor of 10”.
</p>
</div>


<!-- FILE: ch08s01.html -->
<h3 id="ch08s01"><a href="#ch08s01">§</a>Understanding the Taxonomy of Languages</h3>
<p>
  All the languages in Figure 8.1 are described in case studies, either in this chapter or elsewhere in this book.  For
  the general-purpose interpreters near the right-hand side, see
  <a href="#languageschapter" title="Chapter 14. Languages">Chapter 14</a>.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 8.1. Taxonomy of languages.
   </b>
  </p>
  <div class="center">
   <img alt="Taxonomy of languages." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  In
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>
  we
looked at Unix conventions for data files.  There's a spectrum of
complexity in these.  At the low end are files that make simple
associations between names and properties; the
  <code>/etc/passwd</code> and
  <code>.newsrc</code> formats are good examples.  Further up the
scale we start to get formats that marshal or serialize data
structures; the PNG
  and
SNG formats are (equivalent) good examples of this.
</p>
<p>
  A structured data-file format starts to border on being a
minilanguage when it expresses not just structure but actions
performed on some interpretive context (that is, memory that is
outside the data file itself).  XML markups tend to straddle this
border; the example we'll look at here is
  <em>Glade</em>, a code generator for building GUI
interfaces. Formats that are both designed to be read and written by
humans (rather than just programs) and are used to generate code, are
firmly in the realm of minilanguages.
  <em>yacc</em> and
  <em>lex</em> are the classic examples.  We'll
discuss
  <em>glade</em>,
  <em>yacc</em> and
  <em>lex</em> in
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>.
</p>
<p>
  The Unix macro processor,
  <em>m4</em>, is
another very simple declarative minilanguage (that is, one in which
the program is expressed as a set of desired relationships or
constraints rather than explicit actions).  It has often been used as a
preprocessing stage for other minilanguages.
</p>
<p>
  Unix makefiles, which are designed to automate build processes,
express dependency relationships between source and derived files<sup><a href="#ftn.id2924480" id="id2924480">[79]</a></sup>
  and the commands required to make each derived
file from its sources.

When you run make, it uses those declarations to walk the implied tree
of dependencies, doing the least work necessary to bring your build up
to date.  Like
  <em>yacc</em> and
  <em>lex</em> specifications, makefiles are a
declarative minilanguage; they set up constraints that imply actions
performed on an interpretive context (in this case, the portion of the
file system where the source and generated files live).  We'll return
to makefiles in
  <a href="#toolschapter" title="Chapter 15. Tools">
   Chapter 15</a>.
</p>
<p>
  XSLT, the language used to describe transformations of XML,
is at the high end of complexity for declarative minilanguages.  It's
complex enough that it's not normally thought of as a minilanguage 
at all, but it shares some important characteristic of such languages
which we'll examine when we look at it in more detail below.
</p>
<p>
  The spectrum of minilanguages ranges from declarative (with
implicit actions) to imperative (with explicit actions).  The
run-control syntax of
fetchmail(1)
  can be viewed as either a very weak imperative language or a
declarative language with implied control flow.  The troff and
PostScript typesetting languages are imperative languages with a lot
of special-purpose domain expertise baked into them.
</p>
<p>
  Some task-specific imperative minilanguages start to border on
being general-purpose interpreters.  They reach this level when they
are explicitly
  <em>Turing-complete</em> —that is,
they can do both conditionals and loops (or recursion)<sup><a href="#ftn.id2924589" id="id2924589">[80]</a></sup>
  with features that are
designed to be used as control structures.  Some languages, by
contrast, are only accidentally Turing-complete — they have
features that can be used to implement control structures as a 
sort of side effect of what they are actually designed to do.
</p>
<p>
  The
bc(1)
and
dc(1)
interpreters we looked at in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  are good examples of specialized
imperative minilanguages that are explicitly Turing-complete.
</p>
<p>
  We are over the border into general-purpose interpreters when we
reach languages like Emacs Lisp
  and
JavaScript
  that are designed to be full
programming languages run in specialized contexts.  We'll have more to
say about these when we discuss embedded scripting
languages
  later
on.
</p>
<p>
  The spectrum in interpreters is one of increasing generality;
the flip side of this is that a more general-purpose interpreter
embodies fewer assumptions about the context in which it runs.  With
increasing generality there usually comes a richer ontology of data
types.  Shell and Tcl
  have relatively simple ontologies;
Perl,
Python, and
Java
  more
complex ones.  We'll return to these general-purpose languages in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2924480" id="ftn.id2924480">[79]</a></sup>
  For less technical readers: the compiled form of a
C
  <a class="indexterm" id="id2924487"></a>
  program is
derived from its C source form by compilation and linkage.  The
PostScript version of a troff document is derived from the troff
source; the command to make the former from the latter is a
  <em>troff</em> invocation.  There are many other
kinds of derivation; makefiles can express almost all of
them.
</p>

<p><sup><a href="#id2924589" id="ftn.id2924589">[80]</a></sup>
  Any Turing-complete language could theoretically be used for
general-purpose programming, and is theoretically exactly as powerful
as any other Turing-complete language.  In practice, some
Turing-complete languages would be far too painful to use for anything
outside a specified and narrow problem domain.
</p>
</div>


<!-- FILE: ch08s02.html -->
<h3 id="ch08s02"><a href="#ch08s02">§</a>Applying Minilanguages</h3>
<p>
  Designing with minilanguages involves two distinct challenges.
One is having existing minilanguages handy in your toolkit, and
recognizing when they can be applied as-is.  The other is knowing when
it is appropriate to design a custom minilanguage for an application.
To help you develop both aspects of your design sense, about half of 
this chapter will consist of case studies.
</p>
<h4 id="id2924747"><a href="#id2924747">§</a>Case Study: sng</h4>
<p>
  In
  <a href="#transparencychapter" title="Chapter 6. Transparency">
   Chapter 6</a>
  we
looked at
sng(1),
which translates between
PNG
  and an editable
all-text representation of the same bits.  The SNG data-file format is
worth reexamining for contrast here because it is not quite a
domain-specific minilanguage.  It describes a data layout, but doesn't
associate any implied sequence of actions with the data.
</p>
<p>
  SNG does, however, share one important characteristic with
domain-specific minilanguages that binary structured data formats like
PNG do not —
transparency.  Structured data files make
it possible for editing, conversion, and generation tools to cooperate
without knowing about each others' design assumptions other than through
the medium of the minilanguage.  What SNG adds is that, like a
domain-specific minilanguage, it's designed to be easy to parse by
eyeball and edit with general-purpose tools.
</p>
<h4 id="regexps"><a href="#regexps">§</a>Case Study: Regular Expressions</h4>
<p>
  A kind of specification that turns up repeatedly in Unix tools
and scripting languages is the
  <em>regular expression</em>
  (‘regexp’ for short).  We consider
it here as a declarative minilanguage for describing text patterns; it
is often embedded in other minilanguages.  Regexps are so ubiquitous
that the are hardly thought of as a minilanguage, but they replace
what would otherwise be huge volumes of code implementing different
(and incompatible) search capabilities.
</p>
<p>
  This introduction skates over some details like POSIX
  extensions,
back-references, and internationalization features; for a more
complete treatment, see
  <em>Mastering Regular Expressions</em><sup><a href="#Friedl" title="[Friedl]">[Friedl]</a></sup>.
</p>
<p>
  Regular expressions describe patterns that may either match or fail to match against strings.  The simplest
  regular-expression tool is grep(1), a filter that passes through to its output every line in its input matching a
  specified regexp. Regexp notation is summarized in Table 8.1.
</p>

  <table class="border">
	<caption>Table 8.1. Regular-expression examples.</caption>
   <thead>
    <tr>
     <th>
      Regexp
     </th>
     <th>
      Matches
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      <code>"x.y"</code> </td>
     <td>
      <code>x</code> followed by any character followed by
      <code>y</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"x\.y"</code> </td>
     <td>
      <code>x</code> followed by a literal period followed by
      <code>y</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"xz?y"</code> </td>
     <td>
      <code>x</code> followed by at most one
      <code>z</code> followed by
      <code>y</code>; thus,
      <code>"xy"</code> or
      <code>"xzy"</code> but not
      <code>"xz"</code> or
      <code>"xdy"</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"xz*y"</code> </td>
     <td>
      <code>x</code> followed by any number of instances of
      <code>z</code>, followed by
      <code>y</code>;
   thus,
      <code>"xy"</code> or
      <code>"xzy"</code> or
      <code>"xzzzy"</code> but not
      <code>"xz"</code> or
      <code>"xdy"</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"xz+y"</code> </td>
     <td>
      <code>x</code> followed by one or more instances of
      <code>z</code>, followed by
      <code>y</code>;
   thus,
      <code>"xzy"</code> or
      <code>"xzzy"</code> but not
      <code>"xy"</code> or
      <code>"xz"</code> or
      <code>"xdy"</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"s[xyz]t"</code> </td>
     <td>
      <code>s</code> followed by any of the characters
      <code>x</code> or
      <code>y</code> or
      <code>z</code>, followed by
      <code>t</code>;
   thus,
      <code>"sxt"</code> or
      <code>"syt"</code> or
      <code>"szt"</code> but not
      <code>"st"</code> or
      <code>"sat"</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"a[x0-9]b"</code> </td>
     <td>
      <code>a</code> followed by either
      <code>x</code> or characters in the range
      <code>0</code> –
      <code>9</code>, followed by
      <code>b</code>;
   thus,
      <code>"axb"</code> or
      <code>"a0b"</code> or
      <code>"a4b"</code> but not
      <code>"ab"</code> or
      <code>"aab"</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"s[^xyz]t"</code> </td>
     <td>
      <code>s</code> followed by any character that is not
      <code>x</code> or
      <code>y</code> or
      <code>z</code>, followed by
      <code>t</code>;
   thus,
      <code>"sdt"</code> or
      <code>"set"</code> but not
      <code>"sxt"</code> or
      <code>"syt"</code> or
      <code>"szt"</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"s[^x0-9]t"</code> </td>
     <td>
      <code>s</code> followed by any character that is not
      <code>x</code> or in the range
      <code>0</code> –
      <code>9</code>, followed by
      <code>t</code>; thus,
      <code>"slt"</code> or
      <code>"smt"</code> but not
      <code>"sxt"</code> or
      <code>"s0t"</code> or
      <code>"s4t"</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"^x"</code> </td>
     <td>
      <code>x</code> at the beginning of a string; 
  thus,
      <code>"xzy"</code> or
      <code>"xzzy"</code> but not
      <code>"yzy"</code> or
      <code>"yxy"</code>.
     </td>
    </tr>
    <tr>
     <td>
      <code>"x$"</code> </td>
     <td>
      <code>x</code> at the end of a string; 
  thus,
      <code>"yzx"</code> or
      <code>"yx"</code> but not
      <code>"yxz"</code> or
      <code>"zxy"</code>.
     </td>
    </tr>
   </tbody>
  </table>

<p>
  There are a number of minor variants of regexp notation:
</p>
 <div class="orderedlist">
  <ol type="1">
   <li>
    <p>
     <em>Glob expressions.</em>
     This is the limited set
of wildcard conventions used by early Unix shells for filename
matching. There are only three wildcards:
     <code>*</code>, which matches any
sequence of characters (like
     <code>.*</code> in the other variants);
     <code>?</code>, which
matches any single character (like
     <code>.</code> in the other variants); and
     <code>[...]</code>, which matches a character class just as in the other variants.
Some shells (
     <em>csh</em>,
     <em>bash</em>,
     <em>zsh</em>) later
added
     <code>{}</code> for alternation.  Thus,
     <code>x{a,b}c</code> matches
     <code>xac</code> or
     <code>xbc</code> but not
     <code>xc</code>. Some shells further extend globs in the direction of extended
regular expressions.
    </p>
   </li>
   <li>
    <p>
     <em>Basic regular expressions.</em>
     This is the
notation accepted by the original
grep(1)
utility for extracting lines matching a given regexp from a file.  The
line editor
ed(1),
the stream editor
sed(1),
also use these.  Old Unix hands think of these as the basic or
‘vanilla’ flavor of regexp; people first exposed to the
more modern tools tend to assume the extended form described next.
    </p>
   </li>
   <li>
    <p>
     <em>Extended regular expressions.</em>
     This is the
notation accepted by the extended grep utility
egrep(1)
for extracting lines matching a given regexp from a file.  Regular
expressions in Lex and the
     <em>Emacs</em> editor are
very close to the
     <em>egrep</em> flavor.
    </p>
   </li>
   <li>
    <p>
     <em>Perl regular expressions.</em>
     This is the notation
accepted by Perl
     and Python
     regexp functions.  These are quite a bit more
powerful than the
     <em>egrep</em> flavor.
    </p>
   </li>
  </ol>
 </div>
<p>
  Now that we've looked at some motivating examples, Table 8.2 is a summary of the standard regular-expression
  wildcards.  Note: we're not including the glob variant in this table, so a value of “All” implies only all three of
  the basic, extended/Emacs, and Perl/Python variants.<sup><a href="#ftn.id2932978" id="id2932978">[81]</a></sup>
</p>

  <table class="border">
	  <caption>Table 8.2. Introduction to regular-expression operations.</caption>
   <thead>
    <tr>
     <th>
      Wildcard
     </th>
     <th>
      Supported in
     </th>
     <th>
      Matches
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      <code>\</code> </td>
     <td>
      All
     </td>
     <td>
      Escape next character.  Toggles whether following punctuation
  is treated as a wildcard or not. Following letters or digits are interpreted
  in various different ways depending on the program.
     </td>
    </tr>
    <tr>
     <td>
      <code>.</code> </td>
     <td>
      All
     </td>
     <td>
      Any character.
     </td>
    </tr>
    <tr>
     <td>
      <code>^</code> </td>
     <td>
      All
     </td>
     <td>
      Beginning of line
     </td>
    </tr>
    <tr>
     <td>
      <code>$</code> </td>
     <td>
      All
     </td>
     <td>
      End of line
     </td>
    </tr>
    <tr>
     <td>
      <code>[...]</code> </td>
     <td>
      All
     </td>
     <td>
      Any of the characters between the brackets
     </td>
    </tr>
    <tr>
     <td>
      <code>[^...]</code> </td>
     <td>
      All
     </td>
     <td>
      Any characters
      <em>except those</em>
      between the brackets.
     </td>
    </tr>
    <tr>
     <td>
      <code>*</code> </td>
     <td>
      All
     </td>
     <td>
      Accept any number of instances of the previous element.
     </td>
    </tr>
    <tr>
     <td>
      <code>?</code> </td>
     <td>
      egrep/Emacs, Perl/Python
     </td>
     <td>
      Accept zero or one instances of the previous element.
     </td>
    </tr>
    <tr>
     <td>
      <code>+</code> </td>
     <td>
      egrep/Emacs, Perl/Python
     </td>
     <td>
      Accept one or more instances of the previous element.
     </td>
    </tr>
    <tr>
     <td>
      <code>{n}</code> </td>
     <td>
      egrep, Perl/Python; as
      <code>\{n\}</code> in Emacs
     </td>
     <td>
      Accept exactly
      <code>n</code> repetitions of the previous element.
  Not supported by some older regexp engines.
     </td>
    </tr>
    <tr>
     <td>
      <code>{n,}</code> </td>
     <td>
      egrep, Perl/Python; as
      <code>\{n,\}</code> in Emacs
     </td>
     <td>
      Accept
      <code>n</code> or more repetitions of the previous element.
  Not supported by some older regexp engines.
     </td>
    </tr>
    <tr>
     <td>
      <code>{m,n}</code> </td>
     <td>
      egrep, Perl/Python; as
      <code>\{m,n\}</code> in Emacs
     </td>
     <td>
      Accept at least
      <code>m</code> and at most
      <code>n</code> repetitions of the previous 
  element. Not supported by some older regexp engines.
     </td>
    </tr>
    <tr>
     <td>
      <code>|</code> </td>
     <td>
      egrep, Perl/Python; as
      <code>\|</code> in Emacs
     </td>
     <td>
      Accept the element to the left or the element to the right.
  This is usually used with some form of pattern-grouping delimiters.
     </td>
    </tr>
    <tr>
     <td>
      <code>(...)</code> </td>
     <td>
      Perl/Python; as
      <code>\(...\)</code> in older versions.
     </td>
     <td>
      Treat this pattern as a group (in newer regexp engines like
  Perl and Python's). Older regexp engines such as those in Emacs and grep
  require
      <code>\(...\)</code>.
     </td>
    </tr>
   </tbody>
  </table>
<p>
  Design practice in new languages with regexp support has
stabilized on the Perl/Python variant. It is more transparent than the
others, notably because backlash before a non-alphanumeric character
always means that character as a literal, so there is much
less confusion about how to quote elements of regexps.
</p>
<p>
  Regular expressions are an extreme example of how concise a 
minilanguage can be.  Simple regular expressions express recognition
behavior that would otherwise have to be implenented with hundreds of
lines of fussy, bug-prone code.
</p>
<h4 id="id2933450"><a href="#id2933450">§</a>Case Study: Glade</h4>
<p>
  <em>Glade</em> is an interface
builder for the open-source GTK toolkit library for
X.<sup><a href="#ftn.id2933471" id="id2933471">[82]</a></sup>
  <em>Glade</em> allows you to develop a
GUI interface by interactively picking, placing, and modifying widgets
on an interface panel.  The GUI editor produces an XML file describing
the interface; this, in turn, can be fed to one of several code
generators that will actually grind out C,
C++,
Python
  or
Perl
  code for
the interface.  The generated code then calls functions you write to
supply behavior to the interface.
</p>
<p>
  <em>Glade</em> 's XML format for describing GUIs is a good example of a simple domain-specific minilanguage.  See
  Example 8.1 for a “Hello, world!” GUI in Glade format.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 8.1. Glade “Hello, World”.
   </b>
  </p>
  <pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;GTK-Interface&gt;

&lt;widget&gt;
  &lt;class&gt;GtkWindow&lt;/class&gt;
  &lt;name&gt;HelloWindow&lt;/name&gt;
  &lt;border_width&gt;5&lt;/border_width&gt;
  &lt;Signal&gt;
    &lt;name&gt;destroy&lt;/name&gt;
    &lt;handler&gt;gtk_main_quit&lt;/handler&gt;
  &lt;/Signal&gt;
  &lt;title&gt;Hello&lt;/title&gt;
  &lt;type&gt;GTK_WINDOW_TOPLEVEL&lt;/type&gt;
  &lt;position&gt;GTK_WIN_POS_NONE&lt;/position&gt;
  &lt;allow_shrink&gt;True&lt;/allow_shrink&gt;
  &lt;allow_grow&gt;True&lt;/allow_grow&gt;
  &lt;auto_shrink&gt;False&lt;/auto_shrink&gt;

  &lt;widget&gt;
    &lt;class&gt;GtkButton&lt;/class&gt;
    &lt;name&gt;Hello World&lt;/name&gt;
    &lt;can_focus&gt;True&lt;/can_focus&gt;
    &lt;Signal&gt;
      &lt;name&gt;clicked&lt;/name&gt;
      &lt;handler&gt;gtk_widget_destroy&lt;/handler&gt;
      &lt;object&gt;HelloWindow&lt;/object&gt;
    &lt;/Signal&gt;
    &lt;label&gt;Hello World&lt;/label&gt;
  &lt;/widget&gt;
&lt;/widget&gt;

&lt;/GTK-Interface&gt;
</pre>
 </div>
<p>
  A valid specification in
  <em>Glade</em> format implies a repertoire of actions
by the GUI in response to user behavior.  The
  <em>Glade</em> GUI treats these specifications as
structured data files;
  <em>Glade</em> code
generators, on the other hand, use them to write programs implementing
a GUI.  For some languages (including Python), there are runtime libraries that
allow you to skip the code-generation step and simply instantiate the
GUI directly at runtime from the XML specification (interpreting Glade
markup, rather than compiling it to the host language).  Thus, you get
the choice of trading space efficiency for startup speed or
vice versa.
</p>
<p>
  Once you get past the verbosity of XML,
  <em>Glade</em> markup is a fairly simple language.
It does just two things: declare GUI-widget hierarchies and associate
properties with widgets.  You don't actually have to know a lot about
how
  <em>glade</em> works to read the specification
above.  In fact, if you have any experience programming in GUI
toolkits, reading it will immediately give you a fairly good
visualization of what
  <em>glade</em> does with the
specification.  (Hands up everyone who predicted that this particular
specification will give you a single button widget in a window
frame.)
</p>
<p>
  This kind of transparency and simplicity is the mark of a good
minilanguage
design.  The mapping between the notation and
domain objects is very clear.  The relationships between objects are
expressed directly, rather than through name references or some other
sort of indirection that you have to think to follow.
</p>
<p>
  The ultimate functional test of a minilanguage like this one is
simple: can I hack it without reading the manual?  For a significant
range of cases, the
  <em>Glade</em> answer
is yes.  For example, if you know the C-level constants that GTK uses
to describe window-positioning hints, you'll recognize
  <code>GTK_WIN_POS_NONE</code> as one and instantly be able to
change the positioning hint associated with this GUI.
</p>
<p>
  The advantage of using
  <em>Glade</em> should be clear.  It specializes in
code generation so you don't have to.  That's one less routine task
you have to hand-code, and one fewer source of hand-coded bugs.
</p>
<p>
  More information, including source code and documentation and
links to sample applications, is available at the
  <a href="http://glade.gnome.org/">
   Glade project page</a>.
  <em>Glade</em> has been ported to
Windows.
</p>
<h4 id="id2933775"><a href="#id2933775">§</a>Case Study: m4</h4>
<p>
  The
m4(1)
macro processor interprets a declarative minilanguage for describing
transformations of text.  An
  <em>m4</em> program is
a set of macros that specifies ways to expand text strings into other
strings.  Applying those declarations to an input text with
  <em>m4</em> performs macro expansion and yields an output text.  (The
C
  preprocessor performs similar services for C compilers,
though in a rather different style.)
</p>
<p>
   Example 8.2 shows an <em>m4</em> macro that directs <em>m4</em> to expand each occurrence of the string "OS" in its
   input into the string "operating system" on output.  This is a trivial example; <em>m4</em> supports macros with
   arguments that can be used to do more than transform one fixed string into another.  Typing <code>info m4</code> at
   your shell prompt will probably display on-line documentation for this language.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 8.2. A sample
    <em>m4</em> macro.
   </b>
  </p>
  <pre class="programlisting">
define(`OS', `operating system')
</pre>
 </div>
<p>
  The
  <em>m4</em> macro language supports
conditionals and recursion.  The combination can be used to implement
loops, and this was intended;
  <em>m4</em> is
deliberately Turing-complete.  But actually trying to use
  <em>m4</em> as a general-purpose language would be
deeply perverse.
</p>
<p>
  The
  <em>m4</em> macro processor is usually
employed as a preprocessor for minilanguages that lack a built-in
notion of named procedures or a built-in file-inclusion feature.  It's
an easy way to extend the syntax of the base language so the
combination with
  <em>m4</em> supports both these
features.
</p>
<p>
  One well-known use of
  <em>m4</em> has been to
clean up (or at least effectively hide) another minilanguage design
that was called out as a bad example earlier in this chapter.  Most
system administrators now generate their
  <code>sendmail.cf</code> configuration files using an
  <em>m4</em> macro package supplied with the
  <em>sendmail</em> distribution.  The macros
start from feature names (or name/value pairs) and generate the
corresponding (much uglier) strings in the
  <em>sendmail</em> configuration language.
</p>
<p>
  Use
  <em>m4</em> with caution, however.  Unix
experience has taught minilanguage designers to be wary of macro
expansion,<sup><a href="#ftn.id2934007" id="id2934007">[83]</a></sup>
  for reasons we'll discuss
  <a href="#macroexpansion" title="Macros — Beware!">later in the chapter</a>.
</p>
<h4 id="id2934034"><a href="#id2934034">§</a>Case Study: XSLT</h4>
<p>
  XSLT, like
  <em>m4</em> macros, is a
language for describing transformations of a text stream.  But it does
much more than simple macro substitution; it describes transformations
of XML data, including query and report generation.  It is the
language used to write XML stylesheets.  For practical applications,
see the description of XML document processing in
  <a href="#documentationchapter" title="Chapter 18. Documentation">
   Chapter 18</a>.  XSLT is described by a World Wide
Web Consortium standard and has several open-source
implementations.
</p>
<p>
  XSLT and
  <em>m4</em> macros are both purely
declarative and Turing-complete, but XSLT supports only recursions and
not loops. It is quite complex, certainly the most difficult language
to master of any in this chapter's case studies — and probably
the most difficult of any language mentioned in this
book.<sup><a href="#ftn.id2934079" id="id2934079">[84]</a></sup>
</p>
<p>
  Despite its complexity, XSLT really is a minilanguage.  It
shares important (though not universal) characteristics of the breed:
</p>
 <div>
  <ul>
   <li>
    <p>
     A restricted ontology of types, with (in particular) no analog 
of record structures or arrays.
    </p>
   </li>
   <li>
    <p>
     Restricted interface to the rest of the world.  XSLT processors are
designed to filter standard input to standard output, with a
limited ability to read and write files.  They can't open sockets
or run subcommands.
    </p>
   </li>
  </ul>
 </div>
 <div class="example">
  <p class="title">
   <b>
    Example 8.3. A sample XSLT program.
   </b>
  </p>
  <pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
                version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;
  &lt;xsl:template match="*"&gt;
    &lt;xsl:element name="{name()}"&gt;
      &lt;xsl:for-each select="@*"&gt;
        &lt;xsl:element name="{name()}"&gt;
          &lt;xsl:value-of select="."/&gt;
        &lt;/xsl:element&gt;
      &lt;/xsl:for-each&gt;
      &lt;xsl:apply-templates select="*|text()"/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt; 
&lt;/xsl:stylesheet&gt;
</pre>
 </div>
<p>
  The program in Example 8.3 transforms an XML document so that each attribute of every element is transformed into a
  new tag pair directly enclosed by that element, with the attribute value as the tag pair's content.
</p>
<p>
  We've included a glance at XSLT here partly to illustrate the point that ‘declarative’ does not imply either ‘simple’
  or ‘weak’, and mostly because if you have to work with XML documents, you will someday have to face the challenge that
  is XSLT.
</p>
<p>
  <em>XSLT: Mastering XML Transformations</em> <sup><a href="#Tidwell" title="[Tidwell]">[Tidwell]</a></sup> is a good introduction to the
language.  A brief tutorial with examples is available on the
Web.<sup><a href="#ftn.id2934184" id="id2934184">[85]</a></sup>
</p>
<h4 id="id2934197"><a href="#id2934197">§</a>Case Study: The Documenter's Workbench Tools</h4>
<p>
  The
troff(1)
typesetting formatter was, as we noted in
  <a href="#historychapter" title="Chapter 2. History">
   Chapter 2</a>, Unix's original killer application.
  <em>troff</em> is the center of a suite of
formatting tools (collectively called Documenter's Workbench or DWB),
all of which are domain-specific minilanguages of various kinds.  Most
are either preprocessors or postprocessors for
troff markup.  Open-source Unixes host an
enhanced implementation of Documenter's Workbench called
groff(1),
from the Free Software Foundation.
</p>
<p>
  We'll examine <em>troff</em> in more detail in <a href="#documentationchapter" title="Chapter 18. Documentation">
	  Chapter 18</a>; for now, it's sufficient to note that it is a good example of an imperative minilanguage that
  borders on being a full-fledged interpreter (it has conditionals and recursion but not loops; it is accidentally
  Turing-complete).
</p>
<p>
  The postprocessors (‘drivers’ in DWB terminology)
are normally not visible to
  <em>troff</em> users.
The original troff emitted codes for the
particular typesetter the Unix development group had available in
1970; later in the 1970s these were cleaned up into a
device-independent minilanguage for placing text and simple graphics
on a page.  The postprocessors translate this language (called
“ditroff” for “device-independent troff”)
into something modern imaging printers can actually accept — the
most important of these (and the modern default) is PostScript.
</p>
<p>
  The preprocessors are more interesting, because they actually
add capabilities to the troff language.
There are three common ones:
tbl(1)
for making tables,
eqn(1)
for typesetting mathematical equations, and
pic(1)
for drawing diagrams.  Less used, but still live, are
grn(1)
for graphics, and
refer(1)
and
bib(1)
for formatting bibliographies. Open-source equivalents of all of these
ship with
  <em>groff</em>.  The
grap(1)
preprocessor provided a rather versatile plotting facility; there is
an open-source implementation separate from
  <em>groff</em>.
</p>
<p>
  Some other preprocessors have no open-source implementation and
are no longer in common use. Best known of these was
ideal(1),
for graphics.  A younger sibling of the family,
chem(1),
draws chemical structural formulas; it is available as part of Bell
Labs's netlib code.<sup><a href="#ftn.id2934417" id="id2934417">[86]</a></sup>
</p>
<p>
  Each of these preprocessors is a little program that accepts a
minilanguage and compiles it into troff requests.  Each one recognizes
the markup it is supposed to interpret by looking for a unique start
and end request, and passes through unaltered any markup outside those
(
  <em>tbl</em> looks for
.TS/.TE,
  <em>pic</em> looks for
.PS/.PE, etc.).  Thus, most of the
preprocessors can normally be run in any order without stepping on
each other.  There are some exceptions: in particular,
  <em>chem</em> and
  <em>grap</em> both issue
  <em>pic</em> commands, and so must come
before it in the pipeline.
</p>
 <pre class="programlisting">
cat thesis.ms | chem | tbl | refer | grap | pic | eqn \
                                             | groff -Tps &gt;thesis.ps
</pre>
<p>
  The preceding is a full-Monty example of a Documenter's Workbench
processing pipeline,
for a hypothetical thesis incorporating chemical formulas,
mathematical equations, tables, bibliographies, plots, and diagrams.
(The
cat(1)
command simply copies its input or a file argument to its output; we
use it here to emphasize the order of operations.)  In practice modern
troff implementations tend to support
command-line options that can invoke at least
tbl(1),
eqn(1)
and
pic(1),
so it isn't necessary to write such an elaborate pipeline.  Even if it
were, these sorts of build recipes are normally composed just once and
stashed away in a makefile or shellscript wrapper for repeated use.
</p>
<p>
  The document markup of Documenter's Workbench is in some ways
obsolete, but the range of problems these preprocessors address gives
some indication of the power of the minilanguage model — it
would be extremely difficult to embed equivalent knowledge into a
WYSIWYG word processor.  There are some ways in which modern XML-based
document markups and toolchains are still, in 2003, playing
catch-up with capabilities that Documenter's Workbench had in 1979.
We'll discuss these issues in more detail in
  <a href="#documentationchapter" title="Chapter 18. Documentation">
   Chapter 18</a>.
</p>
<p>
  The design themes that gave Documenter's Workbench so much power
should by now be familiar ones; all the tools share a common
text-stream representation of documents, and the formatting system is
broken up into independent components that can be debugged and
improved separately.  The pipeline architecture supports plugging in
new, experimental preprocessors and postprocessors without disturbing
old ones.  It is modular and extensible.
</p>
<p>
  The architecture of Documenter's Workbench as a whole teaches us
some things about how to fit multiple specialist minilanguages into a
cooperating system. One preprocessor can build on another.  Indeed,
the Documenter's Workbench tools were an early exemplar of the power
of pipes, filtering, and minilanguages that influenced a lot of later
Unix design by example.  The design of the individual preprocessors
has more lessons to teach about what effective minilanguage designs
look like.
</p>
<p>
  One of these lessons is negative. Sometimes users writing
descriptions in the minilanguages do unclean things with low-level
troff markup inserted by hand.  This can
produce interactions and bugs that are hard to diagnose, because the
generated troff coming out of the pipeline
is not visible — and would not be readable if it were.  This is
analogous to the sorts of bugs that happen in code that mixes C with
snippets of in-line assembler.  It might have been better to separate
the language layers more completely, if that were possible.
Minilanguage designers should take note of this.
</p>
<p>
  All the preprocessor languages (though not troff markup itself)
have relatively clean, shell-like syntaxes that follow many of the
conventions we described in
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>
  for the design of data-file formats.
There are a few embarrassing exceptions; notably,
tbl(1)
defaults to using a tab as a field separator between table columns,
replicating an infamous botch in the design of
make(1)
and causing annoying bugs when editors or other tools invisibly change
the composition of whitespace.
</p>
<p>
  While troff itself is a specialized
imperative language, one theme that runs through at least three of the
Documenter's Workbench minilanguages is declarative semantics: doing
layout from constraints.  This is an idea that shows up in modern GUI
toolkits as well — that, instead of giving pixel coordinates for
graphical objects, what you really want to do is declare spatial
relationships among them (“widget A is above widget B, which is
to the left of widget C”) and have your software compute a
best-fit layout for A, B, and C according to those constraints.
</p>
<p>
  The pic(1) program uses this approach to lay out elements for diagrams.  The language taxonomy diagram at Figure 8.1
  was produced with
the
  <em>pic</em> source code in Example 8.4<sup><a href="#ftn.id2934708" id="id2934708">[87]</a></sup> run through
  <em>pic2graph</em>, one of our case studies in <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
  Chapter 7</a>.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 8.4. Taxonomy of languages — the
    <em>pic</em> source.
   </b>
  </p>
  <pre class="programlisting">
# Minilanguage taxonomy
#
# Base ellipses
define smallellipse {ellipse width 3.0 height 1.5}
M: ellipse width 3.0 height 1.8 fill 0.2
line from M.n to M.s dashed
D: smallellipse() with .e at M.w + (0.8, 0)
line from D.n to D.s dashed
I: smallellipse() with .w at M.e - (0.8, 0)
#
# Captions
"" "Data formats" at D.s
"" "Minilanguages" at M.s
"" "Interpreters" at I.s
#
# Heads
arrow from D.w + (0.4, 0.8) to D.e + (-0.4, 0.8)
"flat to structured" "" at last arrow.c
arrow from M.w + (0.4, 1.0) to M.e + (-0.4, 1.0)
"declarative to imperative" "" at last arrow.c
arrow from I.w + (0.4, 0.8) to I.e + (-0.4, 0.8)
"less to more general" "" at last arrow.c
#
# The arrow of loopiness
arrow from D.w + (0, 1.2) to I.e + (0, 1.2)
"increasing loopiness" "" at last arrow.c
#
# Flat data files
"/etc/passwd" ".newsrc" at 0.5 between D.c and D.w
# Structured data files
"SNG" at 0.5 between D.c and M.w
# Datafile/minilanguage borderline cases
"regexps" "Glade" at 0.5 between M.w and D.e
# Declarative minilanguages
"m4" "Yacc" "Lex" "make" "XSLT" "pic" "tbl" "eqn" \
			at 0.5 between M.c and D.e
# Imperative minilanguages
"fetchmail" "awk" "troff" "Postscript" at 0.5 between M.c and I.w
# Minilanguage/interpreter borderline cases
"dc" "bc" at 0.5 between I.w and M.e
# Interpreters
"Emacs Lisp" "JavaScript" at 0.25 between M.e and I.e
"sh" "tcl" at 0.55 between M.e and I.e
"Perl" "Python" "Java" at 0.8 between M.e and I.e
</pre>
 </div>
<p>
  This is a very typical Unix minilanguage design, and as such has
some points of interest even on the purely syntactic level.  Notice
how much it looks like a shell program: # leads comments, and
the syntax is obviously token-oriented with the simplest possible
convention for strings.  The designer of
pic(1)
knew that Unix programmers expect minilanguage syntaxes to look like
this unless there is a strong and specific reason they should not.
The Rule of Least Surprise is in full operation here.
</p>
<p>
  It probably doesn't take a lot of effort to discern that the
first line of code is a macro definition; the later references to
  <code>smallellipse()</code> encapsulate a repeated design
element of the diagram.  Nor will it take much scrutiny to deduce that
  <code>box invis</code> declares a box with invisible borders,
actually just a frame for text to be stacked inside.  The
  <code>arrow</code> command is equally obvious.
</p>
<p>
  With these as clues and one eye on the actual diagram, the
meaning of the remaining pieces of the syntax (position references
like
  <code>M.s</code> and constructions like
  <code>last arrow</code> or
  <code>
   at
0.25 between M.e and I.e
  </code>
  or the addition of vector offsets
to a location) should become rapidly apparent.  As with
Glade markup and
  <em>m4</em>, an
example like this one can teach a good bit of the language without any
reference to a manual (a compactness property
troff(1)
markup, unfortunately, does
  <em>not</em>
  have).
</p>
<p>
  The example of
pic(1)
reflects a common design theme in minilanguages, which we also
saw reflected in Glade — the use of a
minilanguage interpreter to encapsulate some form of constraint-based
reasoning and turn it into actions.  We could actually choose to view
pic(1)
as an imperative language rather than a declarative one; it has
elements of both, and the dispute would quickly grow
theological.
</p>
<p>
  The combination of macros with constraint-based layout gives
pic(1)
the ability to express the structure of diagrams in a way that more
modern vector-based markups like SVG cannot.  It is therefore
fortunate that one effect of the Documenter's Workbench design is to
make it relatively easy to keep
pic(1)
useful outside the DWB context.  The
  <em>pic2graph</em> script we used as a case study in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  was an
ad-hoc way to accomplish this, using the retrofitted PostScript
capability of
groff(1)
as a half-way step to a modern bitmap format.
</p>
<p>
  A cleaner solution is the
pic2plot(1)
utility distributed with the GNU plotutils
package, which
exploited the internal modularity of the GNU
pic(1)
code.  The code was split into a parsing front end and a back end that
generated troff markup, the two communicating through a layer of
drawing primitives.  Because this design obeyed the Rule of
Modularity,
  <em>pic2plot(1)</em> implementers were able to split off the GNU
  <em>pic</em> parsing stage and reimplement the
drawing primitives using a modern plotting library.  Their solution
has the disadvantage, however, that text in the output is generated
with fonts built into
  <em>pic2plot</em> that won't
match those of troff.
</p>
<h4 id="fetchmailrc"><a href="#fetchmailrc">§</a>
  Case Study:
fetchmail Run-Control Syntax
 </h4>
<p>
  See Example 8.5 for an example.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 8.5. Synthetic example of a
    <code>fetchmailrc</code>.
   </b>
  </p>
  <pre class="programlisting">
# Poll this site first each cycle.
poll pop.provider.net proto pop3
    user "jsmith" with pass "secret1" is "smith" here
    user jones with pass "secret2" is "jjones" here with options keep

# Poll this site second, unless Lord Voldemort zaps us first.
poll billywig.hogwarts.com with proto imap:
    user harry_potter with pass "floo" is harry_potter here

# Poll this site third in the cycle.  
# Password will be fetched from ~/.netrc
poll mailhost.net with proto imap:
    user esr is esr here
</pre>
 </div>
<p>
  This run-control file can be viewed as an imperative
minilanguage.  There is an implied flow of execution: cycle through
the list of poll commands repeatedly (sleeping for a while at the end
of each cycle), and for each site entry collect mail for each
associated user in sequence.  It is far from being general-purpose; 
all it can do is sequence the program's polling behavior.
</p>
<p>
  As with
pic(1),
one could choose to view this minilanguage as either declarations or a
very weak imperative language, and argue endlessly over the
distinction.  On the one hand, it has neither conditionals nor
recursion nor loops; in fact, it has no explicit control structures at
all.  On the other hand, it does describe actions rather than just
relationships, which distinguishes it from a purely declarative syntax
like Glade GUI descriptions.
</p>
<p>
  Run-control minilanguages for complex programs often straddle
this border.  We're making a point of this fact because not having
explicit control structures in an imperative minilanguage can be a
tremendous simplification if the problem domain lets you get away
with it.
</p>
<p>
  One notable feature of
  <code>.fetchmailrc</code> syntax
is the use of optional noise keywords that are supported simply in
order to make the specifications read a bit more like English.  The
‘with’ keywords and single occurrence of
‘options’ in the example aren't actually necessary, but
they help make the declarations easier to read at a glance.
</p>
<p>
  The traditional term for this sort of thing is
  <em>syntactic sugar</em>; the maxim that goes with this
is a famous quip that “syntactic sugar causes cancer of the
semicolon”.<sup><a href="#ftn.id2935218" id="id2935218">[88]</a></sup>
  Indeed, syntactic sugar needs to be used
sparingly lest it obscure more than help.
</p>
<p>
  In
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>
  we'll see how data-driven programming helps provide an elegant
solution to the problem of editing
  <em>fetchmail</em> run-control files through a
GUI.
</p>
<h4 id="awk"><a href="#awk">§</a>Case Study: awk</h4>
<p>
  The
  <em>awk</em> minilanguage is an old-school
Unix tool, formerly much used in shellscripts.  Like
  <em>m4</em>, it's intended for writing small but
expressive programs to transform textual input into textual output.
Versions ship with all Unixes, several in open source; the command
  <code>info gawk</code> at your Unix shell prompt is quite likely
to take you to on-line documentation.
</p>
<p>
  Programs in
  <em>awk</em> consist of
pattern/action pairs.  Each pattern is a
  <em>regular expression</em>, a concept we'll describe in detail in
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>.  When an
  <em>awk</em> program is run, it steps through each line of the input file.  Each
line is checked against every pattern/action pair in order.  If the
pattern matches the line, the associated action is performed.
</p>
<p>
  Each action is coded in a language resembling a subset of C, with
variables and conditionals and loops and an ontology of types
including integers, strings, and (unlike C)
dictionaries.<sup><a href="#ftn.id2935337" id="id2935337">[89]</a></sup>
</p>
<p>
  The
  <em>awk</em> action language is
Turing-complete, and can read and write files. In some versions it can
open and use network sockets.  But
  <em>awk</em> has
primarily seen use as a report generator, especially for interpreting
and reducing tabular data.  It is seldom used standalone, but rather
embedded in scripts.  There is an example
  <em>awk</em> program in the
  <a href="#htmlgen" title="Case Study: Generating HTML Code for a Tabular List">case study on HTML generation</a>
  included in <a href="#generationchapter" title="Chapter 9. Generation">Chapter 9</a>.
</p>
<p>
  A case study of
  <em>awk</em> is included to
point out that it is
  <em>not</em>
  a model for emulation;
in fact, since 1990 it has largely fallen out of use. It has been
superseded by new-school scripting
languages
  —notably 
Perl, which was explicitly designed to be an
  <em>awk</em> killer.  The reasons are worthy of
examination, because they constitute a bit of a cautionary tale for
minilanguage designers.
</p>
<p>
  The
  <em>awk</em> language was originally
designed to be a small, expressive special-purpose language for report
generation.  Unfortunately, it turns out to have been designed at a
bad spot on the complexity-vs.-power curve.  The action language is
noncompact, but
the pattern-driven framework it sits inside keeps it from being
generally applicable — that's the worst of both worlds.  And the
new-school scripting languages can do anything
  <em>awk</em> can; their equivalent programs are
usually just as readable, if not more so.
</p>
 <blockquote>
  <p>
   Awk has also fallen out of use because more modern shells have
floating point arithmetic, associative arrays, RE pattern matching,
and substring capabilities, so that equivalents of small awk scripts
can be done without the overhead of process creation.
  </p>
  <span>
   – David Korn
  </span>
 </blockquote>
<p>
  For a few years after the release of Perl in 1987,
  <em>awk</em> remained competitive simply because it
had a smaller, faster implementation.  But as the cost of compute
cycles and memory dropped, the economic reasons for favoring a
special-purpose language that was relatively thrifty with both lost
their force. Programmers increasingly chose to do awklike things with
Perl or (later) Python, rather than keep two different scripting
languages
  in their heads.<sup><a href="#ftn.id2935542" id="id2935542">[90]</a></sup>
  By the year 2000
  <em>awk</em> had become little more than a memory
for most old-school Unix
hackers, and not a
particularly nostalgic one.
</p>
<p>
  Falling costs have changed the tradeoffs in minilanguage design.
Restricting your design's capabilities to buy
compactness
  may
still be a good idea, but doing so to economize on machine resources
is a bad one.  Machine resources get cheaper over time, but space in
programmers' heads only gets more expensive.  Modern minilanguages can
either be general but noncompact, or specialized but very
compact; specialized
but noncompact simply won't compete.
</p>
<h4 id="id2935613"><a href="#id2935613">§</a>Case Study: PostScript</h4>
<p>
  PostScript is a minilanguage specialized for describing typeset
text and graphics to imaging devices. It is an import into Unix,
based on design work done at the legendary Xerox Palo Alto
Research Center
  along with the earliest laser printers.  For years after its first
commercial release in 1984, it was available only as a proprietary
product from Adobe, Inc., and was primarily associated with Apple
computers.  It was cloned under license terms very close to
open-source in 1988, and has since become the de-facto standard for
printer control under Unix.  A fully open-source version is shipped
with most most modern Unixes.<sup><a href="#ftn.id2935641" id="id2935641">[91]</a></sup>
  A good technical introduction to PostScript is also
available.<sup><a href="#ftn.id2935658" id="id2935658">[92]</a></sup>
</p>
<p>
  PostScript bears some functional resemblance to troff markup;
both are intended to control printers and other imaging devices, and
both are normally generated by programs or macro packages rather than
being hand-written by humans.  But where troff requests are a
jumped-up set of format-control codes with some language features
tacked on as an afterthought, PostScript was designed from the ground
up as a language and is far more expressive and powerful.  The main
thing that makes Postscript useful is that algorithmic descriptions of
images written in it are far smaller than the bitmaps they render to,
and so take up less storage and communication bandwidth.
</p>
<p>
  PostScript is explicitly Turing-complete, supporting
conditionals and loops and recursion and named procedures.  The
ontology of types includes integers, reals, strings, and arrays (each
element of an array may be of any type) but no equivalent of
structures.  Technically, PostScript is a stack-based language;
arguments of PostScript's primitive procedures (operators) are normally
popped off a push-down stack of arguments, and the result(s) are pushed
back onto it.
</p>
<p>
  There are about 40 basic operators out of a total of around 400.
The one that does most of the work is <code>show</code>, which
draws a string onto the page.  Others set the current font, change the
gray level or color, draw lines or arcs or Bezier curves, fill closed
regions, set clipping regions, etc.  A PostScript interpreter is
supposed to be able to interpret these commands into bitmaps to be
thrown on a display or print medium.
</p>
<p>
  Other PostScript operators implement arithmetic, control
structures, and procedures. These allow repetitive or stereotyped
images (such as text, which is composed of repeated letterforms) to be
expressed as programs that combine images.  Part of the utility of
PostScript comes from the fact that PostScript programs to print text or
simple vector graphics are much less bulky than the bitmaps the text
or vectors render to, are device-resolution independent, and travel more
quickly over a network cable or serial line.
</p>
<p>
  Historically, PostScript's stack-based interpretation resembles
a language called FORTH, originally designed to control telescope
motors in real time, which was briefly popular in the 1980s.
Stack-based languages are famous for supporting extremely tight,
economical coding and infamous for being difficult to read.
PostScript shares both traits.
</p>
<p>
  PostScript is often implemented as firmware built into a
printer.  The open-source implementation Ghostscript can translate
PostScript to various graphics formats and (weaker) printer-control
languages.  Most other software treats PostScript as a final output
format, meant to be handed to a PostScript-capable imaging device but
not edited or eyeballed.
</p>
<p>
  PostScript (either in the original or the trivial variant
EPSF, with a bounding box
declared around it so it can be embedded in other graphics) is a very
well designed example of a special-purpose control language and
deserves careful study as a model. It is a component of other
standards such as PDF, the Portable Document Format.
</p>
<h4 id="id2935779"><a href="#id2935779">§</a>Case Study: bc and dc</h4>
<p>
  We first examined bc(1) and dc(1) in <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming"> Chapter 7</a>
  as a case study in shellouts.  They are examples of domain-specific minilanguages of the imperative type.
</p>
 <blockquote>
  <p>
   <em>dc</em> is the oldest language on Unix; it
was written on the PDP-7 and ported to the PDP-11 before Unix [itself]
was ported.
  </p>
  <span>
   – Ken Thompson
  </span>
 </blockquote>
<p>
  The domain of these two languages is unlimited-precision
arithmetic.  Other programs can use them to do such calculations
without having to worry about the special techniques needed to do
those calculations.
</p>
 <blockquote>
  <p>
   In fact, the original motivation for dc had nothing to do with
providing a general-purpose interactive calculator, which could have
been done with a simple floating-point program.  The motivation was
Bell Labs' long interest in numerical analysis: calculating constants
for numerical algorithms,
   <em>accurately</em>
   is greatly
aided by being able to work to much higher precision than the
algorithm itself will use.  Hence dc's arbitrary-precision
arithmetic.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  Like SNG and
  <em>Glade</em> markup, one of the
strengths of both of these languages is their simplicity.  Once you
know that
dc(1)
is a reverse-Polish-notation calculator and
bc(1)
an algebraic-notation calculator, very little about interactive use of
either of these languages is going to be novel.  We'll return to the
importance of the Rule of Least Surprise in interfaces in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>.
</p>
<p>
  These minilanguages have both conditionals and loops; they are
Turing-complete, but have a very restricted ontology of types
including only unlimited-precision integers and strings.  This puts
them in the borderland between interpreted minilanguages and full
scripting languages.  The programming features have been
designed not to intrude on the common use as a calculator; indeed,
most
  <em>dc</em> /
  <em>bc</em> users
are probably unaware of them.
</p>
<p>
  Normally,
  <em>dc</em> /
  <em>bc</em> are used
conversationally, but their capacity to support libraries of
user-defined procedures gives them an additional kind of utility
— programmability. This is actually the most important advantage
of imperative minilanguages, one that we observed in the case study
of the Documenter's Workbench tools to be very powerful whether or not
a program's normal mode is conversational; you can use them to write
high-level programs that embody task-specific intelligence.
</p>
<p>
  Because the interface of
  <em>dc</em> /
  <em>bc</em> is so
simple (send a line containing an expression, get back a line
containing a value) other programs and scripts can easily get access
to all these capabilities by calling these programs as slave
processes.
   Example 8.6 is one famous example, an implementation of the Rivest-Shamir-Adelman public-key cipher in Perl that was
   widely published in signature blocks and on T-shirts as a protest against U.S. export retrictions on cryptography, c.
   1995; it shells out to <em>dc</em> to do the unlimited-precision arithmetic required.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 8.6. RSA implementation using
    <em>dc</em>.
   </b>
  </p>
  <pre class="programlisting">
print pack"C*",split/\D+/,`echo "16iII*o\U@{$/=$z;[(pop,pop,unpack
"H*",&lt;&gt;)]}\EsMsKsN0[lN*1lK[d2%Sa2/d0&lt;X+d*lMLa^*lN%0]dsXx++\
lMlN/dsM0&lt;J]dsJxp"|dc`
</pre>
 </div>
<h4 id="emacs_lisp_study"><a href="#emacs_lisp_study">§</a>Case Study: Emacs Lisp</h4>
<p>
  Rather than merely being run as a slave process to accomplish
specific tasks, a special-purpose interpreted language can become the
core of an entire architecture; we'll consider the advantages and
disadvantages of this approach in
  <a href="#complexitychapter" title="Chapter 13. Complexity">
   Chapter 13</a>.  troff requests were an early example;
today, the
  <em>Emacs</em> editor is one of the
best-known and most powerful modern ones.  It's built around a dialect
of Lisp
  with
primitives for both describing actions on editing buffers and
controlling slave processes.
</p>
<p>
  The fact that Emacs is built around a powerful language for
describing editing actions or front ends for other programs means that
it can be used for many other things besides ordinary editing.  We'll
examine the applications of Emacs's task-specific intelligence for
day-to-day program development (compilation, debugging, version
control) in
  <a href="#toolschapter" title="Chapter 15. Tools">
   Chapter 15</a>. Emacs ‘modes’
are user-defined libraries — programs written in Emacs Lisp that
specialize the editor for a particular job — usually, but not
necessarily, one related to editing.
</p>
<p>
  Thus there are specialized modes that know the syntax of a large
number of programming languages, and of markup languages like
SGML, XML, and HTML. But
many people also use Emacs modes to send
and receive email (these use Unix system mail utilities as slaves) or
Usenet news. Emacs can browse the web, or act as a front-end for
various chat programs. There is also a calendaring package, Emacs's
own calculator program, and even a fairly wide selection of games
written as Emacs Lisp modes (including a descendant of the famous
ELIZA program that simulates a Rogersian psychiatrist).<sup><a href="#ftn.id2936188" id="id2936188">[93]</a></sup>
</p>
<h4 id="javascript"><a href="#javascript">§</a>Case Study: JavaScript</h4>
<p>
  JavaScript is an open-source language designed to be embedded in
C
  programs. Though
it is also embedded in web servers, its original and best-known
manifestation is client-side JavaScript, which allows you to embed
executable code in Web pages to be run by any JavaScript-capable
browser.  That is the version we will survey here.
</p>
<p>
  JavaScript is a fully Turing-complete interpreted language with
integers, real numbers, booleans, strings, and lightweight
dictionary-based objects resembling those of
Python.
Values are typed, but variables can hold any type; conversions between
types are automatic in many contexts.  Syntactically JavaScript resembles
Java
  with some
influence from Perl, and features Perl-like regular
expressions.
</p>
<p>
  Despite all these features, client-side JavaScript is not quite a
general-purpose language.  Its capabilities are severely restricted
to prevent attacks on the browser user through Web pages
containing JavaScript code.  It can accept input from the user and
generate or modify Web pages, but it cannot directly alter the
contents of disk files and cannot open its own network
connections.
</p>
<p>
  Over time, the JavaScript language has become more general and
less bound to its client-side environment.  This is something that can
be expected to happen to any successful specialized language as its
possibilities unfold in the minds of developers and users.  Client
JavaScript now interacts with its environment by reading and writing
values in a single special object called the browser DOM (Document
Object Model).  The language still has some legacy APIs to the browser
that don't go through the DOM, but these are deprecated, not present
in the ECMA-262 standard for JavaScript, and may not be supported in
future versions.
</p>
<p>
  The standard reference for JavaScript is
  <em>JavaScript: The Definitive Guide</em><sup><a href="#FlanaganJavaScript" title="[FlanaganJavaScript]">[FlanaganJavaScript]</a></sup>.  Source code
is downloadable.<sup><a href="#ftn.id2936325" id="id2936325">[94]</a></sup>
  JavaScript makes an interesting study for two reasons. First, it's
about as close to being a general-purpose language as one can get
without actually being there.  Second, the binding between client-side
JavaScript and its browser environment via a single DOM object is well
designed, and could serve as a model for other embedding
situations.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2932978" id="ftn.id2932978">[81]</a></sup>
  The POSIX
standard for regular expressions introduces some symbolic ranges like
  <code>[[:lower;;]]</code> and
  <code>[[:digit:]]</code>, and some specific tools have extra
wildcards not covered here, but these will suffice to interpret most
regexps.
</p>

<p><sup><a href="#id2933471" id="ftn.id2933471">[82]</a></sup>
  For non-Unix programmers, an X toolkit is a graphics
library that supplies GUI widgets (like labels, buttons, and pull-down
menus) to the programs that link to it.  Under most other graphical
operating systems, the OS supplies one toolkit that everyone uses.
Unix and X support multiple toolkits; this is part of the separation
of policy from mechanism that we called out as a design goal of X in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>. GTK and Qt
are the two most popular open-source X toolkits.
</p>

<p><sup><a href="#id2934007" id="ftn.id2934007">[83]</a></sup>
  Whether or not “macro expansion”
should be spelled “macroexpansion” is a matter for some
dispute.  The latter is found mainly among Lisp
programmers.
</p>

<p><sup><a href="#id2934079" id="ftn.id2934079">[84]</a></sup>
  It is not clear that XSLT could be any simpler
and still do its job, however, so we cannot characterize it as a bad
design.
</p>

<p><sup><a href="#id2934184" id="ftn.id2934184">[85]</a></sup>
  <a href="http://nwalsh.com/docs/tutorials/xsl/xsl/slides.html">
   XSL
Concepts and Practical Use</a>.
</p>

<p><sup><a href="#id2934417" id="ftn.id2934417">[86]</a></sup>
  <a href="http://www.netlib.org/">
   http://www.netlib.org/</a>
</p>

<p><sup><a href="#id2934708" id="ftn.id2934708">[87]</a></sup>
  It is also quite traditional
for Unix books that describe
pic(1)
to include their own illustrations as coding examples.
</p>

<p><sup><a href="#id2935218" id="ftn.id2935218">[88]</a></sup>
  The line is owed to Alan Perlis, who did
some of the pioneering work in software modularity around 1970. The
semicolon in question was the statement separator or terminator
in various Algol-descended languages, including Pascal and
C.
</p>

<p><sup><a href="#id2935337" id="ftn.id2935337">[89]</a></sup>
  For those who have never programmed in a
modern scripting language, a dictionary is a lookup table of
key-to-value associations, often implemented through a hash table.
C
  <a class="indexterm" id="id2935344"></a>
  programmers spend a lot
of their coding time implementing dictionaries in various elaborate
ways.
</p>

<p><sup><a href="#id2935542" id="ftn.id2935542">[90]</a></sup>
  I was at one time an
  <em>awk</em> wizard, but I had to be reminded by someone
else that the language was applicable to the HTML-generation problem
where this book's only
  <em>awk</em> example
occurs.
</p>

<p><sup><a href="#id2935641" id="ftn.id2935641">[91]</a></sup>
  There is a
  <a href="http://www.cs.wisc.edu/~ghost/">
   GhostScript Project
site</a>.
</p>

<p><sup><a href="#id2935658" id="ftn.id2935658">[92]</a></sup>
  <a href="http://www.cs.indiana.edu/docproject/programming/postscript/postscript.html">
   A First Guide To PostScript</a>.
</p>

<p><sup><a href="#id2936188" id="ftn.id2936188">[93]</a></sup>
  One of the silliest things you can do with a modern Unix machine
is run the Eliza mode of Emacs against
random quotes from Zippy the Pinhead.
  <code>M-x psychoanalyze-pinhead</code>; type control-G when you've had
enough.
</p>

<p><sup><a href="#id2936325" id="ftn.id2936325">[94]</a></sup>
  Open-source JavaScript implementations
in C and Java are
  <a href="http://www.mozilla.org/js/">
   available</a>.
</p>
</div>


<!-- FILE: ch08s03.html -->
<h3 id="ch08s03"><a href="#ch08s03">§</a>Designing Minilanguages</h3>
<p>
  When is designing a minilanguage appropriate?  We've observed
that minilanguages offer a way to push problem specifications to a
higher level, and seen how this operates in several case studies.  The
flip side of this observation is that a minilanguage is likely to be a
good approach whenever the domain primitives in your application area
are simple and stereotyped, but the ways in which users are likely to
want to apply them are fluid and varying.
</p>
<p>
  For some related ideas, find a description of the
  <a href="http://www.c2.com/cgi/wiki?AlternateHardAndSoftLayers">
   Alternate
Hard And Soft Layers</a>
  and
  <a href="http://www.doc.ic.ac.uk/~np2/patterns/scripting/scripting.html">
   Scripted
Components</a>
  design patterns.
</p>
<p>
  An interesting survey of design styles and techniques in
minilanguages is
  <em>Notable Design Patterns for Domain-Specific Languages</em><sup><a href="#Spinellis" title="[Spinellis]">[Spinellis]</a></sup>.
</p>
<h4 id="id2936413"><a href="#id2936413">§</a>Choosing the Right Complexity Level</h4>
<p>
  The first important thing to bear in mind when designing a
minilanguage is, as usual, to keep it as simple as possible.  The
taxonomy diagram we used to organize the case studies implies a
hierarchy of complexity; you want to keep your design as far toward the
left-hand edge as possible.  If you can get away with designing a
structured data file rather than a minilanguage that is going to
modify external data when it's interpreted, by all means do
so.
</p>
<p>
  One very pragmatic reason to stick with structured data rather
than a minilanguage is that in a networked world, embedded
minilanguage facilities are subject to abuses that can be inconvenient
or even dangerous.  JavaScript
  is a prime example in the
‘inconvenient’ category; its designers didn't anticipate
that it would be used for pop-up advertisements so obnoxious as to
create a demand for browser features that suppress JavaScript
interpretation.
</p>
<p>
  Microsoft Word
  macro viruses show how this sort of thing
can become actively dangerous, a security hole that costs billions of
dollars in downtime and lost productivity annually.  It is instructive
to note that despite the existence of at least twenty million Unix
users worldwide<sup><a href="#ftn.id2936473" id="id2936473">[95]</a></sup>
  there has never been any Unix equivalent
of Windows's frequent macro-virus outbreaks.  There are a number of
reasons for this, including the fundamentally better security design
of Unix; but at least one is the fact that Unix mail agents do
  <em>not</em>
  default to executing live content in any
document that the user
views.<sup><a href="#ftn.id2936490" id="id2936490">[96]</a></sup>
</p>
<p>
  If there is any way that your application's users might end up
running programs from untrusted sources, risky features of your
application minilanguage might end up having to be suppressed.
Languages like Java and JavaScript are explicitly
  <em>sandboxed</em> —that is, they have limited
access to their environment not merely to simplify their design but to
try to prevent potentially destructive operations by buggy or
malicious code.
</p>
<p>
  On the other hand, a lot of bad designs have been
botched by designers who failed to face up to the fact that they
really needed a minilanguage rather than a data-file format.  Too
often, language-like features get pasted on as an afterthought.
The two most common symptoms of this problem are weak, ad-hoc control
structures and poor or nonexistent facilities for declaring
procedures.
</p>
<p>
  It's risky to design minilanguages that are only accidentally
Turing-complete.  If you do this the odds are good that, sometime in
the future, some clever fellow is going to think he needs to press 
your language into doing loops and conditionals for him.  Because
these are only available in an obfuscated way, he'll produce
obfuscated code. The results may be serviceable in the short term, 
but are likely to be a nightmare for those who come after him.
</p>
<p>
  Minilanguage design is both powerful and esthetically rewarding,
but it's also full of similar traps.  There are kinds of design in
which it is appropriate to take the bottom-up approach of pasting
together a bunch of low-level services and worrying about their
organization after you have explored the problem domain for a
while.  One of the virtues of minilanguages is that they can help you
get a good design out of bottom-up programming by allowing you to
defer some top-down decisions into the control flow of programs in
your minilanguage.  But if you take a bottom-up approach to the minilanguage
design
  <em>itself</em>, you are likely to end up with an
ugly syntax reflecting a weak language and a poorly-thought-out
implementation.
</p>
<p>
  There are many places in a minilanguage design where small
choices make a large difference in the useability and ease of the
tool:
</p>
 <blockquote>
  <p>
   As a language designer, it is a good principle to consider the
alternatives to giving an error message.  When there is true ambiguity
in the intent of the programmer an error message is appropriate, but
in many cases the intent is clear, and making the language silently do
the right thing is a great boon.  A good example is C accommodating an
extra comma at the end of an array initializer list, which makes both
editing and machine generation of array initializers much easier.
Anti-examples are the pickiness of various HTML readers, especially
their habit of silently discarding parts of your document because of
trivial nesting errors.
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>
<p>
  On this issue, as elsewhere, there is no substitute for good
taste and engineering judgment.  If you're going to design a
minilanguage, don't do it halfway.  Declarative minilanguages should
have a clear, consistent language-like syntax designed to be readable
by humans.  Imperative ones should add a full range of control
structures adapted from language models you can expect your users to
be familiar with.  Think about the language
  <em>as</em>
  a
language; ask yourself esthetic questions like “Will this be
comfortable to program in?” and even “Will it be pleasant
to look at?” Here, as elsewhere in software design, David
Gelernter's maxim is apt: beauty is the ultimate defense against
complexity.
</p>
<h4 id="id2936650"><a href="#id2936650">§</a>Extending and Embedding Languages</h4>
<p>
  One fundamentally important question is whether you can
implement your minilanguage by extending or embedding an existing
scripting language.  This is often the right way to go
for an imperative minilanguage, but much less appropriate for a
declarative one.
</p>
<p>
  Sometimes it's possible to write your imperative language simply
by coding service functions in an interpreted language, which we'll
call the ‘host’ language for purposes of this
discussion. Your minilanguage programs are then just scripts that load
your service library and use the host language's control structures
and other facilities as a framework.  Every facility the host language
supplies is one you don't have to write.
</p>
<p>
  This is the easiest way to write a minilanguage.  Old-school
Lisp
  programmers (including me) love this technique and use it heavily.  It
underlies the design of the
  <em>Emacs</em> editor,
and has been rediscovered in the new-school scripting languages like
Tcl,
Python, and
Perl. There are
drawbacks to it, however.
</p>
<p>
  Your host language may be unable to interface to a code library
that you need.  Or, internally, its ontology of data types may be
inadequate for the kind of computation you need to do.  Or, after
measuring the performance of a prototype, you discover that it's too
slow.  When any of these things happen, your solution is usually
going to involve coding in C
  (or
C++) and integrating the
results into your minilanguage.
</p>
<p>
  The option of extending a scripting
language
  with C code, or of embedding a scripting language in a C program,
relies on the existence of scripting languages designed for it.  You
extend a scripting language by telling it to dynamically load a C
library or module in such a way that the C entry points become visible
as functions in the extended language.  You embed a scripting language
in a C program by sending commands to an instance of the interpreter
and receiving the results back as values in C.
</p>
<p>
  Both techniques also rely on the ability to move data between
the type ontology of C and the type ontology of your scripting
language.  Some scripting languages are designed from the ground up to
support this.  One such is Tcl, which we'll cover in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>.  Another is
  <em>Guile</em>, an open-source dialect of the
Lisp
  variant
Scheme.
  <em>Guile</em> is shipped as a library and
specifically designed to be embedded in C
  programs.
</p>
<p>
  It is possible (though in 2003 still rather painful and
difficult) to extend or embed Perl.  It is very easy to extend
Python
  and
only slightly more difficult to embed it; C extension is especially
heavily used in the Python world.  Java
  has an interface to call ‘native
methods’ in C, though the practice is explicitly discouraged
because it tends to break portability.  Most versions of shell are not
designed for embeddability and extension, but the Korn shell (ksh93
and later versions) is a notable exception.
</p>
<p>
  There are lots of bad reasons not to piggyback your imperative
minilanguage on an existing scripting
language.
One of the few good ones is that you actually want to implement your own
custom grammar for error checking.  If that's the case, then see the
advice about
  <em>yacc</em> and
  <em>lex</em> below.
</p>
<h4 id="id2936912"><a href="#id2936912">§</a>Writing a Custom Grammar</h4>
<p>
  For declarative minilanguages, one major question is whether or
not you should use XML as a base syntax and specify your grammar as an
XML document type.  This may well be the right thing for elaborately
structured declarative minilanguages, but the same caveats we noted in
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>
  about the
design of data-file formats apply — XML might be overkill.  If
you don't use XML, follow the Rule of Least Surprise by supporting the
Unix conventions we described for data files (simple token-oriented
syntax, supporting C
  backslash conventions, etc.).
</p>
<p>
  If you do need a custom grammar,
  <em>yacc</em> and
  <em>lex</em> (or their local equivalent in the
language you're using) should probably be your best friends, unless
the grammar of your language is so simple that hand-coding a
recursive-descent parser is trivial. Even then,
  <em>yacc</em> may give you better error recovery,
and a
  <em>yacc</em> specification will be easier to
modify as the language syntax evolves.  See
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>
  for a look at the
  <em>yacc</em> - and
  <em>lex</em> -derived tools available in different
implementation languages.
</p>
<p>
  Even if you decide you must implement your own syntax, consider
what mileage you can get from reusing existing tools.  If you need a
macro facility, consider whether preprocessing with
m4(1)
might be the right answer — but consider the cautions in the
next section first.
</p>
<h4 id="macroexpansion"><a href="#macroexpansion">§</a>Macros — Beware!</h4>
<p>
  Macro expansion facilities were a favored tactic for language
designers in early Unix; the C
  language has one, of course, and we have seen them show up in some of
the more complex special-purpose minilanguages like
pic(1).
The
  <em>m4</em> preprocessor provides a generic tool for implementing
macro-expanding preprocessors.
</p>
<p>
  Macro expansion is easy to specify and implement, and you can do
a lot of cute tricks with it.  Those early designers appear to have been
influenced by experience with assemblers, in which macro facilities
were often the only device available for structuring programs.
</p>
<p>
  The strength of macro expansion is that it knows nothing about
the underlying syntax of the base language, and can be used to extend
that syntax.  Unfortunately, this power is very easily abused to
produce code that is opaque, surprising, and a fertile source of
hard-to-characterize bugs.
</p>
<p>
  In C, the classic example of this sort of problem is a macro
such as this:
</p>
 <pre class="programlisting">
#define max(x, y)	x &gt; y ? x : y
</pre>
<p>
  There are at least two problems with this macro.  One is that it
can produce surprising results if either of the arguments is an
expression including an operator of lower precedence than
  <code>&gt;</code> or
  <code>?:</code>.
Consider the expression
  <code>
   max(a = b,
++c)
  </code>.  If the programmer has forgotten that
  <code>max</code> is a macro, he will be expecting the
assignment
  <code>a = b</code> and the preincrement
operation on
  <code>c</code> to be executed before
the resulting values are passed as arguments to
  <code>max</code>.
</p>
<p>
  But that's not what will happen.  Instead, the preprocessor will
expand this expression to
  <code>
   a = b &gt; ++c ? a = b :
++c
  </code>, which the C compiler's precedence rules make it
interpret as
  <code>
   a = (b &gt; ++c ? a = b :
++c)
  </code>.  The effect will be to assign to
  <code>a</code> !
</p>
<p>
  This sort of bad interaction can be headed off by coding the
macro definition more defensively.
</p>
 <pre class="programlisting">
#define max(x, y)	((x) &gt; (y) ? (x) : (y))
</pre>
<p>
  With this definition, the expansion would be
  <code>((a = b) &gt; (++c) ? (a = b) : (++c))</code>.  This
solves one problem — but notice that
  <code>c</code> may be incremented twice!  There are subtler
versions of this trap, such as passing the macro a function-call with
side effects.
</p>
<p>
  In general, interactions between macros and expressions with
side effects can lead to unfortunate results that are hard to
diagnose.  C's macro processor is a deliberately lightweight and
simple one; more powerful ones can actually get you in worse
trouble.
</p>
<p>
  The
  <em>TeX</em> formatting
language (see
  <a href="#documentationchapter" title="Chapter 18. Documentation">
   Chapter 18</a>) well illustrates the general
problem.
  <em>TeX</em> is intentionally
Turing-complete (it has conditionals, loops, and recursion), but while
it can be made to do amazing things,
  <em>TeX</em> code tends to be unreadable and
painful to debug.  The sources for
  <em>LaTeX</em>, the the most widely used
  <em>TeX</em> macro package, are an instructive
example: they're in very good
  <em>TeX</em> style, but even so are extremely
difficult to follow.
</p>
<p>
  A minor problem, compared to this one, is that macro expansion
tends to screw up error diagnostics.  The base language processor
generates its error reports relative to the macro expanded text, not
the original the programmer is looking at.  If the relationship
between the two has been obfuscated by macro expansion, the emitted
diagnostic can be very difficult to associate with the actual
location of the error.
</p>
<p>
  This is especially a problem with preprocessors and macros
that can have multiline expansions, conditionally include or exclude
text, or otherwise change line numbers in the expanded text.
</p>
<p>
  Macro expansion stages that are built into a language can do
their own compensation, fiddling line numbers to refer back to the
preexpanded text.  The macro facility in
pic(1)
does this, for example.  This problem is more difficult to solve when
the macro expansion is done by a preprocessor.
</p>
<p>
  The C preprocessor
  addresses this problem by emitting
  <code>#line</code> directives whenever it does an inclusion
or multiline expansion. The C compiler is expected to interpret these
and adjust the line numbers in its error reports accordingly.
Unfortunately,
  <em>m4</em> has no such
facility.
</p>
<p>
  These are reasons to use macro expansion with extreme caution.  
One of the long-term lessons of the Unix experience is that macros
tend to create more problems than they solve.  Modern language and
minilanguage designs have moved away from them.
</p>
<h4 id="id2937424"><a href="#id2937424">§</a>Language or Application Protocol?</h4>
<p>
  Another important question you need to ask is whether your
minilanguage engine will be called interactively by other
programs, as a slave process.  If so, your design should probably look
less like a conversational language for human interaction and more
like the kind of application protocols we looked at in
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>.
</p>
<p>
  The main difference is how carefully marked the boundaries
of transactions are.  Human beings are good at spotting where
conversational output from a CLI ends, and where the prompt for the
next input is.  They can use context to tell what's significant and
what should be ignored.  Computer programs have much more trouble with 
this.  Without either unambiguous end markers on output or advance
knowledge of the length of the output, they can't tell when to stop
reading.
</p>
 <blockquote>
  <p>
   Even worse is when a program's input is buffered (often
inadvertently, as by stdio).  A program that stops overtly reading at
the right place can nonetheless eat past it.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  Programs in which master processes are trying to do interactive
things with slaved minilanguages that are not carefully designed
around this problem are prone to deadlock as the master and slave fall
out of synchronization (a problem we first noted in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>).
</p>
<p>
  There are workarounds for driving minilanguages that are not so
carefully designed.  The prototype for most of them is the
Tcl
  <em>expect</em> package.  This package 
assists conversation with CLIs.  It's built around the following
operation: read from slave until either a given regular-expression
pattern is matched or a specified timeout elapses.  With this (and, of
course, a send-to-slave operation) it's often possible to construct
master programs to do reliable dialogues with slave processes even
when the latter have not been tailored for the role.
</p>
<p>
  Workalikes of the
  <em>expect</em> package in
other languages are available; a Web search for the name of your
favorite language with the added keywords “Tcl expect” is
quite likely to turn up something useful.  As a minilanguage designer,
however, you would be unwise to assume that all your users will be
  <em>expect</em> gurus. Even if they are, this is an
extra glue layer and a place for things to go wrong.
</p>
<p>
  Be aware of this issue when designing your minilanguage.  It may
be a good idea to add an option that changes its conversational
behavior to make it respond more like an application protocol, with
unambiguous end-of-output delimiters and an analog of
  <a href="#byte_stuffing">byte stuffing</a>.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2936473" id="ftn.id2936473">[95]</a></sup>
  20M is a conservative estimate based on
mid-2003 figures from the Linux Counter and
elsewhere.
</p>

<p><sup><a href="#id2936490" id="ftn.id2936490">[96]</a></sup>
  <em>Kmail</em>, which we looked
at in
  <a href="#transparencychapter" title="Chapter 6. Transparency">
   Chapter 6</a>, won't
even chase off-site links in HTML for this
reason.
</p>
</div>


<!-- FILE: generationchapter.html -->
<h3 id="generationchapter"><a href="#generationchapter">§</a>Chapter 9. Generation</h3>
 <blockquote class="epigraph">
  <p>
   The programmer at wit's end ... can often do best by
disentangling himself from his code, rearing back, and
contemplating his data. Representation is the essence of
programming.
  </p>
  <span>
   – Fred Brooks
The Mythical Man-Month, Anniversary Edition (1975-1995), p. 103
  </span>
 </blockquote>
<p>
  In
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>
  we
observed that human beings are better at visualizing data than they
are at reasoning about control flow.  We recapitulate: To see this,
compare the expressiveness and explanatory power of a diagram of a
fifty-node pointer tree with a flowchart of a fifty-line program. Or
(better) of an array initializer expressing a conversion table with an
equivalent switch statement. The difference in
transparency
  and clarity is
dramatic.<sup><a href="#ftn.id2939543" id="id2939543">[97]</a></sup>
</p>
<p>
  Data is more tractable than program logic. That's
true whether the data is an ordinary table, a declarative markup
language, a templating system, or a set of macros that will expand to
program logic.  It's good practice to move as much of the complexity
in your design as possible away from procedural code and into
data, and good practice to pick data representations that are
convenient for humans to maintain and manipulate.  Translating
those representations into forms that are convenient for machines
to process is another job for machines, not for humans.
</p>
 <blockquote>
  <p>
   Another important advantage of higher-level, more declarative
notations is that they lend themselves better to compile-time checking.
Procedural notations inherently have complex runtime behavior which is
difficult to analyze at compile time.  Declarative notations give the
implementation much more leverage for finding mistakes, by permitting much
more thorough understanding of the intended behavior.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  These insights ground in theory a set of practices that have
always been an important part of the Unix programmer's toolkit —
very high-level languages, data-driven programming, code generators,
and domain-specific minilanguages.  What unifies these is that they
are all ways of lifting the generation of code up some levels, so that
specifications can be smaller. We've previously noted that defect
densities tend to be nearly constant across programming languages; all
these practices mean that whatever malign forces generate our bugs
will get fewer lines to wreak their havoc on.
</p>
<p>
  In
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>
  we
discussed the uses of domain-specific minilanguages. In
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>
  we'll make the argument for
very-high-level languages.  In this chapter we'll look at some
design studies in data-driven programming and a few examples of ad-hoc
code generation; we'll look at some code-generation tools in
  <a href="#toolschapter" title="Chapter 15. Tools">
   Chapter 15</a>.  As with minilanguages, these methods can
enable you to drastically cut the line count of your programs, and
correspondingly lower debugging time and maintenance costs.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2939543" id="ftn.id2939543">[97]</a></sup>
  For further development of this point see<sup><a href="#Bentley" title="[Bentley]">[Bentley]</a></sup>.
</p>
</div>


<!-- FILE: ch09s01.html -->
<h3 id="ch09s01"><a href="#ch09s01">§</a>Data-Driven Programming</h3>
<p>
  When doing
  <em>data-driven programming</em>, one
clearly distinguishes code from the data structures on which it acts,
and designs both so that one can make changes to the logic of the program 
by editing not the code but the data structure.
</p>
<p>
  Data-driven programming is sometimes confused with object
orientation, another style in which data
organization is supposed to be central.  There are at least two
differences.  One is that in data-driven programming, the data is not
merely the state of some object, but actually defines the control flow
of the program.  Where the primary concern in
OO
  is
encapsulation, the primary concern in data-driven programming is
writing as little fixed code as possible.  Unix has a stronger
tradition of data-driven programming than of OO.
</p>
<p>
  Programming data-driven style is also sometimes confused with
writing state machines.  It is in fact possible to express the logic
of a state machine as a table or data structure, but hand-coded state
machines are usually rigid blocks of code that are far harder to
modify than a table.
</p>
<p>
  An important rule when doing any kind of code generation or
data-driven programming is this: always push problems upstream.  Don't
hack the generated code or any intermediate representations by hand
— instead, think of a way to improve or replace your translation
tool.  Otherwise you're likely to find that hand-patching bits which
should have been generated correctly by machine will have turned into
an infinite time sink.
</p>
<p>
  At the upper end of its complexity scale, data-driven
programming merges into writing interpreters for p-code or simple
minilanguages of the kind we surveyed in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>.  At other edges, it merges into code
generation and state-machine programming.  The distinctions are not
actually that important; the important part is moving program logic
away from hardwired control structures and into data.
</p>
<h4 id="id2939746"><a href="#id2939746">§</a>Case Study: ascii</h4>
<p>
  I maintain a program called
  <em>ascii</em>, a
very simple little utility that tries to interpret its command-line
arguments as names of ASCII (American Standard Code for Information
Interchange) characters and report all the equivalent names.  Code and
documentation for the tool are available from the
  <a href="http://www.catb.org/~esr/ascii">
   project page</a>. Here is an illustrative
screenshot:
</p>
 <pre class="screen">
esr@snark:~/WWW/writings/taoup$ ascii 10
ASCII 1/0 is decimal 016, hex 10, octal 020, bits 00010000: called ^P, DLE
Official name: Data Link Escape

ASCII 0/10 is decimal 010, hex 0a, octal 012, bits 00001010: called ^J, LF, NL
Official name: Line Feed
C escape: '\n'
Other names: Newline

ASCII 0/8 is decimal 008, hex 08, octal 010, bits 00001000: called ^H, BS
Official name: Backspace
C escape: '\b'
Other names:

ASCII 0/2 is decimal 002, hex 02, octal 002, bits 00000010: called ^B, STX
Official name: Start of Text
</pre>
<p>
  One indication that this program was a good idea is the fact
that it has an unexpected use — as a quick CLI aid to converting
between decimal, hex, octal, and binary representations of bytes.
</p>
<p>
  The main logic of this program could have been coded as a 
128-branch case statement.  This would, however, have made the code
bulky and difficult to maintain.  It would also have tangled parts
that change relatively rapidly (like the list of slang names for
characters) with parts that change slowly or not at all (like
the official names), putting them both in the same legend string and
making errors during editing much more likely to touch data that
ought to be stable.
</p>
<p>
  Instead, we apply data-driven programming.  All the character
name strings live in a table structure that is quite a bit larger than
any of the functions in the code (indeed, counted in lines it is
larger than any
  <em>three</em>
  of the functions in the
program).  The code merely navigates the table and does low-level
tasks like radix conversions.  The initializer actually lives in the
file
  <code>nametable.h</code>, which is generated in a way
we'll describe later in this chapter.
</p>
<p>
  This organization makes it easy to add new character names,
change existing ones, or delete old names by simply editing the table,
without disturbing the code.
</p>
<p>
  (The way the program is built is good Unix style, but the
output format is questionable.  It's hard to see how the output could
usefully become the input of any other program, so it does not play
well with others.)
</p>
<h4 id="bayes_spam"><a href="#bayes_spam">§</a>Case Study: Statistical Spam Filtering</h4>
<p>
  One interesting case of data-driven programming is statistical
learning algorithms for detecting spam (unsolicited bulk email).
A whole class of mail filter programs (those easily findable
by Web search include
  <em>popfile</em>,
  <em>spambayes</em>, and
  <em>bogofilter</em>) use a database of word
correlations to replace the elaborate pattern-matching conditional
logic of pattern-matching spam filters.
</p>
<p>
  Programs like these became common on the Internet very rapidly
following Paul Graham's landmark paper
  <em>A Plan for Spam</em><sup><a href="#Graham" title="[Graham]">[Graham]</a></sup> in 2002.  While the
explosion was triggered by the increasing cost of the pattern-matching
arms race, the statistical-filtering idea was adopted first and
fastest by Unix shops.  In part, this was certainly because almost all
the Internet service providers (who are most burdened by spam, and
thus had most incentive to adopt effective new techniques) are Unix
shops — but undoubtedly the harmony with some traditional themes
in Unix software design helped as well.
</p>
<p>
  Conventional spam filters require that a system administrator,
or some other responsible party, maintain information on patterns of
text found in spam — names of sites that emit nothing but spam,
come-on phrases often used by pornography sites or Internet scam
artists, and the like.  In his paper, Graham noted accurately that
computer programmers like the idea of pattern-matching filters, and
sometimes have difficulty seeing past that approach, because it offers
them so many opportunities to be clever.
</p>
<p>
  Statistical spam filters, on the other hand, work by collecting
feedback about what the user judges to be spam versus nonspam.  That
feedback is processed into databases of statistical correlation
coefficients or
  <em>weights</em> connecting words or phrases
to the user's spam/nonspam classification.  The most popular
algorithms use minor variants of Bayes's Theorem on conditional
probabilities, but other techniques (including various sorts of
polynomial hashing) are also employed.
</p>
<p>
  In all these programs, the correlation check is a relatively
trivial mathematical formula.  The weights fed into the formula along
with the message being checked serve as implicit control
structure for the filtering algorithm.
</p>
<p>
  The problem with conventional pattern-matching spam filters is 
that they are brittle.  Spammers are constantly gaming against the
filter-rule databases, forcing the filter maintainers to constantly
reprogram their filters to stay ahead in the arms race.  Statistical
spam filters generate their own filter rules from the user feedback.
</p>
<p>
  In fact, experience with statistical filters seems to show that the 
particular learning algorithm used is far less important than the
quality of the spam and nonspam data sets from which the learning algorithm
computes its weights.  So the results of statistical filters really
are driven more by the shape of the data than by the algorithm.
</p>
<p>
  <em>A Plan for Spam</em> was something of a
bombshell because its author argued convincingly that a simple, even
crude, statistical approach gave a lower rate of nonspam being
erroneously classified as spam than either elaborate pattern-matching
techniques or the human eyeball could manage.  For Unix programmers,
seeing past the lure of clever pattern-matching was far easier than in
other programming cultures without as strong an attachment to
“Keep It Simple, Stupid!”
</p>
<h4 id="fetchmailconf"><a href="#fetchmailconf">§</a>Case Study: Metaclass Hacking in fetchmailconf</h4>
<p>
  The
fetchmailconf(1)
dotfile configurator shipped with
fetchmail(1)
  contains an instructive example of advanced data-driven programming in
a very high-level, object-oriented
  language.
</p>
<p>
  In October 1997 a series of questions on the fetchmail-friends mailing list made it clear that end-users were having
  increasing troubles generating configuration files for <em>fetchmail</em>.  The file uses a simple, classically-Unixy
  free-format syntax, but can become forbiddingly complicated when a user has POP3 and IMAP accounts at multiple sites.
  See Example 9.1 for a somewhat simplified version of the <em>fetchmail</em> author's configuration file.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 9.1. Example of fetchmailrc syntax.
   </b>
  </p>
  <pre class="programlisting">
set postmaster "esr"
set daemon 300

poll imap.ccil.org with proto IMAP and options no dns
    aka snark.thyrsus.com locke.ccil.org ccil.org
       user esr there is esr here 
            options fetchall dropstatus warnings 3600

poll imap.netaxs.com with proto IMAP
       user "esr" there is esr here options dropstatus warnings 3600
</pre>
 </div>
<p>
  The design objective of
  <em>fetchmailconf</em> was to completely hide the control file syntax behind a fashionable,
ergonomically-correct GUI replete with selection buttons,
slider bars and fill-out forms.  But the beta design had a problem: it
could easily generate configuration files from the user's GUI actions,
but could not read and edit existing ones.
</p>
<p>
  The parser for
  <em>fetchmail</em> 's
  configuration file syntax is rather elaborate.  It's actually written
in
  <em>yacc</em> and
  <em>lex</em>,
the two classic Unix tools for generating language-parsing code in C.
For
  <em>fetchmailconf</em> to be able to edit
existing configuration files, it at first appeared that it would be
necessary to replicate that elaborate parser in fetchmailconf's
implementation language — Python.
</p>
<p>
  This tactic seemed doomed.  Even leaving aside the amount of
duplicative work implied, it is notoriously hard to be certain that
two parsers in two different languages accept the same grammar.
Keeping them synchronized as the configuration language evolved bid
fair to be a maintenance nightmare.  It would have violated the SPOT
rule
  we discussed
in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>
  wholesale.
</p>
<p>
  This problem stumped me for a while.  The insight that cracked
it was that
  <em>fetchmailconf</em> could use
  <em>fetchmail</em> 's own parser as a filter!  I
added a
  <code>--configdump</code> option to
  <em>fetchmail</em> that would parse
  <code>.fetchmailrc</code> and dump the result to standard
output in the format of a Python initializer.  For the file above, the result would look roughly like Example 9.2 (to
save space, some data not relevant to the example is omitted).
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 9.2. Python structure dump of a
    <em>fetchmail</em> configuration.
   </b>
  </p>
  <pre class="programlisting">
fetchmailrc = {
    'poll_interval':300,
    "logfile":None,
    "postmaster":"esr",
    'bouncemail':TRUE,
    "properties":None,
    'invisible':FALSE,
    'syslog':FALSE,
    # List of server entries begins here
    'servers': [
        # Entry for site `imap.ccil.org' begins:
        {
            "pollname":"imap.ccil.org",
            'active':TRUE,
            "via":None,
            "protocol":"IMAP",
            'port':0,
            'timeout':300,
            'dns':FALSE,
            "aka":["snark.thyrsus.com","locke.ccil.org","ccil.org"],
            'users': [
                {
                    "remote":"esr",
                    "password":"masked_one",
                    'localnames':["esr"],
                    'fetchall':TRUE,
                    'keep':FALSE,
                    'flush':FALSE,
                    "mda":None,
                    'limit':0,
                    'warnings':3600,
                },            ]
        },
        # Entry for site `imap.netaxs.com' begins:
        {
            "pollname":"imap.netaxs.com",
            'active':TRUE,
            "via":None,
            "protocol":"IMAP",
            'port':0,
            'timeout':300,
            'dns':TRUE,
            "aka":None,
            'users': [
                {
                    "remote":"esr",
                    "password":"masked_two",
                    'localnames':["esr"],
                    'fetchall':FALSE,
                    'keep':FALSE,
                    'flush':FALSE,
                    "mda":None,
                    'limit':0,
                    'warnings':3600,
                },            ]
        },
    ]
}
</pre>
 </div>
<p>
  The major hurdle had been leapt.  The Python interpreter could
then evaluate the
  <em>fetchmail</em> <code>--configdump</code> output and read the configuration
available to
  <em>fetchmailconf</em> as the value of
the variable ‘fetchmail’.
</p>
<p>
  But this wasn't quite the last obstacle in the race.  What was
really needed wasn't just for
  <em>fetchmailconf</em> to have the existing configuration, but to turn it into a linked tree
of live objects.  There would be three kinds of objects in this tree:
  <code>Configuration</code> (the top-level object representing the
entire configuration),
  <code>Site</code> (representing one of the
servers to be polled), and
  <code>User</code> (representing user data
attached to a site).  The example file describes three site objects, each
with one user object attached to it.
</p>
<p>
  The three object classes already existed in
  <em>fetchmailconf</em>.  Each had a method that
caused it to pop up a GUI edit panel to modify its instance data.  The
last remaining problem was to somehow transform the static data in this
Python initializer into live objects.
</p>
<p>
  I considered writing a glue layer that would explicitly
know about the structure of all three classes and use that knowledge
to grovel through the initializer creating matching objects, but
rejected that idea because new class members were likely to be added
over time as the configuration language grew new features.  If the
object-creation code were written in the obvious way, it would once
again be fragile and tend to fall out of synchronization when either
the class definitions or the initializer structure dumped by the
  <code>--configdump</code> report generator changed.  Again, a
recipe for endless bugs.
</p>
<p>
  The better way would be data-driven programming — code
that would analyze the shape and members of the initializer, query the
class definitions themselves about their members, and then
impedance-match the two sets.
</p>
<p>
  Lisp
  and
Java
  programmers call this
  <em>introspection</em>; in
some other object-oriented languages it's called
  <em>
   metaclass
hacking
</em>
  and is generally considered fearsomely esoteric,
deep black magic.  Most object-oriented languages don't support it at
all; in those that do (Perl
  and Java among them), it tends to be a
complicated and fragile undertaking.  But Python's facilities for
introspection and metaclass hacking are unusually accessible.
</p>
<p>
  See Example 9.3 for the solution code, from near line 1895 of the 1.43 version.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 9.3.
    <code>copy_instance</code> metaclass code.
   </b>
  </p>
  <pre class="programlisting">
def copy_instance(toclass, fromdict):
# Make a class object of given type from a conformant dictionary.
    class_sig = toclass.__dict__.keys(); class_sig.sort()
    dict_keys = fromdict.keys(); dict_keys.sort()
    common = set_intersection(class_sig, dict_keys)
    if 'typemap' in class_sig: 
        class_sig.remove('typemap')
    if tuple(class_sig) != tuple(dict_keys):
        print "Conformability error"
#        print "Class signature: " + `class_sig`
#        print "Dictionary keys: " + `dict_keys`
        print "Not matched in class signature: "+ \
                                        `set_diff(class_sig, common)`
        print "Not matched in dictionary keys: "+ \
                                        `set_diff(dict_keys, common)`
        sys.exit(1)
    else:
        for x in dict_keys:
            setattr(toclass, x, fromdict[x])
</pre>
 </div>
<p>
  Most of this code is error-checking against the possibility that
the class members and
  <code>--configdump</code> report generation
have drifted out of synchronization.  It ensures that if the code
breaks, the breakage will be detected early — an implementation
of the Rule of Repair.  The heart of this function is the last
two lines, which set attributes in the class from corresponding
members in the dictionary.  They're equivalent to this:
</p>
 <pre class="programlisting">
def copy_instance(toclass, fromdict):
        for x in fromdict.keys():
                setattr(toclass, x, fromdict[x])
</pre>
<p>
  When your code is this simple, it is far more likely to be right. See Example 9.4 for the code that calls it.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 9.4. Calling context for
    <code>copy_instance</code>.
   </b>
  </p>
  <pre class="programlisting">
    # The tricky part - initializing objects from the `configuration' 
    # global.  `Configuration' is the top level of the object tree 
    # we're going to mung 
    Configuration = Controls()
    copy_instance(Configuration, configuration)
    Configuration.servers = [];
    for server in configuration['servers']:
        Newsite = Server()
        copy_instance(Newsite, server)
        Configuration.servers.append(Newsite)
        Newsite.users = [];
        for user in server['users']:
            Newuser = User()
            copy_instance(Newuser, user)
            Newsite.users.append(Newuser)
</pre>
 </div>
<p>
  The key point to extract from this code is that it traverses the
three levels of the initializer (configuration/server/user),
instantiating the correct objects at each level into lists contained
in the next object up.  Because
  <code>copy_instance</code> is
data-driven and completely generic, it can be used on all three levels
for three different object types.
</p>
<p>
  This is a new-school sort of example; Python was not even
invented until 1990.  But it reflects themes that go back to 1969 in
the Unix tradition.  If meditating on Unix programming as practiced by
his predecessors had not taught me constructive laziness
— insisting on reuse, and refusing to write duplicative glue
code in accordance with the SPOT rule
  —I might have rushed into coding a
parser in Python.  The first key insight that
  <em>fetchmail</em> itself could be made into
  <em>fetchmailconf</em> 's configuration parser might
never have happened.
</p>
<p>
  The second insight (that
  <code>copy_instance</code> could be generic) proceeded from
the Unix tradition of looking assiduously for ways to avoid
hand-hacking. But more specifically, Unix programmers are very used to
writing parser specifications to generate parsers for processing
language-like markups; from there it was a short step to believing
that the rest of the job could be done by some kind of generic
tree-walk of the configuration structure. Two separate stages of
data-driven programming, one building on the other, were needed to
solve the design problem cleanly.
</p>
<p>
  Insights like this can be extraordinarily powerful.  The code we
have been looking at was written in about ninety minutes, worked the
first time it was run, and has been stable in the years since (the
only time it has ever broken is when it threw an exception in the
presence of genuine version skew).  It's less than forty lines and
beautifully simple.  There is no way that the naïve approach of
building an entire second parser could possibly have produced this
kind of maintainability, reliability or
compactness.
Reuse, simplification, generalization,
orthogonality
  :
this is the
  Zen of Unix
in action.
</p>
<p>
  In
  <a href="#configurationchapter" title="Chapter 10. Configuration">
   Chapter 10</a>,
we'll examine the run-control syntax of
  <em>fetchmail</em> as an example of the standard shell-like metaformat for run-control
files.  In
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>
  we'll use
  <em>fetchmailconf</em> as an example of
Python's strength in rapidly building GUIs.
</p>



<!-- FILE: ch09s02.html -->
<h3 id="ch09s02"><a href="#ch09s02">§</a>Ad-hoc Code Generation</h3>
<p>
  Unix comes equipped with some powerful special-purpose code
generators for purposes like building lexical analyzers (tokenizers)
and parsers; we'll survey these in
  <a href="#toolschapter" title="Chapter 15. Tools">
   Chapter 15</a>.  But there are much simpler, lighter-weight
sorts of code generation we can use to make life easier without having
to know any compiler theory or write (error-prone) procedural
logic.
</p>
<p>
  Here are a couple of simple case studies to illustrate this
point:
</p>
<h4 id="id2938615"><a href="#id2938615">§</a>Case Study: Generating Code for the ascii Displays</h4>
<p>
  Called without arguments, <em>ascii</em> generates a usage screen that looks like Example 9.5.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 9.5.
    <em>ascii</em> usage screen.
   </b>
  </p>
  <pre class="screen">
Usage: ascii [-dxohv] [-t] [char-alias...]
   -t = one-line output  -d = Decimal table  -o = octal table  -x = hex table
   -h = This help screen -v = version information
Prints all aliases of an ASCII character. Args may be chars, C \-escapes,
English names, ^-escapes, ASCII mnemonics, or numerics in decimal/octal/hex.

Dec Hex    Dec Hex    Dec Hex  Dec Hex  Dec Hex  Dec Hex   Dec Hex   Dec Hex
  0 00 NUL  16 10 DLE  32 20    48 30 0  64 40 @  80 50 P   96 60 `  112 70 p
  1 01 SOH  17 11 DC1  33 21 !  49 31 1  65 41 A  81 51 Q   97 61 a  113 71 q
  2 02 STX  18 12 DC2  34 22 "  50 32 2  66 42 B  82 52 R   98 62 b  114 72 r
  3 03 ETX  19 13 DC3  35 23 #  51 33 3  67 43 C  83 53 S   99 63 c  115 73 s
  4 04 EOT  20 14 DC4  36 24 $  52 34 4  68 44 D  84 54 T  100 64 d  116 74 t
  5 05 ENQ  21 15 NAK  37 25 %  53 35 5  69 45 E  85 55 U  101 65 e  117 75 u
  6 06 ACK  22 16 SYN  38 26 &amp;  54 36 6  70 46 F  86 56 V  102 66 f  118 76 v
  7 07 BEL  23 17 ETB  39 27 '  55 37 7  71 47 G  87 57 W  103 67 g  119 77 w
  8 08 BS   24 18 CAN  40 28 (  56 38 8  72 48 H  88 58 X  104 68 h  120 78 x
  9 09 HT   25 19 EM   41 29 )  57 39 9  73 49 I  89 59 Y  105 69 i  121 79 y
 10 0A LF   26 1A SUB  42 2A *  58 3A :  74 4A J  90 5A Z  106 6A j  122 7A z
 11 0B VT   27 1B ESC  43 2B +  59 3B ;  75 4B K  91 5B [  107 6B k  123 7B {
 12 0C FF   28 1C FS   44 2C ,  60 3C &lt;  76 4C L  92 5C \  108 6C l  124 7C |
 13 0D CR   29 1D GS   45 2D -  61 3D =  77 4D M  93 5D ]  109 6D m  125 7D }
 14 0E SO   30 1E RS   46 2E .  62 3E &gt;  78 4E N  94 5E ^  110 6E n  126 7E ~
 15 0F SI   31 1F US   47 2F /  63 3F ?  79 4F O  95 5F _  111 6F o  127 7F DEL
</pre>
 </div>
<p>
  This screen is carefully designed to fit in 23 rows and 79
columns, so that it will fit in a 24×80 terminal window.
</p>
<p>
  This table could be generated at runtime, on the fly.  Grinding
out the decimal and hex columns would be easy enough.  But between
wrapping the table at the right places and knowing when to print
mnemonics like NUL rather than characters, there would have been enough
odd corner cases to make the code distinctly unpleasant.  Furthermore,
the columns had to be unevenly spaced to make the table fit in 79
columns.  But any Unix programmer would reflexively express it as a block
of data before finding out these things.
</p>
<p>
  The most naïve way to generate the usage screen would have been
to put each line into a C
  initializer in the
  <code>ascii.c</code> source code, and then
have all lines be written out by code that steps through the
initializer.  The problem with this method is that the extra data in
the C initializer format (trailing newline, string quotes, comma) would
make the lines longer than 79 characters, causing them to wrap and
making it rather difficult to map the appearance of the code to the
appearance of the output.  This, in turn, would make the display
difficult to edit, which was annoying when I was tinkering it
to fit in 24×80 screen cells.
</p>
<p>
  A more sophisticated method using the string-pasting behavior of
the ANSI C
  preprocessor collided with a variant of the same problem.
Essentially, any way of inlining the usage screen explicitly would
involve punctuation at start and end of line that there's no room
for.<sup><a href="#ftn.id2938770" id="id2938770">[98]</a></sup>
  And copying the table to the screen from a
file at runtime seemed like a fragile expedient; after all, the file
could get lost.
</p>
<p>
  Here's the solution.  The source distribution contains a file
that just contains the usage screen, exactly as listed above and named
  <code>splashscreen</code>. The C
  source contains the following
function:
</p>
 <pre class="programlisting">
void 
showHelp(FILE *out, char *progname) 
{
  fprintf(out,"Usage: %s [-dxohv] [-t] [char-alias...]\n", progname);
#include "splashscreen.h"

  exit(0);
}
</pre>
<p>
  And
  <code>splashscreen.h</code> is generated by a makefile production:
</p>
 <pre class="programlisting">
splashscreen.h: splashscreen
        sed &lt;splashscreen &gt;splashscreen.h \
            -e 's/\\/\\\\/g' -e 's/"/\\"/' -e 's/.*/puts("&amp;");/' 
</pre>
<p>
  So when the program is built, the
  <code>splashscreen</code> file is automatically massaged into
a series of output function calls, which are then included by the C
preprocessor in the right function.
</p>
<p>
  By generating the code from data, we get to keep the editable
version of the usage screen identical to its display appearance.  This
promotes
transparency.  Furthermore, we could modify the usage
screen at will without touching the C code at all, and the right thing
would automatically happen on the next build.
</p>
<p>
  For similar reasons, the initializer that holds the name synonym
strings is also generated via a
  <em>sed</em> script
in the makefile, from a file called
  <code>nametable</code> in
the
  <em>ascii</em> source distribution.  Most of
  <code>nametable</code> is simply copied into the C
initializer.  But the generation process would make it easy to adapt
this tool for other 8-bit character sets such as the ISO-8859 series
(Latin-1 and friends).
</p>
<p>
  This is an almost trivial example, but it nevertheless
illustrates the advantages of even simple and ad-hoc code
generation.  Similar techniques could be applied to larger
programs with correspondingly greater benefits.
</p>
<h4 id="htmlgen"><a href="#htmlgen">§</a>Case Study: Generating HTML Code for a Tabular List</h4>
<p>
  Let's suppose that we want to put a page of tabular data on a Web page.  We want the first few lines to look like
  Example 9.6.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 9.6. Desired output format for the star table.
   </b>
  </p>
  <pre class="programlisting">
Aalat         David Weber             The Armageddon Inheritance
Aelmos        Alan Dean Foster        The Man who Used the Universe 
Aedryr        Steve Miller/Sharon Lee Scout's Progress 
Aergistal     Gerard Klein            The Overlords of War 
Afdiar        L. Neil Smith           Tom Paine Maru 
Agandar       Donald Kingsbury        Psychohistorical Crisis 
Aghirnamirr   Jo Clayton              Shadowkill 
</pre>
 </div>
<p>
  The thick-as-a-plank way to handle this would be to hand-write
HTML table code for the desired appearance.  Then, each time we want
to add a name, we'd have to hand-write another set of
&lt;tr&gt; and &lt;td&gt; tags for
the entry.  This would get very tedious very quickly.  But what's
worse, changing the format of the list would require hand-hacking
every entry.
</p>
<p>
  The superficially clever way to handle this would be to make
this data a three-column relation in a database, then use some fancy
CGI<sup><a href="#ftn.id2941426" id="id2941426">[99]</a></sup>
  technique or a database-capable templating
engine like PHP to generate the page on the fly.  But suppose we know
that the list will not change very often, don't want to run a database
server just to be able to display this list, and don't want to load
the server with unnecessary CGI traffic?
</p>
<p>
  There's a better solution.  We put the data in a tabular flat-file format like Example 9.7.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 9.7. Master form of the star table.
   </b>
  </p>
  <pre class="screen">
Aalat         :David Weber                 :The Armageddon Inheritance
Aelmos        :Alan Dean Foster            :The Man who Used the Universe 
Aedryr        :Steve Miller/Sharon Lee     :Scout's Progress 
Aergistal     :Gerard Klein                :The Overlords of War 
Afdiar        :L. Neil Smith               :Tom Paine Maru 
Agandar       :Donald Kingsbury            :Psychohistorical Crisis 
Aghirnamirr   :Jo Clayton                  :Shadowkill 
</pre>
 </div>
<p>
  We could in a pinch have done without the explicit colon field
delimiters, using the pattern consisting of two or more spaces as a
delimiter, but the explicit delimiter protects us in case we press
spacebar twice while editing a field value and fail to notice
it.
</p>
<p>
  We then write a script in shell, Perl, Python, or Tcl
  that massages
this file into an HTML table, and run that each time we add an entry.
The old-school Unix way would revolve around the following
nigh-unreadable sed(1) invocation
</p>
 <pre class="programlisting">
sed -e 's,^,&lt;tr&gt;&lt;td&gt;,' -e 's,$,&lt;/td&gt;&lt;/tr&gt;,' -e 's,:,&lt;/td&gt;&lt;td&gt;,g'
</pre>
<p>
  or this perhaps slightly more scrutable awk(1) program:
</p>
 <pre class="programlisting">
awk -F: '{printf("&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\n", \
                 $1, $2, $3)}'
</pre>
<p>
  (If either of these examples interests but mystifies, read the
documentation for
sed(1)
or
awk(1).
We
  <a href="#awk" title="Case Study: awk">
   explained</a>
  in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>
  that the latter has largely fallen
out of use.  The former is still an important Unix tool that we
haven't examined in detail because (a) Unix programmers already know
it, and (b) it's easy for non-Unix programmers to pick up from the
manual page once they grasp the basic ideas about pipelines and
redirection.)
</p>
<p>
  A new-school solution might center on this Python code, or
on equivalent Perl:
</p>
 <pre class="programlisting">
for row in map(lambda x:x.rstrip().split(':'),sys.stdin.readlines()):
    print "&lt;tr&gt;&lt;td&gt;" + "&lt;/td&gt;&lt;td&gt;".join(row) + "&lt;/td&gt;&lt;/tr&gt;"
</pre>
<p>
  These scripts took about five minutes each to write and debug,
certainly less time than would have been required to either hand-hack
the initial HTML or create and verify the database.  The combination
of the table and this code will be much simpler to maintain than
either the under-engineered hand-hacked HTML or the over-engineered
database.
</p>
<p>
  A further advantage of this way of solving the problem is that
the master file stays easy to search and modify with an ordinary text
editor.  Another is that we can experiment with different
table-to-HTML transformations by tweaking the generator script, or
easily make a subset of the report by putting a
grep(1)
filter before it.
</p>
<p>
  I actually use this technique to maintain the Web page that
lists
  <em>fetchmail</em> test sites; the example above is science-fictional only because
publishing the real data would reveal account usernames and
passwords.
</p>
<p>
  This was a somewhat less trivial example than the previous
one. What we've actually designed here is a separation between content
and formatting, with the generator script acting as a stylesheet.
(This is yet another mechanism-vs.-policy separation.)
</p>
<p>
  The lesson in all these cases is the same.  Do as little work
as possible.  Let the data shape the code. Lean on your tools.
Separate mechanism from policy.  Expert Unix programmers learn to see
possibilities like these quickly and automatically.  Constructive
laziness is one of the cardinal virtues of the master programmer.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2938770" id="ftn.id2938770">[98]</a></sup>
  Scripting languages tend to solve this problem more
elegantly than C does.  Investigate the shell's
  <em>here documents</em>
  and Python's triple-quote construct to find out
how.
</p>

<p><sup><a href="#id2941426" id="ftn.id2941426">[99]</a></sup>
  Here, CGI refers not to Computer Graphic Inagery
but to the Common Gateway Interface used for live Web
content.
</p>
</div>


<!-- FILE: configurationchapter.html -->
<h3 id="configurationchapter"><a href="#configurationchapter">§</a>Chapter 10. Configuration</h3>
 <blockquote class="epigraph">
  <p>
   Let us watch well our beginnings, and results will manage themselves.
  </p>
  <span>
   – Alexander Clark
  </span>
 </blockquote>
<p>
  Under Unix, programs can communicate with their environment in a
rich variety of ways. It's convenient to divide these into (a)
startup-environment queries and (b) interactive channels. In this
chapter, we'll focus primarily on startup-environment queries. The
next chapter will discuss interactive channels.
</p>



<!-- FILE: ch10s01.html -->
<h3 id="ch10s01"><a href="#ch10s01">§</a>What Should Be Configurable?</h3>
<p>
  Before plunging into the details of different kinds of program
configuration, we should ask a high-level question: What things should 
be configurable?
</p>
<p>
  The gut-level Unix answer is “everything”.  The
Rule of Separation that we discussed in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">Chapter 1</a>
  encourages Unix programmers to build
mechanism and defer policy decisions outward toward the user wherever
possible.  While this tends to produce programs that are powerful and
rewarding for expert users, it also tends to produce interfaces that
overwhelm novices and casual users with a surfeit of choices, and with
configuration files sprouting like weeds.
</p>
<p>
  Unix programmers aren't going to be cured of their tendency to
design for their peers and the most sophisticated users any time soon
(we'll grapple a bit with the question of whether such a change would
actually be desirable in
  <a href="#futurechapter" title="Chapter 20. Futures">Chapter 20</a>).  So it's perhaps more useful to invert the
question and ask “What things should
  <em>not</em>
  be
configurable?” Unix practice does offer some guidelines on
this.
</p>
<p>
  First,
  <em>
   don't provide configuration switches for what
you can reliably detect automatically
</em>. This is a
surprisingly common mistake.  Instead, look for ways to eliminate
configuration switches by autodetection, or by trying alternative
methods at runtime until one succeeds. If this strikes you as
inelegant or too expensive, ask yourself if you haven't fallen into
premature optimization.
</p>
 <blockquote>
  <p>
   One of the nicest examples of autodetection I experienced was
when Dennis Ritchie and I were porting Unix to the Interdata 8/32.
This was a big-endian machine, and we had to generate data for that
machine on a PDP-11, write a magnetic tape, and then load the magnetic
tape on the Interdata.  A common error was to forget to twiddle the
byte order; a checksum error showed you that you had to unmount,
remount again on the PDP-11, regenerate the tape, unmount, and
remount.  Then one day Dennis hacked the Interdata tape reader program
so that if it got a checksum error it rewound the tape, toggled
‘byte flip’ switch and reread it.  A second checksum error
would kill the load, but 99% of the time it just read the tape and did
the right thing.  Our productivity shot up, and we pretty much ignored
tape byte order from that point on.
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>
<p>
  A good rule of thumb is this: Be adaptive unless doing so costs
you 0.7 seconds or more of latency.  0.7 seconds is a magic number
because, as Jef Raskin discovered while designing the Canon Cat,
humans are almost incapable of noticing startup latency shorter than
that; it gets lost in the mental overhead of changing the focus of
attention.
</p>
<p>
  Second,
  <em>
   users should not see optimization
switches
</em>.  As a designer, it's
  <em>your</em>
  job to make the program run economically, not the user's.  The
marginal gains in performance that a user might collect from
optimization switches are usually not worth the interface-complexity
cost.
</p>
 <blockquote>
  <p>
   File-format nonsense (record length, blocking factor, etc)
was blessedly eschewed by Unix, but the same kind of
thing has roared back in excess configuration goo.  KISS became
MICAHI: make it complicated and hide it.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  Finally,
  <em>
   don't do with a configuration switch what can
be done with a script wrapper or a trivial pipeline
</em>.  Don't
put complexity inside your program when you can easily enlist other
programs to help get the work done. (Recall our discussion in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  of why
ls(1)
does not have a built-in pager, or an option to invoke it).
</p>
<p>
  Here are some more general questions to consider whenever you
find yourself thinking about adding a configuration option:
</p>
 <div>
  <ul>
   <li>
    <p>
     Can I leave this feature out?  Why am I
fattening the manual and burdening the user?
    </p>
   </li>
   <li>
    <p>
     Could the program's normal behavior be changed in an
innocuous way that would make the option unnecessary?
    </p>
   </li>
   <li>
    <p>
     Is this option merely cosmetic?  Should I be thinking
less about how to make the user interface configurable and more 
about how to make it right?
    </p>
   </li>
   <li>
    <p>
     Should the behavior enabled by this option be
a separate program instead?
    </p>
   </li>
  </ul>
 </div>
<p>
  Proliferating unnecessary options has many bad effects.  One of
the subtlest but most serious is what it will do to your test
coverage.
</p>
 <blockquote>
  <p>
   Unless it is done very carefully, the addition of an on/off
configuration option can lead to a need to double the amount of
testing.  Since in practice one never does double the amount of
testing, the practical effect is to reduce the amount of testing that
any given configuration receives.  Ten options leads to 1024 times as
much testing, and pretty soon you are talking real reliability
problems.
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>



<!-- FILE: ch10s02.html -->
<h3 id="ch10s02"><a href="#ch10s02">§</a>Where Configurations Live</h3>
<p>
  Classically, a Unix program can look for control information in
five places in its startup-time environment:
</p>
 <div>
  <ul>
   <li>
    <p>
     Run-control files under
     <code>/etc</code> (or at fixed location elsewhere in
systemland).
    </p>
   </li>
   <li>
    <p>
     System-set environment variables.
    </p>
   </li>
   <li>
    <p>
     Run-control files (or ‘dotfiles’) in the
user's home directory. (See
     <a href="#contrastchapter" title="Chapter 3. Contrasts">
      Chapter 3</a>
     for a discussion of this important
concept, if it is unfamiliar.)
    </p>
   </li>
   <li>
    <p>
     User-set environment variables.
    </p>
   </li>
   <li>
    <p>
     Switches and arguments passed to the program on the command
line that invoked it.
    </p>
   </li>
  </ul>
 </div>
<p>
  These queries are usually done in the order listed above.  That
way, later (more local) settings override earlier (more global)
ones. Settings found earlier can help the program compute locations
for later retrievals of configuration data.
</p>
<p>
  When thinking about which mechanism to use to pass configuration
data to a program, bear in mind that good Unix practice demands using
whichever one most closely matches the expected lifetime of the
preference.  Thus: for preferences which are very likely to change
between invocations, use command-line switches.  For preferences which
change seldom, but that should be under individual user control, use
a run-control file in the user's home directory.  For preference
information that needs to be set site-wide by a system administrator
and
  <em>not</em>
  changed by users, use a run-control file
in system space.
</p>
<p>
  We'll discuss each of these places in more detail, then examine
some case studies.
</p>



<!-- FILE: ch10s03.html -->
<h3 id="ch10s03"><a href="#ch10s03">§</a>Run-Control Files</h3>
<p>
  A run-control file is a file of declarations or commands
associated with a program that it interprets on startup. If a program
has site-specific configuration shared by all users at a site, it will
often have a run-control file under the
  <code>/etc</code> directory. (Some Unixes have an
  <code>/etc/conf</code> subdirectory that collects such data.)
</p>
<p>
  User-specific configuration information is often carried in a
hidden run-control file in the user's home directory. Such files are
often called ‘dotfiles’ because they exploit the Unix
convention that a filename beginning with a dot is normally invisible
to directory-listing tools.<sup><a href="#ftn.id2941866" id="id2941866">[100]</a></sup>
</p>
<p>
  Programs can also have run-control or dot directories. These
group together several configuration files that are related to the
program, but that are most conveniently treated separately (perhaps
because they relate to different subsystems of the program, or have
differing syntaxes).
</p>
<p>
  Whether file or directory, convention now dictates that the
location of the run-control information has the same basename as the
executable that reads it. An older convention still common among
system programs uses the executable's name with the suffix
‘rc’ for ‘run control’.<sup><a href="#ftn.id2941902" id="id2941902">[101]</a></sup>
  Thus, if you write a
program called ‘seekstuff’ that has both site-wide and
user-specific configuration, an experienced Unix user would expect to
find the former at
  <code>/etc/seekstuff</code> and the latter
at
  <code>.seekstuff</code> in the user's home directory; but
it would be unsurprising if the locations were
  <code>/etc/seekstuffrc</code> and
  <code>.seekstuffrc</code>, especially if seekstuff were a
system utility of some sort.
</p>
<p>
  In
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>
  we
described a somewhat different set of design rules for textual data-file 
formats, and discussed how to optimize for different weightings
of interoperability,
transparency
  and transaction economy.
Run-control files are typically only read once at program startup and
not written; economy is therefore usually not a major concern.
Interoperability and transparency both push us toward textual formats
designed to be read by human beings and modified with an ordinary text
editor.
</p>
<p>
  While the semantics of run-control files are of course
completely program dependent, there are some design rules about
run-control syntax that are widely observed. We'll describe
those next; but first we'll describe an important exception.
</p>
<p>
  If the program is an interpreter for a language, then it is
expected to be simply a file of commands in the syntax of that
language, to be executed at startup. This is an important rule,
because Unix tradition strongly encourages the design of all kinds of
programs as special-purpose languages and minilanguages. Well-known
examples with dotfiles of this kind include the various Unix command
shells and the
  <em>Emacs</em> programmable editor.
</p>
<p>
  (One reason for this design rule is the belief that special
cases are bad news — thus, that any switch that changes the
behavior of a language should be settable from within the language.
If as a language designer you find that you
  <em>cannot</em>
  express all the startup settings of a
language in the the language itself, a Unix programmer would say you
have a design problem — which is what you should be fixing,
rather than devising a special-case run-control syntax.)
</p>
<p>
  This exception aside, here are the normal style rules for 
run-control syntaxes. Historically, they are patterned on the syntax of
Unix shells:
</p>
 <div class="orderedlist">
  <ol type="1">
   <li>
    <p>
     <em>
      Support explanatory comments, and lead them with
      <code>#</code>.
</em>
     The syntax should also ignore whitespace before
     <code>#</code>, so
that comments on the same line as configuration directives are
supported.
    </p>
   </li>
   <li>
    <p>
     <em>
      Don't make insidious whitespace
distinctions.
</em>
     That is, treat runs of spaces and tabs,
syntactically the same as a single space.  If your directive format is
line-oriented, it is good form to ignore trailing spaces and tabs on
lines.  The metarule is that the interpretation of the file should
not depend on distinctions a human eye can't
see.
    </p>
   </li>
   <li>
    <p>
     <em>
      Treat multiple blank lines and comment lines
as a single blank line
</em>.  If the input format uses blank
lines as separators between records, you probably want to ensure that
a comment line does not end a record.
    </p>
   </li>
   <li>
    <p>
     <em>
      Lexically treat the file as a simple
sequence of whitespace-separated tokens, or lines of tokens.
</em>
     Complicated lexical rules are hard to learn, hard to remember, and
hard for humans to parse.  Avoid them.
    </p>
   </li>
   <li>
    <p>
     <em>
      But, support a string syntax for tokens with
embedded whitespace.
</em>
     Use single quote or double quote as
balanced delimiters. If you support both, beware of giving them different
semantics as they have in shell; this is a well-known source
of confusion.
    </p>
   </li>
   <li>
    <p>
     <em>
      Support a backslash syntax for embedding
unprintable and special characters in strings
</em>. The standard
pattern for this is the backslash-escape syntax supported by C
compilers.  Thus, for example, it would be quite surprising if the
string
     <code>"a\tb"</code> were not interpreted as a character
‘a’, followed by a tab, followed by the character
‘b’.
    </p>
   </li>
  </ol>
 </div>
<p>
  Some aspects of shell syntax, on the other hand, should
  <em>not</em>
  be emulated in run-control syntaxes —
at least not without a good and specific reason. The shell's baroque
quoting and bracketing rules, and its special metacharacters for
wildcards and variable substitution, both fall into this
category.
</p>
<p>
  It bears repeating that the point of these conventions is to
reduce the amount of novelty that users have to cope with when they
read and edit the run-control file for a program they have never seen
before. Therefore, if you have to break the conventions, try to do so
in a way that makes it visually obvious that you have done so,
document your syntax with particular care, and (most importantly)
design it so it's easy to pick up by example.
</p>
<p>
  These standard style rules only describe conventions about
tokenizing and comments. The names of run-control files, their
higher-level syntax, and the semantic interpretation of the syntax are
usually application-specific. There are a very few exceptions to
this rule, however; one is dotfiles which have become
‘well-known’ in the sense that they routinely carry
information used by a whole class of applications. Sharing
run-control file formats in this way reduces the amount of novelty
users have to cope with.
</p>
<p>
  Of these, probably the best established is the
  <code>.netrc</code> file.  Internet client programs that must
track host/password pairs for a user can usually get them from
the
  <code>.netrc</code> file, if it exists.
</p>
<h4 id="id2942210"><a href="#id2942210">§</a>Case Study: The .netrc File</h4>
<p>
  The <code>.netrc</code> file is a good example of the standard rules in action.  An example, with the passwords
  changed to protect the innocent, is in Example 10.1.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 10.1. A
    <code>.netrc</code> example.
   </b>
  </p>
  <pre class="programlisting">
# FTP access to my Web host
machine unix1.netaxs.com
        login esr
        password joesatriani

# My main mailserver at Netaxs
machine imap.netaxs.com
        login esr
        password jeffbeck

# Auxiliary IMAP maildrop at CCIL
machine imap.ccil.org
    login esr
    password marcbonilla

# Auxiliary POP maildrop at CCIL
machine pop3.ccil.org
    login esr
    password ericjohnson

# Shell account at CCIL
machine locke.ccil.org
    login esr
    password stevemorse
</pre>
 </div>
<p>
  Observe that this format is easy to parse by eyeball even if
you've never seen it before; it's a set of machine/login/password
triples, each of which describes an account on a remote host. This
kind of
transparency
  is important — much more
important, actually, than the time economy of faster interpretation or
the space economy of a more compact and cryptic file format. It
economizes the far more valuable resource that is
  <em>human</em>
  time, by making it likely that a human
being will be able to read and modify the format without having to
read a manual or use a tool less familiar than a plain old text
editor.
</p>
<p>
  Observe also that this format is used to supply information for
multiple services — an advantage, because it means sensitive
password information need only be stored in one place. The
  <code>.netrc</code> format was designed for the original Unix
FTP client program. It's used by all FTP clients, and also understood
by some telnet clients, and by the
smbclient(1)
command-line tool, and by the
  <em>fetchmail</em> program. If you are writing an Internet client that must do password
authentication through remote logins, the Rule of Least Surprise
demands that it use the contents of
  <code>.netrc</code> as
defaults.
</p>
<h4 id="id2942358"><a href="#id2942358">§</a>Portability to Other Operating Systems</h4>
<p>
  Systemwide run-control files are a design tactic that can be
used on almost any operating system, but dotfiles are rather more
difficult to map to a non-Unix environment. The critical thing
missing from most non-Unix operating systems is true multiuser
capability and the notion of a per-user home directory. DOS and
Windows versions up to ME (including 95 and 98), for example,
completely lack any such notion; all configuration information has to
be stored either in systemwide run-control files at a fixed location,
the Windows registry, or configuration files in the same directory a
program is run from.  Windows NT has some notion of per-user home
directories (which made its way into Windows 2000 and XP), but it is
only poorly supported by the system tools.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2941866" id="ftn.id2941866">[100]</a></sup>
  To make dotfiles visible,
use the
  <code>-a</code> option of
ls(1).
</p>

<p><sup><a href="#id2941902" id="ftn.id2941902">[101]</a></sup>
  The ‘rc’
suffix goes back to Unix's grandparent,
CTSS
  <a class="indexterm" id="id2941907"></a>.  It had a
command-script feature called "runcom".  Early Unixes used
‘rc’ for the name of the operating system's boot script,
as a tribute to CTSS runcom.
</p>
</div>


<!-- FILE: ch10s04.html -->
<h3 id="ch10s04"><a href="#ch10s04">§</a>Environment Variables</h3>
<p>
  When a Unix program starts up, the environment accessible to it
includes a set of name to value associations (names and values are
both strings). Some of these are set manually by the user; others are
set by the system at login time, or by your shell or terminal
emulator (if you're running one).  Under Unix, environment variables
tend to carry information about file search paths, system defaults,
the current user ID and process number, and other key bits of
information about the runtime einvironment of programs.  At a shell
prompt, typing <code>set</code> followed by a newline will list
all currently defined shell variables.
</p>
<p>
  In C
  and
C++
  these values
can be queried with the library function
getenv(3). Perl
  and Python
  initialize environment-dictionary
objects at startup. Other languages generally follow one of these two
models.
</p>
<h4 id="id2942463"><a href="#id2942463">§</a>System Environment Variables</h4>
<p>
  There are a number of well-known environment variables you can
expect to find defined on startup of a program from the Unix
shell.  These (especially
  <code>HOME</code>) will often need to be evaluated
  <em>before</em>
  you read a local dotfile.
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     <code>USER</code> </span>
   </dt>
   <dd>
    <p>
     Login name of the account under which this session is logged in
(BSD convention).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>LOGNAME</code> </span>
   </dt>
   <dd>
    <p>
     Login name of the
account under which this session is logged in (System V
     convention).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>HOME</code> </span>
   </dt>
   <dd>
    <p>
     Home directory of the user running this
session.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>COLUMNS</code> </span>
   </dt>
   <dd>
    <p>
     The number of character-cell columns on the controlling
terminal or terminal-emulator window.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>LINES</code> </span>
   </dt>
   <dd>
    <p>
     The number of character-cell rows on the controlling terminal
or terminal-emulator window.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>SHELL</code> </span>
   </dt>
   <dd>
    <p>
     The name of the user's command shell (often used by shellout
commands).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>PATH</code> </span>
   </dt>
   <dd>
    <p>
     The list of directories that the shell searches when looking
for executable commands to match a name.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>TERM</code> </span>
   </dt>
   <dd>
    <p>
     Name of the terminal type of the session console or
terminal emulator window (see the terminfo case study in
     <a href="#transparencychapter" title="Chapter 6. Transparency">
      Chapter 6</a>
     for background).  TERM is special in
that programs to create remote sessions over the network (such as
     <em>telnet</em> and
     <em>ssh</em>)
are expected to pass it through and set it in the remote
session.
    </p>
   </dd>
  </dl>
 </div>
<p>
  (This list is representative, but not exhaustive.)
</p>
<p>
  The
  <code>HOME</code> variable is especially important,
because many programs use it to find the calling user's dotfiles
(others call some functions in the C
  runtime library to get the calling
user's home directory).
</p>
<p>
  Note that some or all of these system environment variables may
  <em>not</em>
  be set when a program is started by some
other method than a shell spawn. In particular, daemon listeners on a
TCP/IP
  socket often
don't have these variables set — and if they do, the values are
unlikely to be useful.
</p>
<p>
  Finally, note that there is a tradition (exemplified by the
  <code>PATH</code> variable) of using a colon as a separator when an
environment variable must contain multiple fields, especially when the
fields can be interpreted as a search path of some sort. Note that
some shells (notably
  <em>bash</em> and
  <em>ksh</em>)
  <em>always</em>
  interpret
colon-separated fields in an environment variable as filenames, which
means in particular that they expand
  <code>~</code> in these fields to the user's
home directory.
</p>
<h4 id="id2942749"><a href="#id2942749">§</a>User Environment Variables</h4>
<p>
  Although applications are free to interpret environment
variables outside the system-defined set, it is nowadays fairly
unusual to actually do so. Environment values are not really suitable
for passing structured information into a program (though it can in
principle be done via parsing of the values). Instead, modern Unix
applications tend to use run-control files and dotfiles.
</p>
<p>
  There are, however, some design patterns in which user-defined
environment variables can be useful:
</p>
<p>
  <em>
   Application-independent preferences that need to be
shared by a large number of different programs.
</em>
  This set of
‘standard’ preferences changes only slowly, because lots
of different programs need to recognize each one before it becomes
useful.<sup><a href="#ftn.id2942782" id="id2942782">[102]</a></sup>
  Here are the standard ones:
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     <code>EDITOR</code> </span>
   </dt>
   <dd>
    <p>
     The name of the user's preferred editor (often used by shellout
commands).<sup><a href="#ftn.id2942810" id="id2942810">[103]</a></sup>
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>MAILER</code> </span>
   </dt>
   <dd>
    <p>
     The name of the user's preferred mail user agent (often used by
shellout commands).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>PAGER</code> </span>
   </dt>
   <dd>
    <p>
     The name of the
user's preferred program for browsing plaintext.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>BROWSER</code> </span>
   </dt>
   <dd>
    <p>
     The name of the
user's preferred program for browsing Web URLs.  This one, as of
2003, is still very new and not yet widely
implemented.
    </p>
   </dd>
  </dl>
 </div>
<h4 id="id2942882"><a href="#id2942882">§</a>When to Use Environment Variables</h4>
<p>
  What both user and system environment variables have in common
is that it would be annoying to have to replicate the information they
contain in a large number of application run-control files, and
extremely annoying to have to change that information everywhere when
your preference changes.  Typically, the user sets these variables in
his or her shell session startup file.
</p>
<p>
  <em>
   A value varies across several contexts that share
dotfiles, or a parent needs to pass information to multiple child
processes.
</em>
  Some pieces of start-up information are expected
to vary across several contexts in which the calling user would share
common run-control files and dotfiles. For a system-level example,
consider several shell sessions open through terminal emulator windows
on an X desktop. They will all see the same dotfiles, but might have
different values of
  <code>COLUMNS</code>,
  <code>LINES</code>, and
  <code>TERM</code>. (Old-school shell programming used this method
extensively; makefiles still do.)
</p>
<p>
  <em>
   A value varies too often for dotfiles, but doesn't
change on every startup.
</em>
  A user-defined environment
variable may (for example) be used to pass a file system or Internet
location that is the root of a tree of files that the program should
play with. The CVS version-control system interprets the variable
  <code>CVSROOT</code> this way, for example. Several newsreader
clients that fetch news from servers using the NNTP protocol interpret
the variable
  <code>NNTPSERVER</code> as the location of the server
to query.
</p>
<p>
  <em>
   A process-unique override needs to be expressed in a
way that doesn't require the command-line invocation to be
changed.
</em>
  A user-defined environment variable can be useful
for situations in which, for whatever reason, it would be inconvenient to
have to change an application dotfile or supply command-line options
(perhaps it is expected that the application will normally be used
inside a shell wrapper or within a makefile).  A particularly
important context for this sort of use is debugging.  Under Linux, for
example, manipulating the variable
  <code>LD_LIBRARY_PATH</code> associated with the ld(1) linking loader enables you to change where
libraries are loaded from — perhaps to pick up versions that do
buffer-overflow checking or profiling.
</p>
<p>
  In general, a user-defined environment variable can be an
effective design choice when the value changes often enough to make
editing a dotfile each time inconvenient, but not necessarily every
time (so always setting the location with a command-line option
would also be inconvenient).  Such variables should typically be
evaluated
  <em>after</em>
  a local dotfile and be permitted 
to override settings in it.
</p>
<p>
  There is one traditional Unix design pattern that we do not
recommend for new programs. Sometimes, user-set environment variables
are used as a lightweight substitute for expressing a program
preference in a run-control file.  The venerable
nethack(1)
dungeon-crawling game, for example, reads a
  <code>NETHACKOPTIONS</code> environment variable for user
preferences.  This is an old-school technique; modern practice would
lean toward parsing them from a
  <code>.nethack</code> or
  <code>.nethackrc</code> run-control file.
</p>
<p>
  The problem with the older style is that it makes tracking where
your preference information lives more difficult than it would be if
you knew the program had a run-control file under your home directory.
Environment variables can be set anywhere in several different shell
run-control files — under Linux these are likely to include
  <code>.profile</code>,
  <code>.bash_profile</code>, and
  <code>.bashrc</code> at least.  These files are cluttered and
fragile things, so as the code overhead of having an option-parser has
come to seem less significant preference information has tended to
migrate out of environment variables into dotfiles.
</p>
<h4 id="id2947980"><a href="#id2947980">§</a>Portability to Other Operating Systems</h4>
<p>
  Environment variables have only very limited portability off
Unix. Microsoft operating systems
  have an environment-variable feature
modeled on that of Unix, and use a
  <code>PATH</code> variable as
Unix does to set the binary search path, but most of other variables
that Unix shell programmers take for granted (such as process ID or
current working directory) are not supported. Other operating systems
(including classic MacOS) generally do not have any local equivalent
of environment variables.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2942782" id="ftn.id2942782">[102]</a></sup>
  Nobody knows a really graceful way to represent
this sort of distributed preference data; environment variables
probably are not it, but all the known alternatives have equally nasty
problems.
</p>

<p><sup><a href="#id2942810" id="ftn.id2942810">[103]</a></sup>
  Actually, most Unix programs first check
  <code>VISUAL</code>, and only if that's not set will they consult
  <code>EDITOR</code>. That's a relic from the days when people had
different preferences for line-oriented editors and visual
editors.
</p>
</div>


<!-- FILE: ch10s05.html -->
<h3 id="ch10s05"><a href="#ch10s05">§</a>Command-Line Options</h3>
<p>
  Unix tradition encourages the use of command-line switches to
control programs, so that options can be specified from scripts. This
is especially important for programs that function as pipes or
filters. Three conventions for how to distinguish command-line options
from ordinary arguments exist; the original Unix style, the GNU style,
and the X toolkit style.
</p>
<p>
  In the original Unix tradition, command-line options are single
letters preceded by a single hyphen. Mode-flag options that do not
take following arguments can be ganged together; thus, if
  <code>-a</code> and
  <code>-b</code> are mode options,
  <code>-ab</code> or
  <code>-ba</code> is also correct and
enables both. The argument to an option, if any, follows it
(optionally separated by whitespace). In this style, lowercase
options are preferred to uppercase. When you use uppercase options,
it's good form for them to be special variants of the lowercase
option.
</p>
<p>
  The original Unix style evolved on slow ASR-33 teletypes that made
terseness a virtue; thus the single-letter options. Holding down the
shift key required actual effort; thus the preference for lower case,
and the use of “-” (rather than the perhaps more
logical “+”) to enable options.
</p>
<p>
  The GNU style uses option keywords (rather than keyword letters)
preceded by two hyphens. It evolved years later when some of the
rather elaborate GNU utilities began to run out of single-letter
option keys (this constituted a patch for the symptom, not a cure for
the underlying disease). It remains popular because GNU options are
easier to read than the alphabet soup of older styles.  GNU-style
options cannot be ganged together without separating whitespace. An
option argument (if any) can be separated by either whitespace or a
single “=” (equal sign) character.
</p>
<p>
  The GNU double-hyphen option leader was chosen so that traditional
single-letter options and GNU-style keyword options could be
unambiguously mixed on the same command line. Thus, if your initial
design has few and simple options, you can use the Unix style without
worrying about causing an incompatible ‘flag day’ if you
need to switch to GNU style later on. On the other hand, if you are
using the GNU style, it is good practice to support single-letter
equivalents for at least the most common options.
</p>
<p>
  The X toolkit style, confusingly, uses a single hyphen and
keyword options. It is interpreted by X toolkits that filter out and
process certain options (such as
  <code>-geometry</code> and
  <code>-display</code>) before handing the filtered command line to
the application logic for interpretation. The X toolkit style is not
properly compatible with either the classic Unix or GNU styles, and
should not be used in new programs unless the value of being
compatible with older X conventions seems very high.
</p>
<p>
  Many tools accept a bare hyphen, not associated with any option
letter, as a pseudo-filename directing the application to read from
standard input.  It is also conventional to recognize a double hyphen
as a signal to stop option interpretation and treat all following
arguments literally.
</p>
<p>
  Most Unix programming languages offer libraries that will parse
a command line for you in either classic-Unix or GNU style
(interpreting the double-hyphen convention as well).
</p>
<h4 id="id2948149"><a href="#id2948149">§</a>The -a to -z of Command-Line Options</h4>
<p>
  Over time, frequently-used options in well-known Unix programs
have established a loose sort of semantic standard for what various flags
might be expected to mean. The following is a list of options and
meanings that should prove usefully unsurprising to an experienced
Unix user:
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     <code>-a</code> </span>
   </dt>
   <dd>
    <p>
     All (without argument). If there is a GNU-style
     <code>--all</code> option, for
     <code>-a</code> to be anything but a synonym for it
would be quite surprising. Examples:
fuser(1),
fetchmail(1).
    </p>
    <p>
     Append, as in
tar(1).
This is often paired with
     <code>-d</code> for delete.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-b</code> </span>
   </dt>
   <dd>
    <p>
     Buffer or block size (with argument). Set a critical buffer
size, or (in a program having to do with archiving or managing storage
media) set a block size. Examples:
du(1),
df(1),
tar(1).
    </p>
    <p>
     Batch. If the program is naturally interactive,
     <code>-b</code> may be used to suppress prompts or set other
options appropriate to accepting input from a file rather than a human
operator. Example:
flex(1).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-c</code> </span>
   </dt>
   <dd>
    <p>
     Command (with argument). If the program is an interpreter that
normally takes commands from standard input, it is expected that the
option of a
     <code>-c</code> argument will be passed to it as a
single line of input. This convention is particularly strong for
shells and shell-like interpreters. Examples:
sh(1),
ash(1),
bsh(1),
ksh(1),
python(1).
Compare
     <code>-e</code> below.
    </p>
    <p>
     Check (without argument). Check the correctness of the file
argument(s) to the command, but don't actually perform normal
processing. Frequently used as a syntax-check option by programs that
do interpretation of command files. Examples:
getty(1),
perl(1).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-d</code> </span>
   </dt>
   <dd>
    <p>
     Debug (with or without argument). Set the level of debugging
messages. This one is very common.
    </p>
    <p>
     Occasionally
     <code>-d</code> has the sense of
‘delete’ or ‘directory’.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-D</code> </span>
   </dt>
   <dd>
    <p>
     Define (with argument). Set the value of some symbol in an
interpreter, compiler, or (especially) macro-processor-like
application. The model is the use of
     <code>-D</code> by the C
     compiler's macro preprocessor.  This is a strong association 
for most Unix programmers; don't try to fight it.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-e</code> </span>
   </dt>
   <dd>
    <p>
     Execute (with argument). Programs that are wrappers, or that can
be used as wrappers, often allow
     <code>-e</code> to set the program they hand off
control to. Examples:
xterm(1),
perl(1).
    </p>
    <p>
     Edit. A program that can open a resource in either a read-only
or editable mode may allow
     <code>-e</code> to specify opening in the editable
mode. Examples:
crontab(1),
and the
get(1)
utility of the SCCS version-control system.
    </p>
    <p>
     Occasionally
     <code>-e</code> has the sense of ‘exclude’ or
‘expression’.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-f</code> </span>
   </dt>
   <dd>
    <p>
     File (with argument). Very often used with an argument to
specify an input (or, less frequently, output) file for programs that
need to randomly access their input or output (so that redirection via
&lt; or &gt; won't suffice). The classic example is
tar(1);
others abound.  It is also used to indicate that arguments normally
taken from the command line should be taken from a file instead;  see
awk(1)
and egrep(1)
for classic examples.
Compare
     <code>-o</code> below; often,
     <code>-f</code> is the input-side analog of
     <code>-o</code>.
    </p>
    <p>
     Force (typically without argument). Force some operation (such
as a file lock or unlock) that is normally performed
conditionally. This is less common.
    </p>
    <p>
     Daemons often use
     <code>-f</code> in a way that combines
these two meanings, to force processing of a configuration file from a
nondefault location. Examples:
ssh(1),
httpd(1),
and many other daemons.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-h</code> </span>
   </dt>
   <dd>
    <p>
     Headers (typically without argument). Enable, suppress, or
modify headers on a tabular report generated by the program.
Examples:
pr(1),
ps(1).
    </p>
    <p>
     Help. This is actually less common than one might expect offhand
— for much of Unix's early history developers tended to think of
on-line help as memory-footprint overhead they couldn't
afford. Instead they wrote manual pages (this shaped the man-page
style in ways we'll discuss in
     <a href="#documentationchapter" title="Chapter 18. Documentation">
      Chapter 18</a>).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-i</code> </span>
   </dt>
   <dd>
    <p>
     Initialize (usually without argument). Set some critical
resource or database associated with the program to an initial or
empty state.  Example:
ci(1)
in RCS.
    </p>
    <p>
     Interactive (usually without argument). Force a program that
does not normally query for confirmation to do so. There are classical
examples
(rm(1),
mv(1))
but this use is not common.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-I</code> </span>
   </dt>
   <dd>
    <p>
     Include (with argument). Add a file or directory name to those
searched for resources by the application. All Unix compilers with any
equivalent of source-file inclusion in their languages use
     <code>-I</code> in this sense. It would be extremely surprising to
see this option letter used in any other way.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-k</code> </span>
   </dt>
   <dd>
    <p>
     Keep (without argument). Suppress the normal deletion of
some file, message, or resource. Examples:
passwd(1),
bzip(1),
and
fetchmail(1).
    </p>
    <p>
     Occasionally
     <code>-k</code> has the sense of
‘kill’.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-l</code> </span>
   </dt>
   <dd>
    <p>
     List (without argument). If the program is an archiver or
interpreter/player for some kind of directory or archive format, it
would be quite surprising for
     <code>-l</code> to do anything but request an item
listing.  Examples:
arc(1),
binhex(1),
unzip(1). (However,
tar(1)
and
cpio(1)
are exceptions.)
    </p>
    <p>
     In programs that are already report generators,
     <code>-l</code> almost invariably means “long” and
triggers some kind of long-format display revealing more detail than
the default mode.  Examples:
ls(1),
ps(1).
    </p>
    <p>
     Load (with argument). If the program is a linker or a language
interpreter,
     <code>-l</code> invariably loads a library, in some
appropriate sense. Examples:
gcc(1),
f77(1),
emacs(1).
    </p>
    <p>
     Login.  In programs such as
rlogin(1)
and
ssh(1)
that need to specify a network identity,
     <code>-l</code> is how you do it.
    </p>
    <p>
     Occasionally
     <code>-l</code> has the sense of ‘length’ or
‘lock’.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-m</code> </span>
   </dt>
   <dd>
    <p>
     Message (with argument). Used with an argument,
     <code>-m</code> passes it
in as a message string for some logging or announcement purpose.
Examples:
ci(1),
cvs(1).
    </p>
    <p>
     Occasionally
     <code>-m</code> has the sense of ‘mail’,
‘mode’, or ‘modification-time’.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-n</code> </span>
   </dt>
   <dd>
    <p>
     Number (with argument). Used, for example, for page number
ranges in programs such as
head(1),
tail(1),
nroff(1),
and
troff(1). Some
networking tools that normally display DNS names accept
     <code>-n</code> as an option that causes them to display the raw
IP addresses instead;
ifconfig(1)
and
tcpdump(1)
are the archetypal examples.
    </p>
    <p>
     Not (without argument). Used to suppress normal actions in
programs such as make(1).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-o</code> </span>
   </dt>
   <dd>
    <p>
     Output (with argument). When a program needs to specify an
output file or device by name on the command line, the
     <code>-o</code> option does it. Examples:
as(1),
cc(1),
sort(1). On
anything with a compiler-like interface, it would be extremely
surprising to see this option used in any other way.  Programs that
support
     <code>-o</code> often (like gcc) have logic that allows it
to be recognized after ordinary arguments as well as before.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-p</code> </span>
   </dt>
   <dd>
    <p>
     Port (with argument). Especially used for options that specify
TCP/IP
     port numbers.
Examples:
cvs(1),
the PostgreSQL tools, the
smbclient(1),
snmpd(1),
ssh(1).
    </p>
    <p>
     Protocol (with argument). Examples:
fetchmail(1),
snmpnetstat(1).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-q</code> </span>
   </dt>
   <dd>
    <p>
     Quiet (usually without argument). Suppress normal result or
diagnostic output. This is very common.  Examples: ci(1), co(1), 
make(1).  See also the ‘silent’ sense of
     <code>-s</code>.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-r</code> (also
     <code>-R</code>)
    </span>
   </dt>
   <dd>
    <p>
     Recurse (without argument). If the program operates on a
directory, then this option might tell it to recurse on all
subdirectories. Any other use in a utility that operated on
directories would be quite surprising. The classic example is, of
course, cp(1).
    </p>
    <p>
     Reverse (without argument). Examples:
ls(1),
sort(1). A
filter might use this to reverse its normal translation action
(compare
     <code>-d</code>).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-s</code> </span>
   </dt>
   <dd>
    <p>
     Silent (without argument). Suppress normal diagnostic or result
output (similar to
     <code>-q</code>; when both are supported, q
means ‘quiet’ but
     <code>-s</code> means ‘utterly
silent’). Examples:
csplit(1),
ex(1),
fetchmail(1).
    </p>
    <p>
     Subject (with argument).
     <em>Always</em>
     used with
this meaning on commands that send or manipulate mail or news
messages.  It is extremely important to support this, as programs
that send mail expect it. Examples: mail(1), elm(1), mutt(1).
    </p>
    <p>
     Occasionally
     <code>-s</code> has the sense of
‘size’.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-t</code> </span>
   </dt>
   <dd>
    <p>
     Tag (with argument). Name a location or give a string for a
program to use as a retrieval key. Especially used with text editors
and viewers. Examples:
cvs(1),
ex(1),
less(1),
vi(1).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-u</code> </span>
   </dt>
   <dd>
    <p>
     User (with argument). Specify a user, by name or numeric UID.
Examples:
crontab(1),
emacs(1),
fetchmail(1),
fuser(1),
ps(1).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-v</code> </span>
   </dt>
   <dd>
    <p>
     Verbose (with or without argument). Used to enable
transaction-monitoring, more voluminous listings, or debugging
output. Examples:
cat(1),
cp(1),
flex(1),
tar(1),
many others.
    </p>
    <p>
     Version (without argument). Display program's version on
standard output and exit. Examples:
cvs(1),
chattr(1),
patch(1),
uucp(1). More
usually this action is invoked by
     <code>-V</code>.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-V</code> </span>
   </dt>
   <dd>
    <p>
     Version (without argument). Display program's version on
standard output and exit (often also prints compiled-in configuration
details as well). Examples: gcc(1), flex(1), hostname(1),
many others. It would be quite surprising for this switch to be
used in any other way.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-w</code> </span>
   </dt>
   <dd>
    <p>
     Width (with argument). Especially used for specifying widths in
output formats. Examples:
faces(1),
grops(1),
od(1),
pr(1),
shar(1).
    </p>
    <p>
     Warning (without argument). Enable warning diagnostics, or
suppress them. Examples:
fetchmail(1),
flex(1),
nsgmls(1).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-x</code> </span>
   </dt>
   <dd>
    <p>
     Enable debugging (with or without argument). Like
     <code>-d</code>. Examples:
sh(1),
uucp(1).
    </p>
    <p>
     Extract (with argument). List files to be extracted from an
archive or working set. Examples:
tar(1),
zip(1).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-y</code> </span>
   </dt>
   <dd>
    <p>
     Yes (without argument). Authorize potentially destructive
actions for which the program would normally require confirmation.
Examples:
fsck(1),
rz(1).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>-z</code> </span>
   </dt>
   <dd>
    <p>
     Enable compression (without argument). Archiving and backup
programs often use this. Examples:
bzip(1),
GNU
tar(1),
zcat(1),
zip(1),
cvs(1).
    </p>
   </dd>
  </dl>
 </div>
<p>
  The preceding examples are taken from the
Linux
  toolset, but should be good on most modern Unixes.
</p>
<p>
  When you're choosing command-line option letters for your
program, look at the manual pages for similar tools.  Try to use the
same option letters they use for the analogous functions of your
program.  Note that some particular application areas that have
particularly strong conventions about command-line switches which you
violate at your peril — compilers, mailers, text filters,
network utilities and X software are all notable for this.  Anybody
who wrote a mail agent that used
  <code>-s</code> as anything but a
Subject switch, for example, would have scorn rightly heaped upon the
choice.
</p>
<p>
  The GNU project
  recommends conventional meanings for
a few double-dash options in the GNU coding
standards.<sup><a href="#ftn.id2950141" id="id2950141">[104]</a></sup>
  It also lists long options
which, though not standardized, are used in many GNU programs.
If you are using GNU-style options, and some option you need has
a function similar to one of those listed, by all means 
obey the Rule of Least Surprise and reuse the name.
</p>
<h4 id="id2950162"><a href="#id2950162">§</a>Portability to Other Operating Systems</h4>
<p>
  To have command-line options, you have to have a command line.
The MS-DOS family does, of course, though in Windows it's hidden by a
GUI and its use is discouraged; the fact that the option character is
normally ‘
  <code>/</code> ’ rather than ‘
  <code>-</code> ’ is merely a
detail.  MacOS classic and other pure GUI environments have no close
equivalent of command-line options.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2950141" id="ftn.id2950141">[104]</a></sup>
  See the
  <a href="http://www.gnu.org/prep/standards.html">
   Gnu Coding
Standards</a>.
</p>
</div>


<!-- FILE: ch10s06.html -->
<h3 id="ch10s06"><a href="#ch10s06">§</a>How to Choose among the Methods</h3>
<p>
  We've looked in turn at system and user run-control files, at
environment variables, and at command-line arguments. Observe the
progression from least easily changed to most easily changed. There is
a strong convention that well-behaved Unix programs that use more than
one of these places should look at them in the order given, allowing
later settings to override earlier ones (there are specific
exceptions, such as command-line options that specify where a dotfile
should be found).
</p>
<p>
  In particular, environment settings usually override dotfile
settings, but can be overridden by command-line options. It is good
practice to provide a command-line option like the
  <code>-e</code> of
make(1) 
that can override environment settings or declarations in run-control files;
that way the program can be scripted with well-defined behavior
regardless of the way the run-control files look or environment
variables are set.
</p>
<p>
  Which of these places you choose to look at depends on how much
persistent configuration state your program needs to keep around
between invocations. Programs designed mainly to be used in a batch
mode (as generators or filters in pipelines, for example) are usually
completely configured with command-line options. Good examples of this
pattern include
ls(1),
grep(1)
and
sort(1). At
the other extreme, large programs with complicated interactive
behavior may rely entirely on run-control files and environment
variables, and normal use involves few command-line options or none at
all. Most X window managers are a good example of this pattern.
</p>
<p>
  (Unix has the capability for the same file to have multiple
names or ‘links’.  At startup time, every program has
available to it the filename through which it was called.
One other way to signal to a program that has several modes of
operation which one it should come up in is to give it a link for each
mode, have it find out which link it was called through, and change 
its behavior accordingly.  But this technique is generally considered
unclean and seldom used.)
</p>
<p>
  Let's look at a couple of programs that gather configuration
data from all three places. It will be instructive to consider why,
for each given piece of configuration data, it is collected as it
is.
</p>
<h4 id="fetchmail_environment"><a href="#fetchmail_environment">§</a>
  Case Study:
fetchmail
 </h4>
<p>
  The
  <em>fetchmail</em> program uses only two
environment variables,
  <code>USER</code> and
  <code>HOME</code>. These variables are in the predefined set
initialized by the system; many programs use them.
</p>
<p>
  The value of
  <code>HOME</code> is used to find the dotfile
  <code>.fetchmailrc</code>, which contains configuration
information in a fairly elaborate syntax obeying the shell-like
lexical rules described above. This is appropriate because, once it
has been initially set up, Fetchmail's
configuration will change only infrequently.
</p>
<p>
  There is neither an
  <code>/etc/fetchmailrc</code> nor
any other systemwide file specific to fetchmail. Normally such files
hold configuration that's not specific to an individual user.
fetchmail does use a small set of properties with this kind of scope
— specifically, the name of the local postmaster, and a few
switches and values describing the local mail transport setup (such as
the port number of the local SMTP listener). In practice, however,
these are seldom changed from their compiled-in default values.  When
they are changed, they tend to be modified in user-specific
ways. Thus, there has been no demand for a systemwide fetchmail 
run-control file.
</p>
<p>
  Fetchmail can retrieve host/login/password triples from a
  <code>.netrc</code> file. Thus, it gets authenticator
information in the least surprising way.
</p>
<p>
  Fetchmail has an elaborate set of command-line options, which
nearly but do not entirely replicate what the
  <code>.fetchmailrc</code> can express. The set was not
originally large, but grew over time as new constructs were added to
the
  <code>.fetchmailrc</code> minilanguage and parallel
command-line options for them were added more or less
reflexively.
</p>
<p>
  The intent of supporting all these options was to make
fetchmail easier to script by allowing
users to override bits of its run control from the command line. But
it turns out that outside of a few options like
  <code>--fetchall</code> and
  <code>--verbose</code> there is
little demand for this — and none that can't be satisfied with a
shellscript that creates a temporary run-control file on the fly and
then feeds it to fetchmail using the
  <code>-f</code> option.
</p>
<p>
  Thus, most of the command-line options are never used, and in
retrospect including them was probably a mistake; they bulk up the
fetchmail code a bit without accomplishing
anything very useful.
</p>
 <blockquote>
  <p>
   If bulking up the code were the only problem, nobody would care,
except for a couple of maintainers.  However, options increase the
chances of error in code, particularly due to unforeseen interactions
among rarely used options.  Worse, they bulk up the manual, which is a
burden on everybody.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  There is a lesson here; had I thought carefully enough about
fetchmail's usage pattern and been a little less ad-hoc about adding
features, the extra complexity might have been avoided.
</p>
 <blockquote>
  <p>
   An alternative way of dealing with such situations, which
doesn't clutter up either the code or the manual much, is to have a
“set option variable” option, such as the
   <code>-O</code> option of
   <em>sendmail</em>,
which lets you specify an option name and value, and sets that name to
that value as if such a setting had been given in a configuration
file.  A more powerful variant of this is what
   <em>ssh</em> does with its
   <code>-o</code> option: the argument to
   <code>-o</code> is treated as if it were a
line appended to the configuration file, with the full config-file
syntax available.  Either of these approaches gives people with
unusual requirements a way to override configuration from the command
line, without requiring you to provide a separate option for each bit
of configuration that might be overridden.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<h4 id="id2950578"><a href="#id2950578">§</a>Case Study: The XFree86 Server</h4>
<p>
  The X windowing system is the engine that supports bitmapped 
displays on Unix machines. Unix applications running through a client machine
with a bitmapped display get their input events through X and 
send screen-painting requests to it.  Confusingly, X ‘servers’
actually run on the client machine — they exist to serve requests to
interact with the client machine's display device.  The applications
sending those requests to the X server are called ‘X
clients’, even though they may be running on a server machine.
And no, there is no way to explain this inverted terminology that is
not confusing.
</p>
<p>
  X servers have a forbiddingly complex interface to their
environment. This is not surprising, as they have to deal with a wide
range of complex hardware and user preferences. The environment
queries common to all X servers, documented on the
X(1)
and
Xserver(1)
pages, therefore make a useful example for study.  The implementation
we examine here is XFree86, the X implementation used under
Linux
  and several other open-source Unixes.
</p>
<p>
  At startup, the XFree86 server examines a systemwide run-control file; the exact pathname varies between X builds on
  different platforms, but the basename is XF86Config. The XF86Config file has a shell-like syntax as described above.
  Example 10.2 is a sample section of an XF86Config file.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 10.2. X configuration example.
   </b>
  </p>
  <pre class="programlisting">
# The 16-color VGA server

Section "Screen"
    Driver      "vga16"
    Device      "Generic VGA"
    Monitor     "LCD Panel 1024x768"
    Subsection  "Display"
        Modes       "640x480" "800x600"
        ViewPort    0 0
    EndSubsection
EndSection
</pre>
 </div>
<p>
  The XF86Config file describes the host machine's display
hardware (graphics card, monitor), keyboard, and pointing device
(mouse/trackball/glidepad). It's appropriate for this information to
live in a systemwide run-control file, because it applies to all
users of the machine.
</p>
<p>
  Once X has acquired its hardware configuration from the run
control file, it uses the value of the environment variable
  <code>HOME</code> to find two dotfiles in the calling user's home
directory. These files are
  <code>.Xdefaults</code> and
  <code>.xinitrc</code>.<sup><a href="#ftn.id2950710" id="id2950710">[105]</a></sup>
</p>
<p>
  The
  <code>.Xdefaults</code> file specifies per-user,
application-specific resources relevant to X (trivial examples of
these might include font and foreground/background colors for a
terminal emulator). The phrase ‘relevant to X’ indicates a
design problem, however.  Collecting all these resource declarations
in one place is convenient for inspecting and editing them, but it is
not always clear what should be declared in
  <code>.Xdefaults</code> and what belongs in an
application-specific dotfile. The
  <code>.xinitrc</code> file
specifies the commands that should be run to initialize the user's X
desktop just after server startup. These programs will almost always
include a window or session manager.
</p>
<p>
  X servers have a large set of command-line options. Some of
these, such as the
  <code>-fp</code> (font path) option, override
the XF86Config.  Some are intended to help track server bugs, such as
the
  <code>-audit</code> option; if these are used at all, they are
likely to vary quite frequently between test runs and are therefore
poor candidates to be included in a run-control file. A very important
option is the one that sets the server's display number. Multiple
servers may run on a host provided each has a unique display number,
but all instances share the same run-control file(s); thus, the
display number cannot be derived solely from those files.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2950710" id="ftn.id2950710">[105]</a></sup>
  The
  <code>.xinitrc</code> is analogous to a Startup folder on
Windows and other operating systems.
</p>
</div>


<!-- FILE: ch10s07.html -->
<h3 id="ch10s07"><a href="#ch10s07">§</a>On Breaking These Rules</h3>
<p>
  The conventions described in this chapter are not absolute, but
violating them will increase friction costs for users and
developers in the future. Break them if you must — but be sure you
know exactly why you are doing so before you do it. And if you do
break them, make sure that attempts to do things in conventional ways
break noisily, giving proper error feedback in accordance with the
Rule of Repair.
</p>



<!-- FILE: interfacechapter.html -->
<h3 id="interfacechapter"><a href="#interfacechapter">§</a>Chapter 11. Interfaces</h3>
 <blockquote class="epigraph">
  <p>
   All our knowledge has its origins in our perceptions.
  </p>
  <span>
   – Leonardo Da Vinci
  </span>
 </blockquote>
<p>
  The interface of a program is the sum of all the ways that it
communicates with human users and other programs.  In
  <a href="#configurationchapter" title="Chapter 10. Configuration">
   Chapter 10</a>, we discussed the use of environment
variables, switches, run-control files and other parts of
start-up-time interfaces. In this chapter, we'll untangle the history
and explain the pragmatics of Unix interfaces after startup time.
Because user-interface code normally consumes 40% or more of development
time, knowing good design patterns is especially important here in
order to avoid a lot of false starts and time-intensive
rewrites.
</p>
<p>
  In the Unix tradition of interface design, we encounter two
themes over and over again. One is anticipatory design for
communication with other programs; the other is the Rule of Least
Surprise.
</p>
<p>
  Unix programs can give you extra power from being used in
synergistic combinations; we discussed various methods for hooking
together such combinations in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>. The ‘other programs’ part
of Unix interface design is not an afterthought or a marginal case as
it is under many other operating systems. Rather, it is a central
challenge that has to be balanced and integrated carefully with the
demands of interface design for human users.
</p>
<p>
  Much of Unix-community tradition about program interface design
may seem odd and arbitrary — or even, in the age of the GUI,
downright regressive — when you encounter that tradition for the
first time.  But in spite of various blemishes and irregularities,
that tradition has an inner logic to it which is worth learning and
understanding. It reflects heuristics accumulated over Unix's long
history about ways to do effective communication both with human
beings and with other programs. And it includes a set of conventions
which create commonalities between programs — it defines
‘least surprising’ alternatives for a wide range of common
interface-design problems.
</p>
<p>
  After startup, programs normally get input or commands from the
following sources:
</p>
 <div>
  <ul>
   <li>
    <p>
     Data and commands presented on the program's standard
input.
    </p>
   </li>
   <li>
    <p>
     Inputs passed through IPC, such as X server events and
network messages.
    </p>
   </li>
   <li>
    <p>
     Files and devices in known locations (such as a data file name
passed to or computed by the program).
    </p>
   </li>
  </ul>
 </div>
<p>
  Programs can emit results in all the same ways (with output
going to standard output).
</p>
<p>
  Some Unix programs are graphical, some have screen-oriented
character interfaces, and some use a starkly simple text-filter
design unchanged from the days of mechanical teletypes. To the
uninitiated, it is often far from obvious why any given program
uses the style it does — or, indeed, why Unix supports such a
plethora of interface styles at all.
</p>
<p>
  Unix has several competing interface styles.  All are still
alive for a reason; they're optimized for different situations. By
understanding the fit between task and interface style, you will learn
how to choose the right styles for the jobs you need to do.
</p>



<!-- FILE: ch11s01.html -->
<h3 id="ch11s01"><a href="#ch11s01">§</a>Applying the Rule of Least Surprise</h3>
<p>
  The Rule of Least Surprise is a general principle in the design
of all kinds of interfaces, not just software: “Do the least
surprising thing”. It's a consequence of the fact that human
beings can only pay attention to one thing at one time (see
  <em>The Humane Interface</em> <sup><a href="#Raskin" title="[Raskin]">[Raskin]</a></sup>).  Surprises in the interface focus
that single locus of attention on the interface, rather than on the
task where it belongs.
</p>
<p>
  Thus, to design usable interfaces, it's best when possible not
to design an entire new interface model. Novelty is a barrier to
entry; it puts a learning burden on the user, so minimize it. Instead,
think carefully about the experience and knowledge of your user
base. Try to find functional similarities between your program and
programs they are likely to already know about. Then mimic the
relevant parts of the existing interfaces.
</p>
<p>
  The Rule of Least Surprise should not be interpreted as a call
for mechanical conservatism in design. Novelty raises the cost of a
user's first few interactions with an interface, but poor design
will make the interface needlessly painful forever. As in other
sorts of design, rules are not a substitute for good taste and
engineering judgment. Consider your tradeoffs carefully — and
consider them from the
  <em>user's</em>
  point of view. The bias
implied by the Rule of Least Surprise is a good one to hold
consciously, mainly because interface designers (like other
programmers) have an unconscious tendency to be too clever for the
user's good.
</p>
<p>
  One implication of the Rule of Least Surprise is this: Wherever
possible, allow the user to delegate interface functions to a familiar
program. We already observed in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  that, if your program requires the
user to edit significant amounts of text, you should write it to call
an editor (specifiable by the user) rather than building in your own
integrated editor.  This will enable the
  <em>users</em>,
who know their preferences better than you, to choose the least
surprising alternative.
</p>
<p>
  Elsewhere in this book we have advocated symbiosis and
delegation as tactics for promoting code reuse and minimizing
complexity. The point here is that when users can intercept the
delegation, and direct it to an agent of their own choice,
these techniques become not merely economical for the developer but
actively empowering to users.
</p>
<p>
  Further: When you can't delegate, emulate. The purpose of the
Rule of Least Surprise is to reduce the amount of complexity a user
must absorb to use an interface. Continuing the editor example, this
means that if you must implement an embedded editor, it's best if the
editor commands are a subset of those for a well-known general-purpose
editor. (Or more than one.  Both
  <em>bash</em> and
  <em>ksh</em> have command-line editors that allow
the user to choose between
  <em>vi</em> and
  <em>Emacs</em> editing styles.)
</p>
<p>
  Under the Unix versions of the Netscape and Mozilla Web
browsers, for example, fill-in fields in forms recognize a subset of
the default bindings for the
  <em>Emacs</em> editor. Control-A goes to start of line, Control-D deletes the next
character, and so forth. This choice helps people who know
  <em>Emacs</em>, and leaves others no worse off than
an arbitrary, idiosyncratic command set would have. The only way it
could have been bettered was by choosing key bindings associated with
some editor significantly more widely used than
  <em>Emacs</em>; and among Netscape's original user
population there was no such animal.
</p>
<p>
  These principles can be applied in many other areas of interface
design. They suggest, for example, that it is deeply foolish to create
novel document formats for an on-line help system when users are
comfortable with an HTML Web browser. Or even that if you are
designing an arcade-style game, it is wise to look at the gesture sets
of previous games to see if you can give new users a feeling of
comfort by allowing them to transfer joystick skills learned in other
games.
</p>



<!-- FILE: ch11s02.html -->
<h3 id="ch11s02"><a href="#ch11s02">§</a>History of Interface Design on Unix</h3>
<p>
  Unix predates the modern graphics-intensive style of software
interface design. For over a decade after the first Unix in 1969,
command-line interfaces (CLIs) on teletypes and dumb text-mode
terminals were the norm. Most of the basic Unix toolset (programs like
ls(1),
cat(1),
and
grep(1))
still reflect this heritage.
</p>
<p>
  Gradually, after 1980, Unix evolved support for screen-painting
on character-cell terminals. Programs began to mix command-line and
visual interfaces, with common commands often bound to keystrokes that
would not be echoed to the screen. Some of the early programs written
in this style (often called ‘curses’ programs, after the
screen-painting cursor-control library normally used to implement
them, or ‘roguelike’ after the first application to use
curses) are still used today; notable examples include the
dungeon-crawling game
rogue(1),
the
vi(1)
  text editor, and (from a few years later) the
elm(1)
mailer and its modern descendant
mutt(1).
</p>
<p>
  A few years later in the mid-1980s, the computing world as a
whole began to assimilate the results of the pioneering work on
graphical user interfaces (GUIs) that had been going on at Xerox's
Palo Alto Research Center since the early 1970s. On personal
computers, the Xerox PARC
  work inspired the Apple Macintosh interface
and through that the design of Microsoft
Windows. Unix's adaptation of these ideas took a
rather more complicated path.
</p>
<p>
  Around 1987 the X windowing system
  outcompeted several early contenders and
prototype efforts to become the standard graphical-interface facility
for Unix. Whether this was a good or a bad thing has remained a topic
of debate ever since; some of the other contenders (notably Sun's
Network Window System or NeWS)
  were arguably rather more powerful
and elegant. X, however, had one overriding virtue; it was open
source. The code had been developed at MIT by a research group more
interested in exploring the problem space than in creating a product,
and it remained freely redistributable and modifiable. It was thus
able to attract support from a wide range of developers and sponsoring
corporations who would have been reluctant to line up behind a single
vendor's closed product. (This, of course, prefigured an important
theme in the breakout of the Linux operating
system
  ten years later.)
</p>
<p>
  The designers of X decided early on that X would support
“mechanism, not policy”. Their objective was to make X as
flexible and portable across platforms as possible, while putting as
few constraints on the look and feel of X programs as they could
manage. Look and feel, they decided, would be handled by
‘toolkits’ — libraries calling X services linked to
user programs. X would also be designed to support multiple window
managers,<sup><a href="#ftn.id2951032" id="id2951032">[106]</a></sup>
  and would not require a
window manager to have any special privileges or uniquely close
integration with X's machinery.
</p>
<p>
  This approach was the polar opposite of that taken by the
Macintosh and Windows commercial products, which enforced
particular look-and-feel policies by designing them right into the
system. The difference in approach ensured that X would have a
long-run evolutionary advantage by remaining adaptable as new
discoveries were made about the human factors in interface design
— but it also ensured that the X world would be divided by
multiple toolkits, a profusion of window managers, and many
experiments in look and feel.
</p>
<p>
  Since the mid-1990s X has become ubiquitous even on the
lowest-end personal Unix machines. Use of Unix from text-mode
terminals, as opposed to graphics-capable computer consoles, has
sharply declined and seems headed for extinction. Accordingly, the
use of curses-style interfaces for new applications is also in
decline; most new applications that would formerly have been
designed in that style now use an X toolkit. It is instructive to
note that Unix's older CLI design tradition is still
quite vigorous and successfully competes with X in many areas.
</p>
<p>
  It is also instructive to note that there are a few
specific application areas in which curses-style (or
‘roguelike’) character-cell interfaces remain the norm
— especially text editors and interactive communications
programs such as mailers, newsreaders, and chat clients.
</p>
<p>
  For historical reasons, then, there is a wide range of
interface styles in Unix programs. Line-oriented, character-cell
screen-oriented, and X-based — with the X-based world somewhat
balkanized by the competition between multiple X toolkits and
window managers (though this is less an issue in 2003 than
was the case five or even three years ago).
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2951032" id="ftn.id2951032">[106]</a></sup>
  A window manager handles associations between
windows on the screen and running tasks. Window managers handle
behaviors like title bars, placement, minimizing, maximizing, moving,
resizing, and shading windows.
</p>
</div>


<!-- FILE: ch11s03.html -->
<h3 id="ch11s03"><a href="#ch11s03">§</a>Evaluating Interface Designs</h3>
<p>
  All these interface styles survive because they are adapted for
different jobs. When making design decisions about a project, it's
important to know how to pick a style (or combine styles) that will be
appropriate to your application and your user population.
</p>
<p>
  We will use five basic metrics to categorize interface
styles:
  <em>concision</em>,
  <em>expressiveness</em>,
  <em>ease</em>,
  <em>transparency</em>, and
  <em>scriptability</em>.  We've already used some of
these terms earlier in this book in ways that were preparation for
defining them here.  They are comparatives, not absolutes; they have
to be evaluated with respect to a particular problem domain and with
some knowledge of the users' skill base. Nevertheless, they will help
organize our thinking in useful ways.
</p>
<p>
  A program interface is ‘concise’ when the length and
complexity of actions required to do a transaction with it has a low
upper bound (the measurement might be in keystrokes, gestures, or
seconds of attention required). Concise interfaces pack a lot of
leverage into a relatively few bits or state changes.
</p>
<p>
  Interfaces are ‘expressive’ when they can readily be
used to command a wide variety of actions. The
  <em>most</em>
  expressive interfaces can command
combinations of actions not anticipated by the designer of the
program, but which nevertheless give the user useful and consistent
results.
</p>
<p>
  The difference between concision and expressiveness is an
important one. Consider two different ways of entering text: from a
keyboard, or by picking characters from a screen display with mouse
clicks. These have equal expressiveness, but the keyboard is more
concise (as we can easily verify by comparing average text-entry
speeds). On the other hand, consider two dialects of the same
programming language, one with a complex-number type and one not.
Within the problem domain they have in common, their concision will
be identical; but for a mathematician or electrical engineer, the
dialect with complex numbers will be much more expressive.
</p>
<p>
  The ‘ease’ of an interface is inversely proportional
to the mnemonic load it puts on the user — how many things
(commands, gestures, primitive concepts) the user has to remember
specifically to support using that interface. Programming languages
have a high mnemonic load and low ease; menus and well-labeled
on-screen buttons are simpler.
</p>
<p>
  Recall that we devoted an entire earlier chapter to
‘transparency’.  In that chapter we touched on the idea of
interface transparency, and gave the
  <a href="#audacity" title="Case Study: audacity"><em>audacity audio editor</em></a>
  as one superb example of it.  But we were
then much more interested in transparency of a different kind, one
that relates to the structure of code rather than of user interfaces.
We therefore described UI transparency in terms of its effect (nothing
obtrudes between the user and the problem domain) rather than the
specific features of design that produce it.  Now it's time to zero in
on these.
</p>
<p>
  The ‘transparency’ of an interface is how few things
the user has to remember about the state of his problem, his data, or
his program while
  <em>using</em>
  the interface.  An interface has high
transparency when it naturally presents intermediate results, useful
feedback, and error notifications on the effects of a user's
actions. So-called WYSIWYG (What You See Is What You Get) interfaces
are intended to maximize transparency, but sometimes backfire —
especially by presenting an over-simplified view of the
domain.
</p>
<p>
  The related concept of discoverability applies to interface
design, as well.  A discoverable interface provides the user with
assistance in learning it, such as a greeting message pointing to
context-sensitive help, or explanatory balloon popups.  Though
discoverability has to be implemented in rather different ways
for each of the interface styles we shall consider, the degree to
which it is achievable is largely independent of interface style.
Thus, we shall not use it as a metric in this discussion.
</p>
<p>
  Note that transparency of code and design does not automatically imply 
transparency of interface, or vice versa!  It is all too easy to point
to code that has one but not the other.
</p>
<p>
  The ‘scriptability’ of an interface is the ease with
which it can be manipulated by other programs (e.g., through the IPC
mechanisms discussed in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>). Scriptable programs are readily
usable as components by other programs, reducing the need for costly
custom coding and making it relatively easy to automate repetitive
tasks.
</p>
<p>
  That last point — automating repetitive tasks —
deserves more attention than it usually gets.  Unix programmers,
administrators, and users develop a habit of thinking through the
routine procedures they use, then packaging them so they no longer
have to manually execute or even think about them any more.  This
habit depends on scriptable interfaces.  It is a quiet but tremendous
productivity booster not available in most other software
environments.
</p>
<p>
  It will be useful to bear in mind that humans and computer
programs have very different cost functions with respect to these
metrics. So do novice and expert human users in a particular problem
domain. We'll explore how the tradeoffs between them change for
different user populations.
</p>



<!-- FILE: ch11s04.html -->
<h3 id="ch11s04"><a href="#ch11s04">§</a>Tradeoffs between CLI and Visual Interfaces</h3>
<p>
  The CLI style of early Unix has retained its utility long after
the demise of teletypes for two reasons. One is that command-line and
command-language interfaces are more expressive than visual
interfaces, especially for complex tasks. The other is that CLI
interfaces are highly scriptable — they readily support the
combining of programs, as we discussed in detail in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>.  Usually (though not always) CLIs
have an advantage in concision as well.
</p>
<p>
  The disadvantage of the CLI style, of course, is that it almost
always has high mnemonic load (low ease), and usually has low
transparency. Most people (especially
non-technical end users) find such interfaces relatively cryptic and
difficult to learn.
</p>
 <blockquote>
  <p>
   On the other hand, the ‘user-friendly’ GUIs of other
operating systems have their own problems.  Finding the right buttons
to push is like playing Adventure: the interfaces are just as
burdensome as any Unix command line interface, save that one can in
theory find the treasure by sufficient exploration.  In Unix, one
needs the manual.
  </p>
  <span>
   – Brian Kernighan
  </span>
 </blockquote>
<p>
  Database queries are a good example of the kind of interface for
which pushing buttons is not just burdensome but extremely limiting.
Neither keystroke commands to a full-screen character interface nor
GUI gestures on a graphic display can express typical actions in
the problem domain as expressively or concisely as typing SQL
direct to a server. And it is certainly easier to make a client
program utter SQL queries than it would be to have it simulate a
user clicking a GUI!
</p>
<p>
  On the other hand, many non-technical database users are so
resistant to having to remember SQL syntax that they prefer a less
concise and less expressive full-screen or GUI interface.
</p>
<p>
  SQL is a good example for illustrating another point.  The most
powerful CLIs are not ad-hoc collections of commands, but imperative
minilanguages designed along the lines we described in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>. These minilanguages are the
highest-power, highest-complexity end of the CLI spectrum; they
maximize expressiveness, but minimize ease.  They are difficult to use
and generally need to be discreetly veiled from ordinary end-users,
but unbeatable when the capability and flexibility of the interface is
the most important thing.  When properly designed, they also score
high on scriptability.
</p>
<p>
  Some applications, unlike database queries, are naturally
visual. Paint programs, Web browsers, and presentation software make
three excellent examples. What these application domains have in common
is that (a) transparency is extremely valuable, and (b) the primitive
actions in the problem domain are themselves visual: “draw
this”, “show me what I'm pointing at”, “put
this here”.
</p>
<p>
  The flip side of paint programs is that it is
difficult to capture relationships within the pictures they are 
manipulating. It takes careful, thoughtful design to give the user any
handle on the structure of images with repeated elements, for
example. This is a general design problem with visual interfaces.
</p>
<p>
  In
  <a href="#transparencychapter" title="Chapter 6. Transparency">
   Chapter 6</a>
  we
looked at the Audacity sound file editor.  Its interface design
succeeds because it does a particularly clean job of mapping its audio
application domain onto a simple set of visual representations
(borrowed from equalizer displays on stereos).  It does this by
thoroughly following through the consequences of a single translation:
sounds to waveform images.  The visual operations are not a mere
grab-bag of low-level tweaks; they are all tied to that
translation.
</p>
<p>
  In applications that are
  <em>not</em>
  naturally
visual, however, visual interfaces are most appropriate for simple
one-shot or infrequent tasks performed by novice users (a point the
database example illustrates).
</p>
<p>
  Resistance to CLI interfaces tends to decrease as users become
more expert. In many problem domains, users (especially
  <em>frequent</em>
  users) reach a crossover point at which
the concision and expressiveness of CLI becomes more valuable than
avoiding its mnemonic load. Thus, for example, computing novices
prefer the ease of GUI desktops, but experienced users often gradually
discover that they prefer typing commands to a shell.
</p>
<p>
  CLIs also tend to gain utility as problems scale up and involve
more in the way of canned, procedural and repetitive actions. Thus,
for example, a WYSIWYG desktop-publishing program is usually the
easiest route to composing relatively small and unstructured documents
such as business letters. But for complex book-sized documents that
are assembled from sections and may require many global format changes
or structural manipulation during composition, a minilanguage
formatter such as
  <em>troff</em>,
  <em>Tex</em>, or some XML-markup
processor
  is usually a
more effective choice (see
  <a href="#documentationchapter" title="Chapter 18. Documentation">
   Chapter 18</a>
  for more discussion of this
tradeoff).
</p>
<p>
  Even in domains that are naturally visual, scaling up the
problem size tends to tilt the tradeoff toward a CLI. If you need to
fetch and save one Web page from a given URL, point and click (or type
and click) is fine.  But for Web forms, you're going to use a
keyboard.  And if you need to fetch and save the pages corresponding
to a given list of fifty URLs, a CLI client that can read URLs from
standard input or the command line can save you a lot of unnecessary
motion.
</p>
<p>
  As another example, consider modifying the color table in a
graphic image. If you want to change one color (say, to lighten it by
an amount you will only know is right when you see it) a visual
dialogue with a color-picker widget is almost mandatory. But suppose
you need to replace the entire table with a set of specified RGB
values, or to create and index large numbers of thumbnails. These are
operations that GUIs usually lack the expressive power to
specify. Even when they do, invoking a properly designed CLI or filter
program will do the job far more concisely.
</p>
<p>
  Finally (as we observed earlier on) CLIs are important in 
facilitating using programs from other programs. A GUI graphics
editor that
  <em>can</em>
  handle making a batch of
thumbnails for a list of files probably does it with a plugin written
in a scripting language, calling an internal CLI of the graphics
editor (as in the GIMP's
  script-fu facility). Unix environments bring the value of CLIs into
sharper relief precisely because their IPC facilities are rich, have
low overhead, and are easily accessible from user programs.
</p>
<p>
  The explosion of interest in GUIs since 1984 has had the
unfortunate effect of obscuring the virtues of CLIs. The design of
consumer software, in particular, has become heavily skewed toward
GUIs. While this is a good choice for the novice and casual users that
constitute most of the consumer market, it also exacts hidden costs on
more expert users as they run up against the expressiveness limits of
GUIs — costs which steadily increase as the users take on more
demanding problems. Most of these costs derive from the fact that GUIs
are simply not scriptable at all —
  <em>every</em>
  interaction with them has to be human-driven.
</p>
<p>
  Gentner &amp; Nielsen sum up the tradeoff very well in
  <em>The Anti-Mac Interface</em> <sup><a href="#Gentner-Nielsen" title="[Gentner-Nielsen]">[Gentner-Nielsen]</a></sup>: “[Visual interfaces] work well for
simple actions with a small number of objects, but as the number of
actions or objects increases, direct manipulation quickly becomes
repetitive drudgery.  The dark side of a direct manipulation interface
is that you have to manipulate everything. Instead of an executive who
gives high-level instructions, the user is reduced to an assembly-line
worker who must carry out the same task over and over”. Noted
science-fiction writer Neal Stephenson made the same point, less
directly but more entertainingly, in his brilliant and discursive
essay
  <em>In the Beginning Was the Command Line</em> <sup><a href="#Stephenson" title="[Stephenson]">[Stephenson]</a></sup>.
</p>
<p>
  A typical Unix old hand's take on this problem is rather less
theoretical:
</p>
 <blockquote>
  <p>
   The commercial world generally goes for the novice mode because 
(a) purchase decisions are often made on the basis of 30 seconds trial, 
and (b) it minimizes the demands on customer support to have only a 
dumbed-down GUI.  I find many non-Unix systems very frustrating because,
for example, they will provide no way to do something on a hundred or a
thousand files; I want to write a script, and there's no support for it.  The
basic problem is that they've assumed all users are novices all the
time, and then they bash Unix because it doesn't cater to that model.
  </p>
  <span>
   – Mike Lesk
  </span>
 </blockquote>
<p>
  For the long haul, then — for serving both casual and expert
users, for cooperating with other computer programs, and whether
the problem domain is naturally visual or not — support for
  <em>both</em>
  CLI and visual interfaces is important. Unix's
history positions it well to meet both sets of needs. After
presenting an indicative case study, we will examine the
characteristic design patterns that the Unix tradition has evolved
to meet them.
</p>
<h4 id="id2951734"><a href="#id2951734">§</a>Case Study: Two Ways to Write a Calculator Program</h4>
<p>
  To be more concrete, let us contrast how the GUI and CLI styles
can be usefully applied to the design of a simple interactive program:
a desk calculator. Our examples for contrast are
dc(1)/bc(1)
and
xcalc(1).
</p>
<p>
  The original Unix desk calculator program, first distributed
with Version 7, was
dc(1)—a reverse-Polish-notation calculator that could handle
unlimited-precision arithmetic. Later, an algebraic (infix notation)
calculator language,
bc(1),
was implemented on top of dc (we used the relationship between these
programs as a case study in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>, and again in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>). Both of these programs use a
CLI. You type an expression on standard input, you press enter, and
the value of the expression is printed on standard output.
</p>
<p>
  The
xcalc(1)
program, on the other hand, visually simulates a simple calculator,
with clickable buttons and a calculator-style display.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 11.1. The xcalc GUI.
   </b>
  </p>
  <div class="center">
   <img alt="The xcalc GUI." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOIAAAEwAQAAAACC6pDqAAAAAmJLR0QAAd2KE6QAAAOXSURBVHja7dndatswFADgQC87lttBk/gRugfo8KPsCcZuB62jR9gj9AnGLnNRQpIXaOjF2GCNvXSwsh9bK6V4nS1pOke2JTu1Bv1JPOZcFKEv+rN8dETaEZbPtGPXn53az9aDard2Uv+ecmJTNrFpEjRR7XO2r7eZe7QO/fWq59ZrcpQEFv2YiFvrh317W8eqtlkdJYfW9T7fxHO+rW7qrLuDCsun1ftT3IUtfOpPq8VpJ4YvJQT+jqrFpmjHqqRGOblZCYUqNpFVXFYNe93IGYnLJSpXKnL1QhHSkQh9VEaComdUJhay6AdZz2OaEBbCYF+Ujk0dBgnhp66segeaup6hQ+HKnl1oe4VtOZPFaaZeVRkz2u5z6DkATXDOCZNz9tWc0x0Gs6K5DnvbXK7XXzZnf5ui9kj5v2PwXjXtf6ermu4NHPW2o8aFUlC2CCnqQRiU2ioNwyxSXkhdnp+IER/I7shseWLqG6l+fIxVchDKofijn+nxJCHnsS+rWESkfoJi6L1WGkm9VkoPpfqoY6rVR8Weo1MoLhZztV4qu1vO/HxWF2eymD6Ldpu7RxvSNgbXqumjrnwnCRThr0qYhcosI6tQBSqf2JRl+Yg7hQ4Hu1I9R8YCZSpSGGTYdA/yoIehfEBBZQ4DTbtFW6Ueqsx/2FaP60VurvNcqdFWZMp3s55xVrjeFGNQBqX8Yj4r8wGx/HCCrLmi3MmKssMG7OADaBuDa1a8qeLVktbpRJgp8e+q4ojqO3BiRvdvGIwHVc3acpyKW9HUWdXVcflc5HdRU7Nx00DPqna9zdyjNgYb+6zupPzJYzjQp5jeIEWIpaGMepAMOKY3SC/CN1WgsorywNRE6ym2ddW4jlY17hlGWVfNWY0b67bcaFuj+bhKqVZmrtcZOrmqcT83YBcaqW0MrknTQb94TTFxiQszykK8zF3j+yyqWYOFDKqutAarir/JMKeqaR91geNipJwYmY55WgXqsdnzGHWqtXQyLEJxw8mQa9Tr5rp65jRzjzakbQyuSXlf/+qi3slpKY5Qz6v5KFP2dS6r3lczDsn029viIkird1E57stCgyL289tmaKirxyW56jmLqjJD1clgxiAf7IDO9JnTxmCNtjG4Jk23I7ibXWotRVkCPyyqXHaDskXpFSexeetjfFzRxLhtwr8iSjqLZ7a21DpuYPRcmjOBL05q1svdqpYeEGnKHm1IHy4G76B/APSoD6hAftZyAAAAEnRFWHRjb21tZW50AENhbGN1bGF0b3Lat525AAAAAElFTkSuQmCC"/>
  </div>
 </div>
<p>
  The
xcalc(1)
approach is simpler to describe because it mimics an interface with
which novice users will be familiar; the man page says, in fact,
“The numbered keys, the +/− key, and the +, −, *, /, and = keys
all do exactly what you would expect them to”. All the
capabilities of the program are conveyed by the visible button
labels. This is the Rule of Least Surprise in its strongest form, and
a real advantage for infrequent and novice users who will never have
to read a man page to use the program.
</p>
<p>
  However,
  <em>xcalc</em> also inherits the
almost complete
non-transparency
  of a calculator; when
evaluating a complex expression, you don't get to see and sanity-check
your keystrokes — which can be a problem if, say, you misplace a
decimal point in an expression like (2.51 + 4.6) * 0.3. There's no
history, so you can't check. You'll get a result, but it won't be the
result of the calculation you intended.
</p>
<p>
  With the
dc(1)
and
bc(1)
programs, on the other hand, you can edit mistakes out of the
expression as you build it. Their interface is more transparent,
because you can see the calculation that is being performed at every
stage. It is more expressive because the
  <em>dc</em> /
  <em>bc</em> interpreter, not being limited to what fits on a reasonably-sized
visual mockup of a calculator, can include a much larger repertoire of
functions (and facilities such as if/then/else, stored variables, and
iteration). It also incurs, of course, a higher mnemonic load.
</p>
<p>
  Concision is more of a toss-up; good typists will find the CLI
more concise, while poor ones may find it faster to point and
click. Scriptability is not a toss-up;
  <em>dc</em> /
  <em>bc</em> can easily
be used as a filter, but xcalc can't be scripted at all.
</p>
<p>
  The tradeoff between ease for novices and utility for expert
users is very clear here. For casual use in situations where a
mental-arithmetic error check is not hard,
  <em>xcalc</em> wins. For more complex calculations
where the steps must not only be correct but must be
  <em>seen</em>
  to be correct, or in which they are most
conveniently generated by another program,
  <em>dc</em> /
  <em>bc</em> wins.
</p>



<!-- FILE: ch11s05.html -->
<h3 id="ch11s05"><a href="#ch11s05">§</a>Transparency, Expressiveness, and Configurability</h3>
<p>
  Unix programmers inherit a strong bias toward making interfaces
expressive and configurable.  Like programmers from other traditions,
they think about how to match their interfaces to the target audience
— but they differ in how they deal with uncertainty about
that target audience.  Software developers whose experience is
primarily with client operating systems default toward making
interfaces simple; they are willing to sacrifice expressiveness to
gain ease.  Unix programmers default toward making interfaces
expressive and transparent, and are more willing to sacrifice ease to
get these qualities.
</p>
<p>
  The results of this attitude have often been described as
interfaces written “by programmers, for programmers”.
But this oversimplifies the matter in an important way.  When a Unix
programmer opts for configurability and expressiveness over ease, he
is not necessarily thinking of his audience as consisting solely of
other programmers; rather, he is often acting on a gut-level instinct
that in the absence of knowledge about end-users' intentions it is
best not to patronize or second-guess them.
</p>
 <blockquote>
  <p>
   The downside of this attitude (which is a close cousin to
“mechanism, not policy”) is a tendency to assume that
when the highly configurable and expressive interface is done, the job
is finished... even if the result is almost impossible for anyone else
to use without lengthy study.  The flip side of configurability is an
urgent need for good defaults and an easy way to set everything to the
default.  The flip side of expressivity is a need for guidance — be
it in the program or the documentation — on where to get started
and how to achieve the most commonly-desired results.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  The Rule of Transparency also has an influence.  When a Unix
programmer is writing to meet an RFC or other standard that defines a
set of control options, he tends to assume that his job is to provide
a complete and transparent interface to all of those options; whether
or not he thinks any given one will actually be used is secondary.
His job is mechanism; policy belongs to the user.
</p>
<p>
  This mindset leads to a much stricter attitude about what
constitutes standards conformance, one in which incomplete support is
much less tolerable.  In cases where a Macintosh or Windows developer
would say “We don't need to support that feature of the
standard; most users won't care, and it's too complicated for
them”, a Unix developer is likely to say “We don't know
that nobody will ever want this feature or option, therefore we must
support it”.
</p>
<p>
  These attitudes can lead to clashes when a Unix programmer is
working with others, who are likely to interpret his design choices as
a blithe willingness to burden users with technical details that are
obscure, pointless, and even frightening.  Mac or Windows programmers
fear scaring away the many  to serve the advanced needs of the
few.
</p>
<p>
  The Unix programmer, on the other hand, is likely to see
defaulting away from expressiveness as a sort of cop-out or even
betrayal of future users, who will know their own requirements better
than the present implementer.  Ironically, though the Unix attitude is
often construed as a sort of programmer arrogance, it is actually a
form of humility — one often acquired along with years of battle
scars.
</p>
<p>
  The extent to which the Unix attitude is appropriate varies.
Whichever side of this divide you the reader are on, it is wise to
learn to listen to the other, and wise to understand the premises
behind the opposing point of view.  Rather than falling into the trap
of either intimidating users or condescending to them, it may be
possible to build transparent interfaces in which the advanced
features are present but inconspicuous.  The
  <em>audacity</em> and
  <em>kmail</em> case studies in
  <a href="#transparencychapter" title="Chapter 6. Transparency">
   Chapter 6</a>
  are good examples to follow.
</p>
<p>
  Finally, a note about user-interface design for nontechnical
end-users.  This is a demanding art, and Unix programmers don't have a
tradition of being very good at it.  But with the ideas we've
developed from examining the Unix tradition, it is possible to make
one strong and useful statement about it.  That is: when people say a
user interface is
  <em>intuitive</em>, what they mean is
that it (a) is discoverable, (b) is transparent in use, and (c) obeys
the Rule of Least Surprise.<sup><a href="#ftn.id2957556" id="id2957556">[107]</a></sup>
  Of these three rules, Least
Surprise is the least binding; initial surprises can be coped with 
if discoverability and transparency make longer-term use rewarding.
</p>
<p>
  The user interfaces of today's cellphones (for example) have
relatively high mnemonic load in that you have to maintain at least a
rough mental map of the interface menus to use them rapidly without
constantly having to spend attention on checking where you are in the
hierarchy.  But the better-designed ones rapidly become
‘intuitive‘ for their users anyway, because they have
these three qualities.
</p>
<p>
  Intuitiveness is not quite the same quality as ease, because (as
the cellphone example shows) people can develop what they think of as
‘intuitions‘ about transparent interfaces that have fairly
high mnemonic load, as long as simple operations are easy and there is
a discovery path that allows them to assimilate the interface's more
difficult corners one step at a time.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2957556" id="ftn.id2957556">[107]</a></sup>
  This insight comes to us
from a nontechnical end-user who just happens to be the author's wife
Catherine Raymond.
</p>
</div>


<!-- FILE: ch11s06.html -->
<h3 id="ch11s06"><a href="#ch11s06">§</a>Unix Interface Design Patterns</h3>
<p>
  In the Unix tradition, the tradeoffs we described above are met
by well-established interface design patterns. Here is a bestiary
of these patterns, with analyses and examples. We'll follow it with
a discussion of how to apply them.
</p>
<p>
  Note that this bestiary does not include GUI design patterns
(though it includes a design pattern that can use a GUI as a
component). There are no design patterns in graphical user interfaces
themselves that are specifically native to Unix. A promising beginning
of a discussion of GUI design patterns in general can be found at
  <em>Experiences — A Pattern Language for User Interface Design</em><sup><a href="#Coram-Lee" title="[Coram-Lee]">[Coram-Lee]</a></sup>.
</p>
<p>
  Also note that programs may have modes that fit more than one
interface pattern. A program that has a compiler-like interface,
for example, may behave as a filter when no file arguments are
specified on the command line (many format converters behave like
this).
</p>
<h4 id="id2957637"><a href="#id2957637">§</a>The Filter Pattern</h4>
<p>
  The interface-design pattern most classically associated with
Unix is the
  <em>filter</em>. A filter program takes data on
standard input, transforms it in some fashion, and sends the result
to standard output. Filters are not interactive; they may query
their startup environment, and are typically controlled by
command-line options, but they do not require feedback or commands
from the user in their input stream.
</p>
<p>
  Two classic examples of filters are
tr(1)
and
grep(1). The
tr(1)
program is a utility that translates data on standard input to
results on standard output using a translation specification given on
the command line. The
grep(1)
program selects lines from standard input according to a match
expression specified on the command line; the resulting selected lines
go to standard output. A third is the
sort(1)
utility, which sorts lines in input according to criteria specified on
the command line and issues the sorted result to standard
output.
</p>
<p>
  Both
grep(1)
and
sort(1)
(but not
tr(1))
can alternatively take data input from a file (or files) named on the
command line, in which case they do not read standard input but act
instead as though that input were the catenation of the named files
read in the order they appear. (In this case it is also expected that
specifying “-” as a filename on the command line will
direct the program explicitly to read from standard input.) The
archetype of such ‘catlike’ filters is
cat(1),
and filters are expected to behave this way unless there are
application-specific reasons to treat files named on the command line
differently.
</p>
<p>
  When designing filters, it is well to bear in mind some
additional rules, partly developed in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>
  :
</p>
 <div class="orderedlist">
  <ol type="1">
   <li>
    <p>
     <em>
      Remember Postel's Prescription: Be generous in what
you accept, rigorous in what you emit.
</em>
     That is, try to
accept as loose and sloppy an input format as you can and emit as
well-structured and tight an output format as you can.  Doing the
former reduces the odds that the filter will be brittle in the face of
unexpected inputs, and break in someone's hand (or in the middle of
someone's toolchain).  Doing the latter increases the odds that your
filter will someday be useful as an input to other programs.
    </p>
   </li>
   <li>
    <p>
     <em>
      When filtering, never throw away information you don't
need to.
</em>
     This, too, increases the odds that your filter
will someday be useful as an input to other programs. Information you
discard is information that no later stage in a pipeline can
use.
    </p>
   </li>
   <li>
    <p>
     <em>When filtering, never add noise.</em>
     Avoid
adding nonessential information, and avoid reformatting in ways that
might make the output more difficult for downstream programs to parse.
The most common offenders are cosmetic touches like headers, footers,
blank/ruler lines, summaries and conversions like adding aligned
columns, or writing a factor of "1.5" as "150%".  Times and dates are
a particular bother because they're hard for downstream programs to
parse. Any such additions should be optional and controlled by
switches.  If your program emits dates, it's good practice to have a
switch that can force them into ISO8601 YYYY-MM-DD and hh:mm:ss
formats — or, better yet, use those by default.
    </p>
   </li>
  </ol>
 </div>
<p>
  The term “filter” for this pattern is
long-established Unix jargon.
</p>
 <blockquote>
  <p>
   “Filter” is indeed long-established.  It came into
use on day one of pipes.  The term was a natural transferral from
electrical-engineering usage: data flowed from source through filters
to sink.  Source or sink could be either process or file.  The
collective EE term, “circuit”, was never considered,
since the plumbing metaphor for data flow was already well
established.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  Some programs have interface design patterns like the filter,
but even simpler (and, importantly, even easier to script). They
are cantrips, sources, and sinks.
</p>
<h4 id="id2957916"><a href="#id2957916">§</a>The Cantrip Pattern</h4>
<p>
  The cantrip interface design pattern is the simplest of all. No
input, no output, just an invocation and a numeric exit status. A cantrip's
behavior is controlled only by startup conditions. Programs don't
get any more scriptable than this.
</p>
<p>
  Thus, the cantrip design pattern is an excellent default when
the program doesn't require any runtime interaction with the user
other than fairly simple setup of initial conditions or control
information.
</p>
<p>
  Indeed, because scriptability is important, Unix designers learn
to resist the temptation to write more interactive programs when
cantrips will do. A collection of cantrips can always be driven from
an interactive wrapper or shell program, but interactive programs are harder
to script. Good style therefore demands that you try to find a cantrip
design for your tool before giving in to the temptation to write an
interactive interface that will be harder to script. And when
interactivity seems necessary, remember the characteristic Unix design
pattern of separating the engine from the interface; often, the right
thing is an interactive wrapper written in some scripting
language
  that calls a cantrip to do the real work.
</p>
<p>
  The console utility
clear(1),
which simply clears your screen, is the purest possible cantrip; it
doesn't even take command-line options. Other classic simple examples
are
rm(1)
and
touch(1).
The
startx(1)
program used to launch X is a complex example, typical of a whole
class of daemon-summoning cantrips.
</p>
<p>
  This interface design pattern, though fairly common, has not
traditionally been named; the term “cantrip” is my
invention. (In origin, it's a Scots-dialect word for a magic spell,
which has been picked up by a popular fantasy-role-playing game to tag
a spell that can be cast instantly, with minimal or no
preparation.)
</p>
<h4 id="id2958032"><a href="#id2958032">§</a>The Source Pattern</h4>
<p>
  A
  <em>source</em>
  is a filter-like program that
requires no input; its output is controlled only by startup
conditions. The paradigmatic example would be
ls(1),
the Unix directory lister.  Other classic examples include
who(1)
and
ps(1).
</p>
<p>
  Under Unix, report generators like
ls(1),
ps(1),
and
who(1)
tend strongly to obey the source pattern, so their output can be
filtered with standard tools.
</p>
<p>
  The term ‘source’ is, as Doug McIlroy noted, very
traditional. It is less common than it might be because
‘source’ has other important meanings.
</p>
<h4 id="id2958116"><a href="#id2958116">§</a>The Sink Pattern</h4>
<p>
  A
  <em>sink</em>
  is a filter-like program that
consumes standard input but emits nothing to standard output. Again,
its actions on the input data are controlled only by startup
conditions.
</p>
<p>
  This interface pattern is unusual, and there are few well-known
examples. One is
lpr(1),
the Unix print spooler. It will queue text passed to it on standard
input for printing. Like many sink programs, it will also process
files named to it on the command line.  Another example is
mail(1)
in its mail-sending mode.
</p>
<p>
  Many programs that might appear at first glance to be sinks take
control information as well as data on standard input and are actually
instances of something like the
  <em>ed</em> pattern
(see below).
</p>
<p>
  The term
  <em>sponge</em> is sometimes applied
specifically to sink programs like
sort(1)
that must read their entire input before they can process any of
it.
</p>
<p>
  The term ‘sink’ is traditional and common.
</p>
<h4 id="id2958199"><a href="#id2958199">§</a>The Compiler Pattern</h4>
<p>
  Compiler-like programs use neither standard output nor standard
input; they may issue error messages to standard error, however.
Instead, a compiler-like program takes file or resource names from
the command line, transforms the names of those resources in some
way, and emits output under the transformed names. Like cantrips,
compiler-like programs do not require user interaction after
startup time.
</p>
<p>
  This pattern is so named because its paradigm is the
C
  compiler,
cc(1)
(or, under Linux
  and many other modern Unixes,
gcc(1)). But
it is also widely used for programs that do (for example) graphics
file conversions or compression/decompression.
</p>
<p>
  A good example of the former is the
gif2png(1)
program used to convert GIF (Graphic Interchange Format) to PNG
(Portable Network
Graphics).<sup><a href="#ftn.id2958281" id="id2958281">[108]</a></sup>
  Good examples of the latter are
the
gzip(1)
and
gunzip(1)
GNU compression utilities, almost certainly shipped with your Unix
system.
</p>
<p>
  In general, the compiler interface design pattern is a good
model when your program often needs to operate on multiple named
resources and can be written to have low interactivity (with its
control information supplied at startup time). Compiler-like
programs are readily scriptable.
</p>
<p>
  The term “compiler-like interface” for this pattern
is well-understood in the Unix community.
</p>
<h4 id="id2958336"><a href="#id2958336">§</a>The ed pattern</h4>
<p>
  All the previous patterns have very low interactivity; they use
only control information passed in at startup time, and separate
from the data. Many programs, of course, need to be driven by a
continuing dialog with the user after startup time.
</p>
<p>
  In the Unix tradition, the simplest interactive design pattern
is exemplified by
ed(1),
the Unix line editor. Other classic examples of this pattern include
ftp(1)
and
sh(1),
the Unix shell.  The
ed(1)
program takes a filename argument; it modifies that file.  On its
input, it accepts command lines. Some of the commands result in output
to standard output, which is intended to be seen immediately by the
user as part of the dialog with the program.
</p>
<p>
  An actual sample
ed(1)
session will be included in
  <a href="#complexitychapter" title="Chapter 13. Complexity">
   Chapter 13</a>.
</p>
<p>
  Many browserlike and editorlike programs under Unix obey this
pattern, even when the named resource they edit is something other
than a text file. Consider
gdb(1),
the GNU symbolic debugger, as an example.
</p>
<p>
  Programs obeying the
  <em>ed</em> interface
design pattern are not quite so scriptable as would be the simpler
interface types resembling filters. You can feed them commands on
standard input, but it is trickier to generate sequences of commands
(and interpret any output they might ship back) than it is to just set
environment variables and command-line options.  If the action of the
commands is not so predictable that they can be run blind (e.g., with a
here-document as input and ignoring output), driving
  <em>ed</em> -like programs requires a protocol, and a
corresponding state machine in the calling process.  This raises the
problems we noted in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  during the discussion of slave process
control.
</p>
<p>
  Nevertheless, this is the simplest and most scriptable
pattern that supports fully interactive programs. Accordingly, it
is still quite useful as a component of the “separated engine and
interface” pattern we'll describe below.
</p>
<h4 id="id2958491"><a href="#id2958491">§</a>The Roguelike Pattern</h4>
<p>
  The roguelike pattern is so named because its first example was the dungeon-crawling game rogue(1) (see Figure 11.2)
  under BSD; the adjective “roguelike” for this pattern is widely recognized in Unix tradition. Roguelike programs are
  designed to be run on a system console, an X terminal emulator, or a video display terminal. They use the full screen
  and support a visual interface style, but with character-cell display rather than graphics and a mouse.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 11.2. Screen shot of the original Rogue game.
   </b>
  </p>
  <pre class="screen">
                                                a) some food
                                                b) +1 ring mail [4] being worn
-----------------------              ########## c) a +1,+2 mace in hand 
|                     +###############          d) a +1,+0 short bow
|                     |                         e) 28 +0,+0 arrows
---------------+-------                         f) a short bow
               #                                i) a magnesium wand
               #                                g) a magnesium wand
             ###               ---------------- j) a potion of detect things
     --------+----------       |                l) a scroll of teleportation
     |                 |      #+                --press space to continue--
     |                 |      #|                 |             #
     |                 +#######|                 |            ##
     |                 |       |                 +##############
     --------+----------       -------------------             #
        ######                                                 #
  ------+----------                                            ######
  |...........@..!|                                                 #
  |...........%...|                 ----------------                #
  |...............|                #+              |          #######
  |...............+#################|              |          #
  |...............|                 |              +###########
  -----------------                 ----------------
Level: 3  Gold: 73     Hp: 36(36)   Str: 14(16) Arm: 4  Exp: 4/78
</pre>
 </div>
<p>
  Commands are typically single keystrokes not echoed to the user
(as opposed to the command lines of the
  <em>ed</em> pattern), though some will open a command window (often, though not
always, the last line of the screen) on which more elaborate
invocations can be typed.  The command architecture often makes heavy
use of the arrow keys to select screen locations or lines on which to
operate.
</p>
<p>
  Programs written in this pattern tend to model themselves on either
vi(1)
  or
emacs(1)
and (obeying the Rule of Least Surprise) use their command sequences
for common operations such as getting help or terminating the
program. Thus, for example, one can expect one of the commands
‘x’, ‘q’, or ‘C-x C-c’ to
terminate a program written to this pattern.
</p>
<p>
  Some other interface tropes associated with this pattern
include: (a) the use of one-item-per-line menus, with the
currently-selected item indicated by bold or reverse-video
highlighting, and (b) ‘mode lines’ — program status
summaries carried on a highlighted screen line, often near the bottom
or at the top of the screen.
</p>
<p>
  The roguelike pattern evolved in a world of video display
terminals; many of these didn't have arrow or function keys.  In a
world of graphics-capable personal computers, with character-cell
terminals a fading memory, it's easy to forget what an influence this
pattern exerted on design; but the early exemplars of the roguelike
pattern were designed a few years before IBM standardized the PC
keyboard in 1981.  As a result, a traditional but now archaic part of
the roguelike pattern is the use of the h, j, k, and l as cursor keys
whenever they are not being interpreted as self-inserting characters
in an edit window; invariably k is up, j is down, h is left, and l is
right.  This history also explains why older Unix programs tend not to
use the ALT keys and to use function keys in a limited way if at
all.
</p>
<p>
  Programs obeying this pattern are legion: The
vi(1)
text editor in all its variants, and the
emacs(1)
editor;
elm(1),
pine(1),
mutt(1), and most other Unix mail readers;
tin(1),
slrn(1),
and other Usenet
  newsreaders; the
lynx(1)
Web browser; and many others.  Most Unix programmers spend most of
their time driving programs with interfaces like these.
</p>
<p>
  The roguelike pattern is hard to script; indeed scripting it is
seldom even attempted. Among other things, this pattern uses raw-mode
character-by-character input, which is inconvenient for scripting.
It's also quite hard to interpret the output programmatically, because
it usually consists of sequences of incremental screen-painting
actions.
</p>
<p>
  Nor does this pattern have the visual slickness of a mouse-driven
full GUI. While the point of using the full screen interface is to
support simple kinds of direct-manipulation and menu interfaces,
roguelike programs still require users to learn a command
repertoire. Indeed, interfaces built on the roguelike pattern show a
tendency to degenerate into a sort of cluttered wilderness of modes
and meta-shift-cokebottle commands that only hard-core
hackers
  can love. It
would seem that this pattern has the worst of both worlds, being
neither scriptable nor conforming to recent fashions in design for
end-users.
</p>
<p>
  But there must be some value in this pattern. Roguelike mailers,
newsreaders, editors, and other programs remain extremely popular even
among people who invariably run them through terminal emulators on an
X display that supports GUI competitors. Moreover, the roguelike
pattern is so pervasive that under Unix even GUI programs often
emulate it, adding mouse and graphics support to a command and display
interface that still looks rather roguelike.  The X mode of
emacs(1),
and the
xchat(1)
client are good examples of such adaptation. What accounts for the
pattern's continuing popularity?
</p>
<p>
  Efficiency, and perceived efficiency, seem to be important
factors. Roguelike programs tend to be fast and lightweight
relative to their nearest GUI competitors. For startup and runtime
speed, running a roguelike program in an Xterm may be preferable to
invoking a GUI that will chew up substantial resources setting up
its displays and respond more slowly afterwards. Also, programs
with a roguelike design pattern can be used over telnet links or
low-speed dialup lines for which X is not an option.
</p>
<p>
  Touch-typists often prefer roguelike programs because they can
avoid taking their hands off the keyboard to move a mouse.  Given a
choice, touch-typists will prefer interfaces that minimize keystrokes
far off the home row; this may account for a significant percentage of
vi(1)'s
popularity.
</p>
<p>
  Perhaps more importantly, roguelike interfaces are predictable
and sparing in their use of screen real estate on an X display;
they do not clutter the display with multiple windows, frame
widgets, dialog boxes, or other GUI impedimenta. This makes the
pattern well suited for use in programs that must frequently share
the user's attention with other programs (as is especially the case
with editors, mailers, newsreaders, chat clients, and other
communication programs).
</p>
<p>
  Finally (and probably most importantly) the roguelike pattern
tends to appeal more than GUIs to people who value the concision and
expressiveness of a command set enough to tolerate the added mnemonic
load. We saw above that there are good reasons for this preference to
become more common as task complexity, use frequency, and user
experience rise. The roguelike pattern meets this preference while
also supporting GUI-like elements of direct manipulation as an
  <em>ed</em> -pattern program cannot. Thus, far from
having only the worst of both worlds, the roguelike interface design
pattern can capture some of the best.
</p>
<h4 id="id2958899"><a href="#id2958899">§</a>The ‘Separated Engine and Interface’ Pattern</h4>
<p>
  In
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  we
argued against building monster single-process monoliths, and that it
is often possible to lower the global complexity of programs by
splitting them into communicating pieces.  In the Unix world, this
tactic is frequently applied by separating the ‘engine’
part of the program (core algorithms and logic specific to its
application domain) from the ‘interface’ part (which
accepts user commands, displays results, and may provide services such
as interactive help or command history).  In fact, this
separated-engine-and-interface pattern is probably the one most
characteristic interface design pattern of Unix.
</p>
<p>
  (The other, more obvious candidate for that distinction would be
filters.  But filters are more often found in non-Unix environments
than engine/interface pairs with bidirectional traffic between them.
Simulating pipelines is easy; the more sophisticated IPC mechanisms 
required for engine/interface pairs are hard.)
</p>
<p>
  Owen Taylor, maintainer of the GTK+ library widely used for writing user interfaces under X, beautifully brings out
  the engineering benefits of this kind of partitioning at the end of his note <a href="http://www.gtk.org/setuid.html">
  Why GTK_MODULES is not a security hole</a>; he finishes by writing "[T]he secure setuid program is a 500 line program
  that does only what it needs to, rather than a 500,000 line library whose essential task is user interfaces".
</p>
<p>
  This is not a new idea. Xerox PARC's
  early research into graphical user
interfaces led them to propose the
“model-view-controller”
  pattern as an archetype for
GUIs.
</p>
 <div>
  <ul>
   <li>
    <p>
     The “model” is what in the Unix world is usually
called an “engine”.  The model contains the
domain-specific data structures and logic for your application.
Database servers are archetypal examples of models.
    </p>
   </li>
   <li>
    <p>
     The “view” part is what renders your domain objects
into a visible form.  In a really well-separated model/view/controller
application, the view component is notified of updates to the model
and responds on its own, rather than being driven synchronously by
the controller or by explicit requests for a refresh.
    </p>
   </li>
   <li>
    <p>
     The “controller” processes user requests and passes
them as commands to the model.
    </p>
   </li>
  </ul>
 </div>
<p>
  In practice, the view and controller parts tend to be more
closely bound together than either is to the model.  Most GUIs, for
example, combine view and controller behavior.  They tend to be
separated only when the application demands multiple views of the
model.
</p>
<p>
  Under Unix, application of the model/view/controller pattern is
far more common than elsewhere precisely because there is a strong
“do one thing well” tradition, and IPC methods are both
easy and flexible.
</p>
<p>
  An especially powerful form of this technique couples a policy
interface (often a GUI combining view and controller functions) with
an engine (model) that contains an interpreter for a domain-specific
minilanguage.  We examined this pattern in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>, focusing on minilanguage design; now
it's time to look at the different ways that such engines can form
components of larger systems of code.
</p>
<p>
  There are several major variants of this pattern.
</p>
<h5 id="id2959084"><a href="#id2959084">§</a>Configurator/Actor Pair</h5>
<p>
  In a configurator/actor pair, the interface part controls the
startup environment of a filter or daemon-like program which then runs
without requiring user commands.
</p>
<p>
  The programs
fetchmail(1)
  and
fetchmailconf(1)
(which we've already used as case studies in
discoverability
  and data-driven programming and will encounter again as language case
studies in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>) are
a good example of a configurator/actor pair.
  <em>fetchmailconf</em> is the interactive dotfile
configurator that ships with
fetchmail.
  <em>fetchmailconf</em> can also serve as a GUI
wrapper that runs fetchmail in either foreground or background
mode.
</p>
<p>
  This design pattern enables both
  <em>fetchmail</em> and
  <em>fetchmailconf</em> to specialize in what they do
well, and indeed to be written in different languages appropriate to
their task domains. Fetchmail, which usually runs in background as a
daemon, need not be bloated with GUI code. Conversely,
  <em>fetchmailconf</em> can specialize in elaborate
GUIness without exacting size and complexity costs from
fetchmail. Finally, because the information channels between them are
narrow and well-defined, it remains possible to drive
  <em>fetchmail</em> from the command line and from
scripts other than
  <em>fetchmailconf</em>.
</p>
<p>
  The term “configurator/actor” is my invention.
</p>
<h5 id="id2959228"><a href="#id2959228">§</a>Spooler/Daemon Pair</h5>
<p>
  A slight variant of the configurator/actor pair can be useful in
situations that require serialized access to a shared resource in a
batch mode; that is, when a well-defined job stream or sequence
of requests requires some shared resource, but no individual
job requires user interaction.
</p>
<p>
  In this spooler/daemon pattern, the spooler or front end simply
drops job requests and data in a spool area. The job requests and data
are simply files; the spool area is typically just a directory. The
location of the directory and the format of the job requests are agreed
on by the spooler and daemon.
</p>
<p>
  The daemon runs forever in background, polling the spool
directory, looking there for work to do. When it finds a job request,
it tries to process the associated data. If it succeeds, the job
request and data are deleted out of the spool area.
</p>
<p>
  The classic example of this pattern is the Unix print spooler
system,
lpr(1)/lpd(1). The
front end is
lpr(1);
it simply drops files to be printed in a spool area periodically
scanned by
  <em>lpd</em>.
  <em>lpd</em> 's job
is simply to serialize access to the printer devices.
</p>
<p>
  Another classic example is the pair
at(1)/atd(1),
which schedules commands for execution at specified times. A
third example, historically important though no longer in wide use,
was UUCP — the Unix-to-Unix Copy Program commonly used as a mail
transport over dial-up lines before the Internet explosion of the
early 1990s.
</p>
<p>
  The spooler/daemon pattern remains important in mail-transport
programs (which are batchy by nature). The front ends of mail
transports such as
sendmail(1)
and
qmail(1)
usually make one try at delivering mail immediately, through SMTP over an
outbound Internet connection. If that attempt fails, the mail will
fall into a spool area; a daemon version or mode of the mail transport
will retry the delivery later.
</p>
<p>
  Typically, a spooler/daemon system has four parts: a job
launcher, a queue lister, a job-cancellation utility, and a
spooling daemon, In fact, the presence of the first three parts is
a sure clue that there is a spooler daemon behind them
somewhere.
</p>
<p>
  The terms “spooler” and “daemon” are
well-established Unix jargon. (‘Spooler’ actually
dates back to early mainframe days.)
</p>
<h5 id="id2959389"><a href="#id2959389">§</a>Driver/Engine Pair</h5>
<p>
  In this pattern, unlike a configurator/actor or spooler/server
pair, the interface part supplies commands to and interprets output
from an engine after startup; the engine has a simpler interface
pattern. The IPC method used is an implementation detail; the engine
may be a slave process of the driver (in the sense we discussed in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>) or the
engine and driver may communicate through sockets, or shared memory,
or any other IPC method. The key points are (a) the interactivity of
the pair, and (b) the ability of the engine to run standalone with its
own interface.
</p>
<p>
  Such pairs are trickier to write than configurator/actor pairs
because they are more tightly and intricately coupled; the driver
must have knowledge not merely about the engine's expected startup
environment but about its command set and response formats as well.
</p>
<p>
  When the engine has been designed for scriptability, however, it
is not uncommon for the driver part to be written by someone other
than the engine author, or for more than one driver to front-end a
given engine. An excellent example of both is provided by the programs
gv(1)
and
ghostview(1),
which are drivers for
gs(1),
the Ghostscript interpreter. GhostScript renders PostScript to various
graphics formats and lower-level printer-control languages. The gv and
ghostview programs provide GUI wrappers for GhostScript's rather
idiosyncratic invocation switches and command syntax.
</p>
<p>
  Another excellent example of this pattern is the
  <em>xcdroast</em> /
  <em>cdrtools</em> combination.  The cdrtools distribution provides a program
cdrecord(1)
with a command-line interface.  The
  <em>cdrecord</em> code specializes in knowing
everything about talking to CD-ROM hardware.
  <em>xcdroast</em> is a GUI; it specializes in
providing a pleasant user experience.  The
xcdroast(1)
  program calls
cdrecord(1)
to do most of its work.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 11.3. The Xcdroast GUI.
   </b>
  </p>
  <div class="center">
   <img alt="The Xcdroast GUI." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  <em>xcdroast</em> also calls other CLI tools:
cdda2wav(1)
(a sound file converter) and
mkisofs(1)
(a tool for creating ISO-9660 CD-ROM file system images from a list of
files).  The details of how these tools are invoked are hidden from
the user, who can think in terms centered on the task of making CDs
rather than having to know directly about the arcana of sound-file
conversion or file-system structure.  Equally important, the
implementers of each of these tools can concentrate on their
domain-specific expertise without having to be user-interface
experts.
</p>
 <blockquote>
  <p>
   A key pitfall of driver/engine organization is that frequently
the driver must understand the state of the engine in order to reflect
it to the user.  If the engine action is practically instantaneous,
it's not a problem, but if the engine can take a long time (e.g., when
accessing many URLs) the lack of feedback can be a significant issue.
A similar problem is responding to errors.  For example, the
traditional (although not very Unix-like) confirmation question about
whether it's OK to overwrite a file that already exists is kind of
painful to write in the driver/engine world; the engine, which detects
the problem, has to ask the driver to do the confirmation prompting.
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>
<p>
  It's important to design the engine so that it not only does the
right thing, but also notifies the driver about what it's doing so
the driver can present a graceful interface with appropriate feedback.
</p>
<p>
  The terms “driver” and “engine” are
uncommon but established in the Unix community.
</p>
<h5 id="id2959688"><a href="#id2959688">§</a>Client/Server Pair</h5>
<p>
  A client/server pair is like a driver/engine pair, except that
the engine part is a daemon running in background which is not
expected to be run interactively, and does not have its own user
interface. Usually, the daemon is designed to mediate access to
some sort of shared resource — a database, or a transaction
stream, or specialized shared hardware such as a sound device.
Another reason for such a daemon may be to avoid performing 
expensive startup actions each time the program is invoked.
</p>
<p>
  Yesterday's paradigmatic example was the
ftp(1)/ftpd(1)
pair that implements FTP, the File Transfer Protocol; or perhaps two
instances of
sendmail(1),
sender in foreground and listener in background, passing Internet
email. Today's would have to be any browser/web server pair.
</p>
<p>
  However, this pattern is not limited to communication programs;
another important case is in databases, such as the
psql(1)/postmaster(1)
pair. In this one,
  <em>psql</em> serializes access
to a shared database managed by the postgres daemon, passing it SQL
requests and presenting data sent back as responses.
</p>
<p>
  These examples illustrate an important property of such pairs,
which is that the cleanliness of the protocol that serializes
communication between them is all-important. If it is well-defined
and described by an open standard, it can become a tremendous
opportunity for leverage by insulating client programs from the
details of how the server's resource is managed, and allowing
clients and servers to evolve semi-independently. All
separated-engine-and-interface programs potentially get this kind
of benefit from clean separation of function, but in the
client/server case the payoffs for getting it right tend to be
particularly high exactly because managing shared resources is
intrinsically difficult.
</p>
<p>
  Message queues and pairs of named
pipes
  can be and have
been used for front-end/back-end communication, but the benefits of
being able to run the server on a different machine from the client
are so great that nowadays almost all modern client-server pairs use
TCP/IP
  sockets.
</p>
<h4 id="id2959821"><a href="#id2959821">§</a>The CLI Server Pattern</h4>
<p>
  It's normal in the Unix world for server processes to be invoked
by harness programs<sup><a href="#ftn.id2959831" id="id2959831">[109]</a></sup>
  such as
inetd(8)
in such a way that the server sees commands on standard input and
ships responses to standard output; the harness program then takes
care of ensuring that the server's stdin and stdout are connected to a
specified TCP/IP
  service port.  One benefit of this division of labor is that the
harness program can act as a single security gatekeeper for all of the
servers it launches.
</p>
<p>
  One of the classic interface patterns is therefore a CLI server.
This is a program which, when invoked in a foreground mode, has a
simple CLI interface reading from standard input and writing to
standard output.  When backgrounded, the server detects this and
connects its standard input and standard output to a specified
TCP/IP
  service
port.
</p>
<p>
  In some variants of this pattern, the server backgrounds itself
by default, and has to be told with a command-line switch when it
should stay in foreground.  This is a detail; the essential point is
that most of the code neither knows nor cares whether it is running in
foreground or a TCP/IP
  harness.
</p>
<p>
  POP, IMAP, SMTP, and HTTP servers normally obey this pattern.
It can be combined with any of the server/client patterns described
earlier in this chapter.  An HTTP server can also act as a harness
program; the CGI scripts that supply most live content on the Web run
in a special environment provided by the server where they can take
input (form arguments) from standard input, and write the generated
HTML that is their result to standard output.
</p>
<p>
  Though this pattern is quite traditional, the term “CLI
server” is my invention.
</p>
<h4 id="id2959928"><a href="#id2959928">§</a>Language-Based Interface Patterns</h4>
<p>
  In
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>
  we
examined domain-specific minilanguages as a means of pushing program
specification up a level, gaining flexibility, and minimizing bugs.
These virtues make the language-based CLI an important style of Unix
interface — one exemplified by the Unix shell itself.
</p>
<p>
  The strengths of this pattern are well illustrated by the case
study earlier in the chapter comparing
dc(1)/bc(1)
with
xcalc(1).
The advantages that we observed earlier (the gain in expressiveness
and scriptability) are typical of minilanguages; they generalize to
other situations in which you routinely have to sequence complex
operations in a specialized problem domain. Often, unlike the
calculator case, minilanguages also have a clear advantage in
concision.
</p>
<p>
  One of the most potent Unix design patterns is the combination
of a GUI front end with a CLI minilanguage back end.  Well-designed
examples of this type are necessarily rather complex, but often a
great deal simpler and more flexible than the amount of ad-hoc code
that would be necessary to cover even a fraction of what the
minilanguage can do.
</p>
<p>
  This general pattern is not, of course, unique to Unix. Modern
database suites everywhere normally consist of one or more GUI
front ends and report generators, all of which talk to a common
back-end using a query language such as SQL. But this pattern
mainly evolved under Unix and is still much better understood and
more widely applied there than elsewhere.
</p>
<p>
  When the front and back ends of a system fulfilling this design
pattern are combined in a single program, that program is often said
to have an ‘embedded scripting
language’.  In the Unix world,
  <em>Emacs</em> is one of the best-known exemplars of
this pattern; refer to our discussion of it in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>
  for some advantages.
</p>
<p>
  The script-fu facility of
GIMP
  is another good
example. GIMP is a powerful open-source graphics editor.  It has a GUI
resembling that of Adobe Photoshop.  Script-fu allows GIMP to be
scripted using Scheme (a dialect of Lisp); scripting through
Tcl, or
Perl
  or
Python
  is
also available.  Programs written in any of these languages can call
GIMP internals through its plugin interface.  The demonstration
application for this facility is a Web page<sup><a href="#ftn.id2960094" id="id2960094">[110]</a></sup>
  which allows people to
construct simple logos and graphic buttons through a CGI interface
that passes a generated Scheme program to an instance of GIMP, and
returns a finished image.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2958281" id="ftn.id2958281">[108]</a></sup>
  Sources for this program, and other converters with
similar interfaces, are available at the
  <a href="http://www.cdrom.com/pub/png/">
   PNG
website</a>.
</p>

<p><sup><a href="#id2959831" id="ftn.id2959831">[109]</a></sup>
  A harness program is a wrapper
whose job it is to make some special sort of resource available to the
program(s) it calls.  The term is most often used for test harnesses,
which make available test loads and (often) examples of correct output
for the actual output to be checked against.
</p>

<p><sup><a href="#id2960094" id="ftn.id2960094">[110]</a></sup>
  <a href="http://www.xcf.berkeley.edu/~gimp/script-fu/script-fu.html">
   Script-Fu
page</a>.
</p>
</div>


<!-- FILE: ch11s07.html -->
<h3 id="ch11s07"><a href="#ch11s07">§</a>Applying Unix Interface-Design Patterns</h3>
<p>
  To facilitate scripting and pipelining (see
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>) it is wise to choose the
simplest interface pattern possible — that is, the pattern with the
fewest channels to the environment and the least
interactivity.
</p>
<p>
  In many of the single-component patterns described above, it is
emphasized that the pattern does not require user interaction after
startup time. When the ‘user’ is often expected to be another
program (and thus to lack the range and flexibility of a human
brain) this is a very valuable feature, maximizing
scriptability.
</p>
<p>
  We've seen that different interface design patterns optimize for
traits valuable in differing circumstances. In particular, there is
a strong and inherent tension between the GUIs and design patterns
appropriate for novice and nontechnical end-users (on the one
hand) and those which serve expert users and maximize scriptability
(on the other).
</p>
<p>
  One way around this dilemma is to make programs with modes that
exhibit more than one pattern. An excellent example is the Web browser
lynx(1). It
normally has a roguelike interface for interactive use, but can be
called with a
  <code>-dump</code> option that makes it into a
source, formatting a specified Web page to text dumped on standard
output.
</p>
<p>
  Such dual-mode interfaces, however, are not normally attempted
when the program has to have a true GUI. The reasons for this are
partly historical, but mostly have to do with controlling global
complexity. GUIs tend to require complex startup configurations and
large volumes of specialized code; these features coexist uneasily
with the simpler patterns. In the worst case, a dual-mode GUI/non-GUI
program could require two separate command-interpreter loops, with
all that implies in the way of code bloat and potential
inconsistencies.
</p>
<p>
  Thus, when “choose the simplest pattern” conflicts
with a requirement to produce a GUI, the Unix way is to split the
program in two, applying the ‘separated engine and
interface’ design pattern.
</p>
<p>
  In fact, by combining a theme from
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  with this idea, we can perhaps name a
new design pattern emerging under Linux
  and other modern, open-source
Unixes where GUIs are not merely a reluctant add-on but an active
focus of lots of development effort.
</p>
<h4 id="id2960228"><a href="#id2960228">§</a>The Polyvalent-Program Pattern</h4>
<p>
  A polyvalent program has the following traits:
</p>
 <div class="orderedlist">
  <ol type="1">
   <li>
    <p>
     The program's application-domain logic lives in a library with a
documented API, which can be linked to other programs.  The program's
interface logic to the rest of the world is a thin layer over the
library.  Or perhaps there are several layers with different UI
styles, any of which the library can be linked to.
    </p>
   </li>
   <li>
    <p>
     One UI mode is a cantrip, compiler-like or CLI pattern that executes its
interactive commands in batch mode.
    </p>
   </li>
   <li>
    <p>
     One UI mode is a GUI, either linked directly to the
core library or acting as as a separate process driving the CLI
interface.
    </p>
   </li>
   <li>
    <p>
     One UI mode is a scripting interface using a modern
general-purpose scripting language like 
Perl,
Python, or
Tcl.
    </p>
   </li>
   <li>
    <p>
     Optional extra: One UI mode is a roguelike interface
using
curses(3).
    </p>
   </li>
  </ol>
 </div>
 <div class="figure">
  <p class="title">
   <b>
    Figure 11.4. Caller/callee relationships in a polyvalent program.
   </b>
  </p>
  <div class="center">
   <img alt="Caller/callee relationships in a polyvalent program." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  Notably, the GIMP
  actually fulfills this pattern.
</p>



<!-- FILE: ch11s08.html -->
<h3 id="ch11s08"><a href="#ch11s08">§</a>The Web Browser as a Universal Front End</h3>
<p>
  Separating your CLI back end from a GUI interface has become an even
more attractive strategy since the transformation of computing by
the World Wide Web in the mid-1990s. For a large class of
applications, it makes increasing sense not to write a custom GUI
front end at all, but rather to press Web browsers into service in
that role.
</p>
<p>
  This approach has many advantages. The most obvious is that you
don't have to write procedural GUI code — instead, you can
describe the GUI you want in languages (HTML and JavaScript) that are
specialized for it. This avoids a lot of expensive and complex
single-purpose coding and often more than halves the total project
effort. Another is that it makes your application instantly
Internet-ready; the front end may be on the same host as the back end,
or may be a thousand miles away. Yet another is that all the minor
presentation details of the application (such as fonts and color) are
no longer your back end's problem, and indeed can be customized by
users to their own tastes through mechanisms like browser preferences
and cascading style sheets. Finally, the uniform elements of the Web
interface substantially ease the user's learning task.
</p>
<p>
  There are disadvantages. The two most important are (a) the
batch style of interaction that the Web enforces, and (b) the
difficulties of managing persistent sessions using a stateless
protocol. Though these are not exclusively Unix issues, we'll discuss
them here — because it's very important to think clearly on the
  <em>design</em>
  level about when it's worthwhile to accept
or work around these constraints.
</p>
<p>
  CGI, the Common Gateway Interface through which a browser can
invoke a program on the server host, does not support fine-grained
interactivity well.  Nor do the templating systems, application
servers, and embedded server scripts that are gradually replacing it
(in a mild abuse of language, we will use CGI for all of these in
this section).
</p>
<p>
  You can't do character-by-character or
GUI-gesture-by-GUI-gesture I/O through a CGI gateway; instead, you
have to fill out an HTML form and click a submit button that sends the
form contents to a CGI script. The CGI script then runs and the server
hands you back a page of HTML that it generated (which may itself be
another CGI form).
</p>
<p>
  This is essentially a batch style of interaction, not that far
removed in concept from dropping punched cards in an input hopper and
getting back a printout. It can be made more palatable by using
JavaScript to interact with the user, batching up transactions into
messages to be shipped to the server.
</p>
<p>
  Java
  applets can open up their own character-stream connections back to the
server to support smoother interactivivity. But Java has technical
problems (it can only use a fixed display area on the page, and can't
change the portion of the display outside that rectangle) and much
worse political ones (proprietary licensing from Sun has stalled Java
deployment and made others reluctant to commit to it; you can't count
on every user's browser to support it).
</p>
<p>
  Both Java
  and JavaScript
  can run into browser incompatibilities,
as well.
Microsoft's
  resistance
to implementing JDK 1.2 and Swing on Internet Explorer is a serious
problem for Java applets, and differing Javascript version levels can
also break your application (though Javascript bugs are easier to
fix).  Nevertheless, it is frequently less effort to work around these
problems than it would be to write and deploy a custom front end.
A problem harder to work around is that a growing number of sophisticated
users routinely disable Java and even JavaScript in their browsers because
of security problems and interface abuses.
</p>
<p>
  As an independent issue, it is tricky to maintain session
information across multiple CGI forms. The server doesn't keep any
state about client sessions between CGI transactions, so you can't
rely on it to connect later form submissions with earlier ones by the
same user. There are two standard dodges around this: chained forms
and browser cookies.
</p>
<p>
  When you chain forms, you arrange for the CGI for the first form
to generate a unique ID in an invisible field of the second form, and
for the second and all subsequent forms to pass that ID to their
successors. Cookies give a similar effect in a less direct way
analogous to environment variables (see any of the hundreds of books
on CGI design for details).  In either case, your CGI has to use the
ID as a session index (or cookies to cache state directly) and to
handle multiplexing the sessions explicitly.
</p>
<p>
  It is often possible to live with these restrictions. Many
nontrivial applications can fit into a single form and response,
evading both problems. Even when this isn't true and the
application requires multiple forms, the complexity and cost
savings from not having to build and distribute a specialized front
end are so large that they can easily pay for the effort required
to write CGIs smart enough to do their own session tracking.
</p>
<p>
  The session management problem can be addressed with application
servers like Zope or Enhydra which provide a session abstraction, and
services like user authentication to programs embedded inside
them. The drawback of these programs is identical to their advantage:
the fact that they make it easier to keep per-user state on the
server.  That per-user state can be a problem; it eats resources, and
it has to be timed out, because between transactions there is no way to
know that the user is still on the other end of the wire.
</p>
<p>
  As usual, the best advice is to choose the simplest pattern
possible.  Resist the temptation to do a heavyweight design relying on
Java or an application server when simple CGIs and cookies will
do the job.
</p>
<p>
  One problem with the browser-as-universal-front-end approach is that 
CGI back ends aren't readily separable from the browser environment, so
it can be hard to script or automate transactions to the back end.
The Unix answer  is a three-tier architecture — Web forms
calling CGIs which call commands.  The automation interface is the
commands.
</p>
<p>
  The way that browsers decouple front and back ends has larger
implications. On the Web, locking in consumers to closed, proprietary
protocols and APIs has become more difficult and less attractive as
this trend has advanced. The economics of software development are
therefore tilting toward HTML, XML, and other open, text-based
Internet standards.  This trend synergizes in interesting ways with
the evolution of the open-source development model, which we'll survey
in
  <a href="#opensourcechapter" title="Chapter 19. Open Source">
   Chapter 19</a>. In the
world that the Web is creating, Unix's design tradition —
including the approaches to interface design we've surveyed in this
chapter — looks more at home than ever before.
</p>



<!-- FILE: ch11s09.html -->
<h3 id="ch11s09"><a href="#ch11s09">§</a>Silence Is Golden</h3>
<p>
  We cannot leave the subject of interactive user interfaces
without exploring one of the oldest and most persistent design tropes
of Unix, the Rule of Silence.  We observed in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>
  that well-designed
Unix programs with nothing interesting or surprising to say should
shut up, and suggested there are good reasons for this that have long
outlasted the slow teletypes on which Unix was born.
</p>
<p>
  Here's one: Programs that babble don't tend to play well with
other programs.  If your CLI program emits status messages to standard
output, then programs that try to interpret that output will be put to
the trouble of interpreting or discarding those messages (even if
nothing went wrong!).  Better to send only real errors to standard
error and not to emit unrequested data at all.
</p>
<p>
  Here's another: The user's vertical screen space is precious.
Every line of junk your program emits is one less line of context
still available on the user's display.
</p>
<p>
  Here's a third: Junk messages are a careless waste of the human
user's bandwidth.  They're one more source of distracting motion on a
screen display that may be mediating for more important foreground
tasks, such as communication with other humans.
</p>
<p>
  Go ahead and give your GUIs progress bars for long operations.
That's good style — it helps the user time-share his brain
efficiently by cuing him that he can go off and read mail or do other
things while waiting for completion.  But don't clutter GUI interfaces
with confirmation popups except when you have to guard operations
that might lose or trash data — and even then, hide them when
the parent window is minimized, and bury them unless the parent window
has focus.<sup><a href="#ftn.id2960697" id="id2960697">[111]</a></sup>
  Your job as an
interface designer is to assist the user, not to gratuitously get in
his face.
</p>
<p>
  In general, it's bad style to tell the user things he already
knows ("Program &lt;foo&gt; is starting up...", or "Program
&lt;foo&gt; is exiting" are two classic offenders).  Your interface
design as a whole should obey the Rule of Least Surprise, but the
content of messages should obey a Rule of
  <em>Most</em>
  Surprise — be chatty only about things that deviate from
what's normally expected.
</p>
<p>
  This rule has even greater force for confirmation prompts.
Constantly asking for confirmation where the answer is almost always
“yes” conditions the user to press “yes” without
thinking about it, a habit that can have very unfortunate
consequences.  Programs should request confirmation only when there is
good reason to suspect that the answer might be “no no
no!”  A confirmation request that is not a surprise is a
strong hint of bad design.  Any confirmation prompts at all may be a
sign that what your interface really needs is an undo command.
</p>
<p>
  If you want chatty progress messages for debugging purposes,
disable them by default with a verbosity switch.  Before releasing for
production, relegate as many of the normal messages as possible to
being displayed only when the verbosity switch is on.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2960697" id="ftn.id2960697">[111]</a></sup>
  If your windowing system supports translucent
popups that intrude less between the user and the application,
  <span class="emphasis">
   <em>use them</em>
  </span>.
</p>
</div>


<!-- FILE: optimizationchapter.html -->
<h3 id="optimizationchapter"><a href="#optimizationchapter">§</a>Chapter 12. Optimization</h3>
 <blockquote class="epigraph">
  <p>
   Premature optimization is the root of all evil.
  </p>
  <span>
   – C. A. R. Hoare
  </span>
 </blockquote>
<p>
  This is going to be a very short chapter, because the main thing
Unix experience teaches us about optimizing for performance is how to
know when not to do it. A secondary lesson is that the most effective
optimization tactics are usually things we do for other reasons, such as
cleanness of design.
</p>



<!-- FILE: ch12s01.html -->
<h3 id="ch12s01"><a href="#ch12s01">§</a>Don't Just Do Something, Stand There!</h3>
<p>
  The most powerful optimization technique in any programmer's
toolbox is to do nothing.
</p>
<p>
  This very Zen advice is true for several reasons.  One is the
exponential effect of Moore's Law — the smartest, cheapest, and
often
  <em>fastest</em>
  way to collect performance gains is
to wait a few months for your target hardware to become more capable.
Given the cost ratio between hardware and programmer time, there are
almost always better things to do with your time than to optimize a
working system.
</p>
<p>
  We can get mathematically specific about this.  It is almost
never worth doing optimizations that reduce resource use by merely a
constant factor; it's smarter to concentrate effort on cases in which
you can reduce average-case running time or space use from
O(
  <em>n</em><sup>
   2</sup>) to
O(
  <em>n</em>) or O(
  <em>n</em>
  log
  <em>n</em>),<sup><a href="#ftn.id2962140" id="id2962140">[112]</a></sup>
  or similarly reduce from a higher
order. Linear performance gains tend to be rapidly swamped by Moore's
Law.<sup><a href="#ftn.id2960862" id="id2960862">[113]</a></sup>
</p>
<p>
  Another very constructive form of doing nothing is to not write
code.  The program can't be slowed down by code that isn't there.  It
can be slowed down by code that
  <em>is</em>
  there but
less efficient than it could be — but that's a different
matter.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2962140" id="ftn.id2962140">[112]</a></sup>
  For readers unfamiliar with O
notation, it is a way of indicating how the average running time of an
algorithm changes with the size of its inputs. An O(1) algorithm runs
in constant time.  An O(
  <span class="emphasis">
   <em>n</em>
  </span>) algorithm runs in a
time that is predicted by
  <code>
   A
   <span class="emphasis">
    <em>n</em>
   </span>
   + C
  </code>, where
  <code>A</code> is some unknown
constant of proportionality and
  <code>C</code> is an
unknown constant representing setup time.  Linear search of a list for
a specified value is O(
  <span class="emphasis">
   <em>n</em>
  </span>).  An
O(
  <span class="emphasis">
   <em>n</em>
  </span><sup>
   2</sup>) algorithm runs
in time
  <code>
   A
   <span class="emphasis">
    <em>n</em>
   </span><sup>
    2</sup>
  </code>
  plus
lower-order terms (which might be linear, or logarithmic, of any other
function lower than a quadratic).  Checking a list for duplicate values
(by the naïve method, not sorting it) is
O(
  <span class="emphasis">
   <em>n</em>
  </span><sup>
   2</sup>).  Similarly,
O(
  <span class="emphasis">
   <em>n</em>
  </span><sup>
   3</sup>) algorithms have
an average run time predicted by the cube of problem size; these tend
to be too slow for practical use.  O(log
  <span class="emphasis">
   <em>n</em>
  </span>) is typical of tree searches.  Intelligent
choice of algorithm can often reduce running time from
O(
  <span class="emphasis">
   <em>n</em>
  </span><sup>
   2</sup>) to
O(log
  <span class="emphasis">
   <em>n</em>
  </span>).  Sometimes when
we are interested in predicting an algorithm's memory utilization, we
may notice that it varies as O(1) or O(
  <span class="emphasis">
   <em>n</em>
  </span>) or
O(
  <span class="emphasis">
   <em>n</em>
  </span><sup>
   2</sup>); in general,
algorithms with O(
  <span class="emphasis">
   <em>n</em>
  </span><sup>
   2</sup>)
or higher memory utilization are not practical
either.
</p>
</div>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2960862" id="ftn.id2960862">[113]</a></sup>
  The eighteen-month doubling time usually quoted for
Moore's Law implies that you can collect a 26% performance gain just
by buying new hardware in six months.
</p>
</div>


<!-- FILE: ch12s02.html -->
<h3 id="ch12s02"><a href="#ch12s02">§</a>Measure before Optimizing</h3>
<p>
  When you have real-world evidence that your application is too
slow, then (and
  <em>only</em>
  then) is the time to think
about optimizing the code.  But before you do more than think about
optimizing, measure.
</p>
<p>
  Recall Rob Pike's six rules in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>.  One of the lessons that the original
Unix programmers learned early is that intuition is a poor guide to
where the bottlenecks are, even for one who knows the code in question
intimately. Unixes, unlike most other operating systems, usually come with
profilers; use them.
</p>
<p>
  Reading profiler results is something of an art.  There are a
couple of recurring problems: one is instrumentation noise, another is
the effect of imposed external latencies, and a third is
overweighting of upper nodes in the call graph.
</p>
<p>
  The instrumentation-noise problem is fundamental.  Profilers
work by inserting instructions that report execution time at the entry
and exit points of subroutines, also at fixed intervals within the inline
code of routines.  These instructions themselves take time to execute.
The effect is to reduce the dispersion of call times: very short
subroutines tend to look more expensive than they are, with a 
lot of noise in their comparative call times, while for longer
ones the instrumentation overhead is invisible.
</p>
<p>
  Bearing instrumentation noise in mind, it's wise to assume
that the times listed for the fastest, shortest subroutines are
going to have a lot of froth and air in them.  They can still be
eating a lot of time if they are called very frequently, however, 
so pay particular attention to their call-count statistics.
</p>
<p>
  The external-latency problem is also fundamental.  There are 
various sorts of delay and distortion that can happen behind the 
profiler's back. The simplest is overhead from operations with
unpredictable latency — disk and network accesses, cache fills,
process-context switches, and the like.  The problem is not so much
that these overheads happen — they may actually be what you're
trying to measure, especially if you're focusing on whole-system
performance rather than just tuning a critical inner loop.  The
problem is that they have a random component that means the
results from any individual profiling run may not be very useful.
</p>
<p>
  One way to minimize the effects of these noise sources, and get a
better picture of where the time is going in the average case, is to
add together the results from a lot of profiling runs.  There are a lot
of good reasons to build test harnesses and test loads for your
programs before you get to optimizing; the most important reason, usually
far more important than performance tuning, is so you can
regression-test your program for correctness as you change it.  Once
you've done this, being able to profile repeated tests under load is a
nice side effect that will often give you better information than
a few runs by hand.
</p>
<p>
  Various effects tend to allocate time spent to calling routines
rather than callees, overweighting upper modes in the call graph.
Function-call overhead, for example, is often charged to the calling
routine (whether or not this is true depends partly on your machine
architecture and where the profiler is allowed to insert probes).
Macros and inline functions, if your compiler supports them, won't
show up in the profiling report at all; every bit of their time gets
charged to the calling function.
</p>
<p>
  More importantly, many time-reporting tools give a display in
which time spent in subroutines is charged to the caller. (The
gprof(1)
profiler distributed with open-source Unixes has this trait.)
Naïvely subtracting callee time from caller time won't give you a
useful result if the same routine can have more than one caller
— the effect would be to artificially deflate both callers'
times. Especially nasty is the common case of a utility function with
multiple call sites, some of which make lots of trivial calls and
others of which make a few complicated ones.
</p>
<p>
  To get more transparent results, factor your code so that
upper-level routines consist as much as possible of calls to
lower-level routines, rather than in-line code.  If you keep
the overhead of upper-level control logic to a minimum, the
call structure of the code will tend to organize the profile report
in a way that is relatively easy to read.
</p>
<p>
  You'll get more insight from using profilers if you think of them less
as ways to collect individual performance numbers, and more as ways to
learn how performance varies as a function of interesting parameters
(e.g., problem size, CPU speed, disc speed, memory size, compiler
optimization, or whatever else is relevant).  Try fitting those
numbers to a model, using open-source software like R or a good-quality
proprietary tool like MATLAB.
</p>
 <blockquote>
  <p>
   The natural smoothing of the data that results from model
fitting tends to focus on the big effects and cover up the small,
noisy ones.  For example, by fitting a cubic to the matrix inversion
routine in MATLAB on random matrices from 10 × 10 to 1000 × 1000, it is
clear that we actually have three cubics, with clearly defined
boundaries, that correspond roughly to “in cache”,
“in memory but out of cache”, and “out of
memory”.  The data shows us this effect even if weren't looking
for it, just by looking at the deviations from the best fit.
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>



<!-- FILE: ch12s03.html -->
<h3 id="ch12s03"><a href="#ch12s03">§</a>Nonlocality Considered Harmful</h3>
<p>
  The most effective way to optimize your code is to keep it
small and simple.  We've been through lots of good reasons to
keep it small and simple earlier in this book.  Here's a new 
one: you want the central data structures and the time-critical loops
in your code never to fall out of cache.
</p>
<p>
  Consider your target machine as a hierarchy of memory types
arranged by distance from the processor.  There are the processor's
own registers; its instruction pipeline; the level-one (L1) cache; the
level-two (L2) cache; possibly a level-three (L3) cache; main memory
(what Unix old hands still quaintly call ‘core’); and the disk
drives where swap space lives.  Technologies like SMP,
shared-memory clusters, and non-uniform memory access (NUMA) add 
more layers to the picture but only widen the overall spread.
</p>
<p>
  Every kind of access to that stack is getting faster. Processor
cycles are almost free, outside of a few demanding applications like
modeling nuclear explosions or real-time video compression.  But
what's also happening is that the speed ratios between layers in the
storage hierarchy are all increasing as processor speeds go up.  Thus,
the relative cost of a cache miss is increasing.
</p>
<p>
  So we have an interesting paradox.  As machine resources plummet, the
expected cost of large data structures falls — but because the cost
spread between adjacent cache levels is also going up, the
performance impact of being just large enough to break a cache
boundary is also rising.
</p>
<p>
  “Small is beautiful” is therefore better advice
than ever, particularly with regard to central data structures that
must live in the fastest possible cache.  The advice applies to code
as well; the average instruction spends more time being loaded than
it does executing.
</p>
<p>
  This turns some traditional advice on its head.  Compiler
optimizations like loop unrolling, which get rid of relatively
expensive machine instructions in return for an increase in total code
size, may no longer be worth doing.  Another example is precomputing
small tables — for example, a table of sin(x) by degree for
optimizing rotations in a 3D graphics engine will take 365 × 
4 bytes on a modern machine.  Before processors got enough faster than
memory to demand caching, this was an obvious speed optimization.
Nowadays it may be faster to recompute each time rather than pay for
the percentage of additional cache misses caused by the table.
</p>
<p>
  But in the future, this might turn around again as caches grow
larger.  More generally, many optimizations are temporary and can
easily turn into pessimizations as cost ratios change.  The only way
to know is to measure and see.
</p>



<!-- FILE: ch12s04.html -->
<h3 id="ch12s04"><a href="#ch12s04">§</a>Throughput vs. Latency</h3>
<p>
  Another effect of fast processors is that performance is 
usually bounded by the cost of I/O and — especially with 
programs that use the Internet — network transactions.  It's
therefore valuable to know how to design network protocols for
good performance.
</p>
<p>
  The most important issue is avoiding protocol round trips as
much as possible.  Every protocol transaction that requires a
handshake turns any latency in the connection into a potentially
serious slowdown.  Avoiding such handshakes is not specifically a
Unix-tradition practice, but it's one that needs mention here because
so many protocol designs lose huge amounts of performance to
them.
</p>
 <blockquote>
  <p>
   I cannot say enough about latency.  X11 went well beyond
X10 in avoiding round trip requests: the Render extension goes even
further.  X (and these days, HTTP/1.1) is a streaming protocol.  For
example, on my laptop, I can execute over 4
   <em>million</em>
   1×1 rectangle requests (8 million no-op
requests) per second.  But round trips are hundreds or thousands of
times more expensive. Anytime you can get a client to do something
without having to contact the server, you have a tremendous
win.
  </p>
  <span>
   – Jim Gettys
  </span>
 </blockquote>
<p>
  In fact, a good rule of thumb is to design for the lowest
possible latency and ignore bandwidth costs until your profiling tells
you otherwise.  Bandwidth problems can be solved later in development
by tricks like compressing a protocol stream on the fly; but getting
rid of high latency baked into an existing design is much, much harder
(often, effectively impossible).
</p>
<p>
  While this effect shows up most clearly in network protocol
design, throughput vs. latency tradeoffs are a much more general
phenomenon.  In writing applications, you will sometimes face a choice
between doing an expensive computation once in anticipation that it
will be used several times, or computing only when actually needed
(even if that means you will often recompute results).  In most cases
where you face a tradeoff like this, the right thing to do is bias
toward low latency.  That is, don't try to precompute expensive
operations unless you have a throughput requirement and know by actual
measurement that the throughput you are getting is too low.
Precomputation may seem efficient because it minimizes total use of
processor cycles, but processor cycles are cheap.  Unless you are
doing one of a handful of monstrously compute-intensive applications
like data mining, animation rendering, or the aforementioned bomb
simulations, it is usually better to opt for short startup times and
quick response.
</p>
<p>
  In Unix's early days this advice might have been considered
heretical.  Processors were much slower and cost ratios were very
different then; also, the pattern of Unix use was tilted rather more
strongly toward server operations.  The point about the value of low
latency needs to be made partly because even newer Unix developers
sometimes inherit an old-time cultural prejudice toward optimizing for
throughput.  But times have changed.
</p>
<p>
  Three general strategies for reducing latency are (a) batching
transactions that can share startup costs, (b) allowing transactions
to overlap, and (c) caching.
</p>
<h4 id="id2961306"><a href="#id2961306">§</a>Batching Operations</h4>
<p>
  Graphics APIs are frequently written on the assumption that the
fixed setup cost for a physical screen update is large.  Consequently, the
write operations actually modify an internal buffer.  It is up to
the programmer to decide when enough of these updates have been batched 
and to issue the call that turns them into a physical screen update.
Picking the right spacing of physical updates can make a great deal
of difference to the feel of the graphics client.  Both the 
X server and the
curses(3)
library used by roguelike programs are organized in this way.
</p>
<p>
  Persistent service daemons are a more Unix-specific example of
batching.  There are two reasons, one obvious and one subtle, to write
persistent daemons (as opposed to CLI servers that are started up
fresh for each session).  The obvious reason is to manage updates to a
shared resource.  The less obvious reason, which obtains even for daemons
that don't handle updates, is to amortize the cost of reading in the
daemon's database across multiple requests.  A perfect example of this
is the DNS service daemon
named(8),
which must sometimes handle thousands of requests per second, each one
of which may actually be blocking a user's Web page load.  One of the
tactics that makes
named(8)
fast is that it replaces parses of expensive on-disk text files
describing DNS zones with accesses to a cache held in memory.
</p>
<h4 id="id2961372"><a href="#id2961372">§</a>Overlapping Operations</h4>
<p>
  In
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>
  we
compared the POP3 and IMAP protocols for querying remote-mail
servers.  We noted that IMAP requests (unlike POP3 requests) are
tagged with a request identifier generated by the client; the server,
when it ships back a response, includes the tag of the request it
pertains to.
</p>
<p>
  POP3 requests have to be processed in lockstep by both client
and server; the client sends a request, waits for the response to that
request, and only then can prepare and ship the next one.  IMAP
requests, on the other hand, are are tagged so they can be overlapped.
If an IMAP client knows that it wants to fetch multiple messages, it
can stream several fetch requests (each with a different tag) to the
IMAP server, without waiting for responses between them.  Responses,
each tagged, will come back when the server is ready; responses to
early requests may come in while the client is still shipping later
ones.
</p>
<p>
  This strategy is general to more areas than network protocols.
If you want to cut latency, blocking or waiting on intermediate
results is deadly.
</p>
<h4 id="binary_caches"><a href="#binary_caches">§</a>Caching Operation Results</h4>
<p>
  Sometimes you can get the best of both worlds (low latency and
good throughput) by computing expensive results as needed and caching
them for later use.  Earlier we mentioned that
  <em>named</em> reduces latency by batching; it
also reduces latency by caching the results of previous network
transactions with other DNS servers.
</p>
<p>
  Caching has its own problems and tradeoffs, which are well
illustrated by one application: the use of binary caches to eliminate
parsing overhead associated with text database files.  Some variants
of Unix have used this technique to speed up access to their password
information (the usual motivation was to cut latency on logins at very
large sites).
</p>
<p>
  To make this work, all code that looks at the binary cache has
to know that it should check the timestamps on both files and
regenerate the cache if the text master is newer.  Alternatively, all
changes to the textual master must be made through a wrapper that will
update the binary format.
</p>
<p>
  While this approach can be made to work, it has all the
disadvantages that the SPOT
  rule would lead us to expect.  The
duplication of data means that it doesn't yield any economy of storage
— it's purely a speed
optimization.
But the real problem with it is that the code to ensure coherency
between cache and master is notoriously leaky and bug-prone.  Very
frequently updated cache files can lead to subtle race conditions
simply because of the 1-second resolution of timestamps.
</p>
<p>
  Coherency can be guaranteed in simple cases.  One such is the
Python interpreter, which compiles and deposits on disk a
p-code file with extension
  <code>.pyc</code> when a
Python library file is first imported. On subsequent runs the cached
copy of the p-code is loaded unless the source has since changed (this
avoids reparsing the library source code on every run).  Emacs
Lisp uses a similar technique with
  <code>.el</code> and
  <code>.elc</code> files.  This technique works because both
read and write accesses to the cache go through a single
program.
</p>
<p>
  When the update pattern of the master is more complex, however,
the synchronization code tends to spring leaks. The Unix variants that
used this technique to speed up access to critical system databases
were infamous for spawning system-administrator horror stories that
reflected this.
</p>
<p>
  In general, binary cache files are a brittle technique and
probably best avoided.  The work that went into implementing a
special-purpose hack to reduce latency in this one case would have
been better spent improving the application design so it doesn't have
a bottleneck there — or even on tuning to improve the speed of
the file system or the virtual-memory implementation.
</p>
<p>
  When you think you are in a situation that demands caching, it
is wise to look one level deeper and ask why the caching is necessary.
It may well be no more difficult to solve that problem than it would
be to get all the edge cases in the caching software right.
</p>



<!-- FILE: complexitychapter.html -->
<h3 id="complexitychapter"><a href="#complexitychapter">§</a>Chapter 13. Complexity</h3>
 <blockquote class="epigraph">
  <p>
   Everything should be made as simple as possible, but no simpler.
  </p>
  <span>
   – Albert Einstein
  </span>
 </blockquote>
<p>
  At the end of
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>, we summarized the Unix philosophy as
“Keep It Simple, Stupid!”  Throughout the Design
section, one of the continuing themes has been the importance of
keeping designs and implementations as simple as possible.  But what
  <em>is</em>
  “as simple as possible”?  How do
you tell?
</p>
<p>
  We've held off on addressing this question until now because
understanding simplicity is complicated.  It needs some of the ideas
we developed earlier in the Design section, especially in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>
  and
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>, as background.
</p>
<p>
  The large questions in this chapter are central preoccupations
of the Unix tradition, some of them motivating holy wars that have
simmered for decades.  This chapter starts from established Unix
practice and vocabulary, then goes a bit further beyond it than we do in
the rest of the book.  We don't try to develop simple answers to
these questions, because there aren't any — but we can hope that
you will walk away with better conceptual tools for developing
your own answers.
</p>



<!-- FILE: ch13s01.html -->
<h3 id="ch13s01"><a href="#ch13s01">§</a>Speaking of Complexity</h3>
<p>
  As with previous issues about modularity and interface design,
Unix programmers react to a set of distinctions they have often 
learned from experience without knowing how to articulate.  Therefore
we'll need to start by developing some terminology.
</p>
<p>
  We will start by defining what software complexity is.  We will
make some horizontal distinctions between different flavors of
complexity, which sometimes have to be traded off against each other.
We will finish by making some even more important vertical
distinctions, between the kinds of complexity we must live with and
the kinds we have the option to eliminate.
</p>
<h4 id="id2964646"><a href="#id2964646">§</a>The Three Sources of Complexity</h4>
<p>
  Questions about simplicity, complexity, and the right size of
software arouse a lot of passion in the Unix world.  Unix programmers
have learned a view of the world in which simplicity is beauty is
elegance is good, and in which complexity is ugliness is
grotesquery is evil.
</p>
<p>
  Underlying the Unix programmer's passion for simplicity is a
pragmatic fact: complexity costs.  Complex software is harder to think
about, harder to test, harder to debug, and harder to maintain —
and above all, harder to learn and use.  The costs of complexity,
rough as they are during development, bite hardest after
deployment. Complexity creates places for bugs to nest, from which
they will emerge to trouble the world through the entire lifetime of
their software.
</p>
<p>
  All kinds of pressures tend to drag programmers into a swamp of
complexity nevertheless.  We've examined a rogue's gallery of these in
earlier chapters; feature creep and premature optimization are the two
most notorious.  Traditionally, Unix programmers push back against
these tendencies by proclaiming with religious fervor a rhetoric that
condemns all complexity as bad.
</p>
<p>
  So what exactly do we mean by ‘complexity’?  This
point is worth pinning down, because it varies by observer.
</p>
<p>
  Unix programmers (like other programmers) tend to focus on
  <em>implementation complexity</em> —basically,
the degree of difficulty a programmer will experience in attempting to
understand a program so he or she can mentally model or debug
it.
</p>
<p>
  Customers and users, on the other hand, tend to see complexity
in terms of the program's
  <em>interface complexity</em>.
In
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>
  we discussed
the quality of ease and its inverse, mnemonic load.  To a user,
complexity correlates closely with mnemonic load.  Poor expressiveness
and concision can matter too, if a weak interface forces the user to
perform lots of error-prone or merely tedious low-level operations
rather than a few high-level ones.
</p>
<p>
  Driven by both of these is a third measure that is much simpler:
the total number of lines of code in the system, its
  <em>codebase size</em>.  In terms of life-cycle costs,
this is usually the most important measure.  The reasons go back to
perhaps the most important empirical result in software engineering,
one we've cited before: the defect density of code, bugs per hundred
lines, tends to be a constant independent of implementation language.
More lines of code means more bugs, and debugging is the most
expensive and time-consuming part of development.
</p>
<p>
  Codebase size, interface complexity and implementation
complexity may all rise together.  That is the usual result of feature
creep, and why programmers especially dread it.  Premature
optimization doesn't tend to raise interface complexity, but it has
bad effects (often severely bad) on implementation complexity and
codebase size.  But those sorts of arguments against complexity are
relatively easy to win; the difficult ones begin when these three
measures have to be traded off against each other.
</p>
<p>
  We've already mentioned one situation in which two measures vary in
opposite directions: a user interface that has been designed primarily
to preserve implementation simplicity, or keep codebase size down, may
simply dump low-level tasks on the user.  (A crude example of this,
barely imaginable to a Unix programmer but all too common elsewhere,
might be an editor that lacked a global-replace feature.)  Though this
sort of design failure is all too common, it does not traditionally
have a name. We'll call it a
  <em>manularity trap</em>.
</p>
<p>
  Pressure to keep the codebase size down by using extremely dense
and complicated implementation techniques can cause a cascade of
implementation complexity in the system, leading to an un-debuggable
mess.  This used to happen frequently when fitting programs onto very
small systems demanded assembler programming or tricks like
self-modifying code; nowadays it is uncommon except in embedded systems,
and rapidly becoming rare even there.  This kind of design failure doesn't
have a traditional name, but one might call it a
  <em>blivet trap</em>, after an old Army term for the results of attempting
to stuff ten pounds of horse manure into a five-pound bag.
</p>
<p>
  The blivet trap won't appear in our case studies, but we've
defined it for contrast with its opposite.  It can happen that the
designers of a project are so wary of implementation complexity that
they reject a complex but unified way to solve a whole class of
problems in favor of lots of duplicative, ad-hoc code that solves each
individual one in turn. The result is bloat in the size of the
codebase, and maintainability problems more severe than if the unified
method had been accepted.  For example, a Web project that really
needs a centralized relational database behind its pages might instead
spawn several different keyed data files containing information that
has to be reintegrated at page generation time.  This sort of failure
is all too common.  It doesn't have a traditional name; we'll call it
an
  <em>adhocity trap</em>.
</p>
<p>
  These are the three faces of complexity, and some of the traps
designers fall into in attempts to avoid them.<sup><a href="#ftn.id2964826" id="id2964826">[114]</a></sup>
  We'll see more examples
when we get to the case studies later in the chapter.
</p>
<h4 id="id2964843"><a href="#id2964843">§</a>Tradeoffs between Interface and Implementation Complexity</h4>
<p>
  One of the most perceptive observations ever made about the Unix
tradition by someone standing outside it was contained in Richard
Gabriel's paper called
  <em>Lisp: Good News, Bad News, and How to Win Big</em><sup><a href="#Gabriel" title="[Gabriel]">[Gabriel]</a></sup>.
Gabriel is a long-time leader of the Lisp community, and the paper was
primarily an argument for a particular style of
Lisp
  design,
but the author himself acknowledges that it is now remembered
primarily for the section called ‘The Rise of
  <em>
   Worse Is
Better
</em>
  ’.
</p>
<p>
  The paper argued that Unix and C have the characteristics of
viruses, and that in the evolutionary struggle among software designs
traits like implementation simplicity and portability which lead to
rapid propagation (infectiousness) are more effective than correctness
and completeness of the design.  Gabriel came so close to anticipating
the ‘many-eyeballs’ effect on open-source software that
the open-source community retrospectively adopted him as one of its
theorists after 1997.
</p>
<p>
  Less remembered is that the Gabriel's central argument was about
a very specific tradeoff between implementation and interface
complexity, one which rather exactly fits the categories we have
examined in this chapter.  Gabriel contrasts an ‘MIT’
philosophy most valuing interface simplicity with a ‘New
Jersey’ philosophy most valuing implementation simplicity.
He then proposes that although the MIT philosophy leads to software
that is better in the abstract, the (worse) New Jersey model has better
propagation characteristics.  Over time, people pay more attention 
to software written in the New Jersey style, so it improves faster.
Worse becomes better.
</p>
<p>
  In fact, the MIT and New Jersey philosophies have analogs as
conflicting tendencies within the Unix design tradition itself. One
strain of Unix thinking emphasizes small sharp tools, starting designs
from zero, and interfaces that are simple and consistent.  This point
of view has been most famously championed by Doug McIlroy. Another
strain emphasizes doing simple implementations that work, and that
ship quickly, even if the methods are brute-force and some edge cases
have to be punted.  Ken Thompson's code and his maxims about
programming have often seemed to lean in this direction.
</p>
<p>
  The tension between these approaches arises precisely because
one can sometimes get a simpler interface if one is willing to pay 
implementation complexity for it, or vice versa.  Gabriel's original
example, about how system calls that do long operations handle
interrupts they cannot hold or mask, is still one of the best.  Under
the MIT philosophy, the right thing to do would be to back out of
the system call and automatically resume it once the interrupt has
been handled; this is harder to implement but leads to a simpler
interface.  Under the New Jersey philosophy, the system call would
return an error indicating that it has been interrupted and the
user must re-execute; this can be implemented far more simply, but
leads to a programming interface that is more difficult to use.
</p>
<p>
  Both approaches have been tried.  Old Unix hands will instantly
think of System-V-style vs. BSD-style handling of software signals;
the latter follows the MIT philosophy, while the former hails from New
Jersey. Underlying the choice between them is a pressing question
that has nothing directly to do with the software's infectiousness:
if your goal is to hold down total global complexity, where are you
most willing to pay to do that?  Where
  <em>should</em>
  you
be most willing to pay?
</p>
<p>
  One epochal example not mentioned in Gabriel's paper is from
distributed hypertext systems.  Early distributed-hypertext projects
such as NLS and Xanadu were severely constrained by the MIT-philosophy
assumption that dangling links were an unacceptable breakdown in the
user interface; this constrained the systems to either browsing only a
controlled, closed set of documents (such as on a single CD-ROM) or
implementing various increasingly elaborate replication, caching, and
indexing methods in an attempt to prevent documents from randomly
disappearing.  Tim Berners-Lee cut through this Gordian knot by
punting the problem in classic New Jersey style.  The simplicity of
implementation he bought by allowing “404: Not Found” as
a response was what made the World Wide Web lightweight enough to
propagate and succeed.
</p>
<p>
  Gabriel himself, while sticking with the observation that
‘worse’ is more infectious and tends to win in the end,
has publicly changed his mind several times about the underlying
complexity-related question of whether or not this is actually a good
thing.  His uncertainty mirrors a lot of ongoing design 
debates within the Unix community.
</p>
<p>
  We cannot offer a one-size-fits-all answer.  As with most of the
large questions in this chapter, good taste and engineering judgement
will demand different answers in different situations.  The important
thing is to develop the habit of thinking carefully about this issue
on each and every one of your designs.  As we have observed before in
discussing software modularity, complexity is a cost you must budget
very carefully.
</p>
<h4 id="id2961759"><a href="#id2961759">§</a>Essential, Optional, and Accidental Complexity</h4>
<p>
  In an ideal world, Unix programmers would craft only small,
perfect gems of software, each minimal, each elegant, each
perfect. But one of the unfortunate things about reality is that it
often poses complex problems that demand complex solutions.  You can't
control a jetliner with an elegant ten-line procedure.  There are too
many pieces of equipment, too many channels and interfaces, too many
different processors — too many different subsystems defined by
independently operating human beings who often don't agree even on
fundamental conventions.  Even if you are successful at making all the
individual software parts of an avionics system elegant, integration
is likely to produce a large, complex, and grubby body of code with
(one hopes) the single virtue that it will actually
  <em>work</em>.
</p>
<p>
  Jetliners have
  <em>essential complexity</em>.  
There is a rather sharp point past which it's not possible to trade
away features for simplicity, because the plane has to stay in the air.  
Because of that very fact, avionics control systems do not tend to
spawn religious wars about complexity — and Unix programmers
tend to stay away from them.
</p>
<p>
  Jetliners are certainly not immune from system failures due to
overcomplexity.  But the design issues are easier to discern and think
about in software for which the requirements are more flexible, in
which it is easy to trade off between anticipated features and
complexity. (Here, and in the rest of this chapter, we will use
‘feature’ in a very general sense that includes things
like performance gains or overall degree of interface polish.)
</p>
<p>
  To sharpen our vision, we need to begin by noticing a difference
between
  <em>accidental complexity</em> and
  <em>optional complexity</em>.<sup><a href="#ftn.id2961828" id="id2961828">[115]</a></sup>
  Accidental complexity
happens because someone didn't find the simplest way to implement a
specified set of features.  Accidental complexity can be eliminated by
good design, or good redesign.  Optional complexity, on the other
hand, is tied to some desirable feature.  Optional complexity can be
eliminated only by changing the project's objectives.
</p>
<p>
  When we fail to distinguish between optional and accidental
complexity, design debates become seriously confused.  Questions about
what a project's objectives are get confused with questions about the
aesthetics of simplicity, and whether people have been sufficiently
clever.
</p>
<h4 id="id2961870"><a href="#id2961870">§</a>Mapping Complexity</h4>
<p>
  So far, we've developed two different scales for thinking about complexity.  These scales are actually orthogonal to
  each other. Figure 13.1 may help clarify the relationships.  Each of the nine boxes of the figure lists a common
  source of a particular kind of complexity.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 13.1. Sources and kinds of complexity.
   </b>
  </p>
  <div class="center">
   <img alt="Sources and kinds of complexity." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  We've touched on some of these varieties of complexity earlier
in this book, especially the accidental ones. In
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>
  we saw that accidental interface
complexity often comes from non-orthogonality in the interface design
— that is, failing to carefully factor the interface operations
so that each does exactly one thing.  Accidental code complexity
(making code more complicated than it needs to be to get the job done)
often results from premature optimization. Accidental codebase bloat
often results from violating the SPOT rule, duplicating code or
organizing it poorly so that opportunities for reuse aren't
recognized.
</p>
<p>
  Essential interface complexity usually can't be cut without
trimming the basic functional requirements for the software (a theme
we'll develop further in this chapter's case studies).  Essential
codebase size is related to choice of development tools because, if
the feature list is held constant, the most important factor in
codebase size is probably the choice of implementation language (as we
implied in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>).
</p>
<p>
  Sources of optional complexity are the most difficult to make
useful generalizations about, because they so often depend on
delicate judgments about which features it is worth paying the
complexity cost for.  Optional interface complexity often comes from
adding convenience features that make life easier for users but aren't
essential to the function of the program.  Optional increases in
codebase size (supposing the user-visible features and the algorithms
used are held constant) can often come from various sorts of practices
intended to make it more maintainable — adding mode comments,
using long variable names, and so forth. Optional implementation
complexity tends to be driven by
  <em>everything</em>
  that
touches a project.
</p>
<p>
  The sources of complexity have to be grappled with in different
ways.  Codebase size can be attacked with better tools.
Implementation complexity can be addressed with better choice of
algorithms.  Interface complexity has to be addressed with better
interaction design, a skill involving considerations of ergonomics and
user psychology.  This skill is less common (and possibly more
difficult) than writing code.
</p>
<p>
  Attacking the kinds of complexity, on the other hand, has to be
done more with insight than with methods.  You cut accidental
complexity by noticing that there is a simpler way to do things.
You cut optional complexity by making context-dependent judgments
about what features are worthwhile.  You can only cut essential 
complexity by having an epiphany, fundamentally redefining the
problem you are addressing.
</p>
<h4 id="id2963237"><a href="#id2963237">§</a>When Simplicity Is Not Enough</h4>
<p>
  The failure mode that goes with the Unix tradition's insistence
on simplicity is that Unix programmers often talk (and sometimes even
behave) as though all optional complexity is accidental.  More than
this, there is a strong bias in the Unix tradition toward removing
features rather than accepting optional complexity.
</p>
<p>
  The case for this attitude is easy to make (indeed, we spend
much of this book making it).  Clean minimalism makes us feel virtuous
on many levels, and designing for it is a valuable counter to
the natural tendency of software systems to develop
ever-more-elaborate encrustations of ill-considered features.  But
computing resources and human thinking time, like wealth, find their
justification not in being hoarded but in being spent.  As with other
forms of asceticism, one has to ask when design minimalism stops being
a valuable form of self-discipline and starts being a mere hair shirt
— a way to indulge those feelings of virtue at the expense of
actually
  <em>using</em>
  that wealth to get work
done.
</p>
<p>
  This is a perilous question, all too easily turned into an
argument for abandoning good design discipline altogether.  Unix old
hands often shy away from it, fearing that failing to hold the hardest
possible line against complexity and bloat will lead us inexorably to
damnation.  But it's also a
  <em>necessary</em>
  question.
We'll tackle it directly when analyzing this chapter's case
studies.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2964826" id="ftn.id2964826">[114]</a></sup>
  The terms
we have invented for these design traps, unlikely as they may sound,
come from established hacker jargon described in <sup><a href="#Raymond96" title="[Raymond96]">[Raymond96]</a></sup>.
</p>

<p><sup><a href="#id2961828" id="ftn.id2961828">[115]</a></sup>
  The
distinction between accidental and optional complexity means that the
categories we're discussing here are
  <span class="emphasis">
   <em>not</em>
  </span>
  the same
as essence and accident in Fred Brooks's essay
  <em>No Silver Bullet</em><sup><a href="#Brooks" title="[Brooks]">[Brooks]</a></sup>, but they have common
ancestry in philosophy.
</p>
</div>


<!-- FILE: ch13s02.html -->
<h3 id="ch13s02"><a href="#ch13s02">§</a>A Tale of Five Editors</h3>
<p>
  Now we're going to use five different Unix editors as case 
studies.  It will be helpful to bear in mind a set of benchmark
tasks as we examine these designs:
</p>
 <div>
  <ul>
   <li>
    <p>
     <em>Plain-text editing.</em>
     Manipulating
plain ASCII (or, in this internationalized age, perhaps Unicode) files
with no structure known to the editor above byte level, or perhaps
line level.
    </p>
   </li>
   <li>
    <p>
     <em>Rich-text editing.</em>
     Editing of text
with attributes; these might include font changes, color, or other sorts of
properties of text spans (such as being a hyperlink).  Editors that can
do this have to be able to translate between some presentation of the
attributes in the user interface and some on-disk representation of
the data (such as HTML, XML, or other rich-text formats.)
    </p>
   </li>
   <li>
    <p>
     <em>Syntax awareness.</em>
     An editor that
is syntax-aware knows that input events have a grammar, and does things like
automatically changing the indent level when it recognizes the
beginning or end of a block scope in a programming language.  Editors
that are syntax-aware also commonly highlight syntax with colors
or distinguished fonts.
    </p>
   </li>
   <li>
    <p>
     <em>Output parsing</em>
     of batch command
output. The commonest case of this in the Unix world is running a C
compilation from inside the editor, trapping the error messages, and
then being able to step through the error locations without leaving the
editor.
    </p>
   </li>
   <li>
    <p>
     <em>Interaction</em>
     with helper
subprocesses that persist and maintain state between editor commands.
This capability, when present, has powerful consequences:
    </p>
    <div>
     <ul>
      <li>
       <p>
        It's possible to drive a version-control system
    from inside the editor, performing file checkins and checkouts
    without dropping out to a shell window or separate
    utility.
       </p>
      </li>
      <li>
       <p>
        It's possible to front-end a symbolic debugger
    inside the editor, such that (for example) when the run stops on a
    breakpoint the appropriate file and line is automatically
    visited.
       </p>
      </li>
      <li>
       <p>
        It's possible to edit remote files within the
    editor, by having it recognize when a filename refers to another
    host (recognizing some syntax like
        <code>/user@host:/path/to-file</code>).  Provided you have
    the right access, such an editor can automatically run a
    utility like
    scp(1)
    or
    ftp(1)
    to fetch a local copy, then automatically copy the edited version
    back to the remote location at file-save time.
       </p>
      </li>
     </ul>
    </div>
   </li>
  </ul>
 </div>
<p>
  All our case studies can edit plain text.  (The reader should
not take this capability for granted — there are many things
called editors, such as ‘word processors’ that are too
specialized to do this!) We begin seeing variable degrees of optional
complexity in how they handle the more complex tasks.
</p>
<h4 id="id2963445"><a href="#id2963445">§</a>ed</h4>
<p>
  ed(1)
is the truly Unix-minimalist way of plain-text editing.  It dates from
the days of teletypes.<sup><a href="#ftn.id2963466" id="id2963466">[116]</a></sup>
  It has a simple, austere CLI, and there is
no screen display.  In the following listing, computer output is
  <em>emphasized</em>.
</p>
 <pre class="programlisting">
ed sample.txt
<em>sample.txt: No such file or directory</em>
# This is a comment line, not a command.
# The message above warns that the sample.txt file is newly created.
a
<em>the quick brown fox
jumped over the lazy dog</em>
.
# That was an append command, which added text to the file.  
# The dot on a line by itself terminated the append.
1s/f[a-z]x/dragon/
# On line 1, replace the first substring matching an f followed by a
# lowercase alphabetic followed by x with ‘dragon’.  The
# substitute command accepts basic regular expressions.
1,$p
the quick brown dragon
jumped over the lazy dog
# Print all lines from 1 to the last.
w
<em>51</em>
# That wrote the file to disk. The ‘q’ command ends the
# editing session.
q
</pre>
<p>
  Unbelievable as it may seem to a modern reader, most of Unix's
original code was written with this editor.  The reader with DOS
experience may recognize here the original on which
  <em>EDLIN</em> was (crudely) modeled.
</p>
<p>
  If one defines the job of an editor simply as enabling the user
to create and modify plain text files,
ed(1)
is entirely sufficient for the job.  Importantly to the Unix view of
design correctness, it does nothing else.  Many old-school Unix
programmers half-seriously maintain that all editors with more
features than ed has are simply bloated — and a few still who
seriously believe this.
</p>
<p>
  Appropriately,
  <em>ed</em> was Ken Thompson's
deliberate simplification of the earlier
  <em>qed</em> <sup><a href="#RitchieQED" title="[RitchieQED]">[RitchieQED]</a></sup> editor
— which was very similar (and the first editor to use regular
expressions in the characteristic Unix way) but had multiple-buffer
capability that Ken deliberately discarded.  He judged it not worth
the additional complexity.
</p>
<p>
  A notable characteristic of ed(1) and all its descendants is the
object-operation format of its commands (the session example shows an
explicit range on the ‘p’ command).  There is a relatively
powerful syntax for specifying line ranges, either numerically, or by
regular-expression pattern match, or by special shorthands for the
current and last line.  Most editor operations can be applied to any
range.  This is a good example of orthogonality.
</p>
<p>
  Nowadays,
ed(1)
is primarily used as a program-driven editing tool in scripts —
a role to which editors with more elaborate modes of interactivity are
unsuited.  There is a close variant called
ex(1)
which adds a few useful interactivity features such as command
prompts; it is occasionally useful in rare cases when editing must be
done over a slow serial line, or in certain unusual crash-recovery
situations where the library support needed to run other editors is
not accessible.  For these reasons, every Unix includes an
  <em>ed</em> implementation and most include
  <em>ex</em> as well.
</p>
<p>
  The
sed(1)
stream editor mentioned in
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>
  is also closely related to ed; many
of the basic commands are the same, though designed to be invoked
through command-line switches rather than from standard input.
</p>
<p>
  Almost all Unix programmers have strayed from the path of
austerity and minimalist virtue enough to normally use editors that at
least present a roguelike, screen-oriented interface.  However, the
fact that the religion of ed
persists<sup><a href="#ftn.id2963675" id="id2963675">[117]</a></sup>
  says a great deal that is worth
noting about the Unix mindset.
</p>
<h4 id="vi_complexity"><a href="#vi_complexity">§</a>vi</h4>
<p>
  The original
vi(1)
editor was the first attempt to bolt a visual, roguelike interface
onto the command set of
ed(1).
Like ed, its commands are generally single
keystrokes, and it is particularly well suited to use by
touch-typists.
</p>
<p>
  The original vi didn't have mouse
support, editing menus, macros, assignable key bindings, or any form
of user customization. In line with the religion of ed, vi's partisans
considered the lack of these features a virtue.  On this view, one of
vi's most important virtues is that you can start editing immediately
on a new Unix system without having to carry along your customizations
or worrying that the default command bindings will be dangerously
different from what you're used to.
</p>
<p>
  One characteristic of vi that
beginners tend to find frustrating is a result of its terse
single-keystroke commands. It has a
  <em>moded</em> interface — you are either in command mode or in text-insertion
mode. In text-insertion mode, the only commands that work are the
ESC key for mode exit and (on newer versions) the cursor-movement
keys. In command mode, typing text will be interpreted as commands and
do odd (and probably destructive) things to your content.
</p>
<p>
  On the other hand, one property of the command set that
vi fans particularly tout is the
object-operation format it inherited from
ed. Most of the extended commands also
operate in a natural way on any line range.
</p>
<p>
  Over the years, vi has bulked up
considerably.  Modern versions add mouse support, editing menus,
unlimited undo (the original vi could only
undo the last command), multiple files in separate buffers, and
customization with a run-control file.  However, the use of
run-control files is still unusual, and in contrast to
Emacs, the use of embedded general-purpose
scripting has never caught on.  Instead, vi
implementations have grown individual capabilities to do things, like
syntax awareness of C code and output parsing of C compiler error
messages, by adding C code to vi itself.
Subprocess interaction is not supported.
</p>
<h4 id="id2963798"><a href="#id2963798">§</a>Sam</h4>
<p>
  The
  <em>Sam</em> editor<sup><a href="#ftn.id2963818" id="id2963818">[118]</a></sup>
  was written by Rob Pike at Bell Labs in the mid-1980s.  Sam was
designed for the Plan 9 operating system, which we'll survey in
  <a href="#futurechapter" title="Chapter 20. Futures">
   Chapter 20</a>.  While the Sam editor is not widely known
outside the Labs, it's favored by many of the original Unix developers
who went on to work on Plan 9, including Ken Thompson himself.
</p>
<p>
  Sam is a fairly straightforward descendant of ed, remaining much
closer to its parent than vi.  Sam incorporates only two new concepts:
a curses-style text display and text selection with the mouse.
</p>
<p>
  Each Sam session has exactly one command window, and one or more
text windows.  Text windows edit text, and command windows accept
ed-style editing commands.  The mouse is used to move between windows,
and to select text regions within text windows.  This is a clean,
orthogonal, modeless design that discards most of the interface
complexity of vi.
</p>
<p>
  Most commands operate by default on a select region that can be
painted with a mouse drag operation.  The select region for a command
can also be set by specifying a line range in the fashion of ed, but
Sam gains considerable power from the fact that the user can select at
finer granularity than a line range.  Because the mouse is available
to do selections and rapidly change focus between buffers (including
the command buffer), Sam needs no equivalent of the default (command)
mode of vi.  The hundreds of extended vi commands are unnecessary and,
therefore, omitted. Overall, Sam adds only about a dozen commands to
the seventeen or so in the ed set, for a total of about thirty.
</p>
<p>
  Four of the new commands in Sam join two inherited from
ed(1)
and
vi(1),
as ways to apply regular expressions to the task of selecting files
and file regions to operate on.  These provide limited but effective
loop and conditional facilities to the command language.  There is,
however, no way to name or parameterize command-language
procedures. Nor can the language do interactive control of a
subprocess.
</p>
<p>
  An interesting feature of Sam is that it's split into two parts.
separating a back end that manipulates files and does searches from a
front end that handles the screen interface.  This instance of the 
“separated engine and interface” chapter has the 
immediate practical benefit that, though the program has a GUI, it
can run easily over a low-bandwidth connection to edit files on a
remote server.  Also, the front and back ends can be retargeted
relatively easily.
</p>
<p>
  Sam, like recent versions of vi, has infinite undo.  By design,
it supports neither rich-text editing, nor output parsing, nor
subprocess interaction.
</p>
<h4 id="emacs_editing"><a href="#emacs_editing">§</a>Emacs</h4>
<p>
  <em>Emacs</em> is undoubtedly the most
powerful programmer's editor in existence. It's a big, feature-laden
program with a great deal of flexibility and customizability. As we
observed in the
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>
  section on Emacs Lisp, Emacs has an entire programming language inside
it that can be used to write arbitrarily powerful editor
functions.
</p>
<p>
  Unlike
vi,
Emacs doesn't have interface modes;
instead, commands are normally control characters or prefixed with an
ESC. However, in Emacs it is possible to
bind just about any key sequence to any command, and commands can be
stock or customized Lisp programs.
</p>
<p>
  Emacs can edit multiple files, each
in a separate buffer, and supports moving text among the buffers.
Versions running under X have native mouse support.
</p>
<p>
  The Lisp programs bound to Emacs keystrokes can perform
arbitrary text transformations on a buffer.  This capability is
heavily used, among other things to define syntax-aware and rich-text
editing modes for dozens of different languages and markup formats
(beginning with support and color highlighting of C code as in
vi, but going way beyond that).  Each mode
is simply a library file of Lisp code that is loaded on demand.
</p>
<p>
  Emacs Lisp programs can also interactively control arbitrary
subprocesses.  Some notable consequences of this capability were
listed earlier, including the ability to serve as a front end for
version-control systems, debuggers, and the like.
</p>
<p>
  The designers of Emacs<sup><a href="#ftn.id2967056" id="id2967056">[119]</a></sup>
  built a programmable editor
that could have task-related intelligence customized into it for
hundreds of different specialized editing jobs.  They then gave it the
ability to drive other tools. As a result, Emacs supports dealing with
all things textual in one shared context — files, mail, news,
debugger symbols.  It can serve as a customizable front end to any
command with an interactive textual interface.
</p>
<p>
  It is a common joke, both among fans and detractors of
Emacs, to describe it as an operating
system masquerading as an editor.  That overstates the case, but
Emacs certainly does fulfill the role
occupied by integrated development environments (IDEs) under non-Unix
operating systems (a theme to which we shall return in
  <a href="#toolschapter" title="Chapter 15. Tools">
   Chapter 15</a>).
</p>
<p>
  This power comes at a price in complexity. To use a customized
Emacs you have to carry around the Lisp
files that define your personal Emacs
preferences. Learning how to customize
Emacs is an entire art in
itself. Emacs is correspondingly harder to
learn than vi.
</p>
<h4 id="id2967110"><a href="#id2967110">§</a>Wily</h4>
<p>
  The
  <em>wily</em> editor<sup><a href="#ftn.id2967125" id="id2967125">[120]</a></sup>
  is a clone of the Plan 9
  editor
  <em>acme</em>.<sup><a href="#ftn.id2967150" id="id2967150">[121]</a></sup>
  It shares some facilities with Sam, but is intended to provide a
fundamentally different user experience.  Although Wily probably sees
the least widespread use of any of these editors, it is interesting
because it illustrates a different and arguably more Unixy way of
implementing an Emacs-like programmable editor.
</p>
<p>
  Wily could be described as a minimalist IDE, an implementation
of Emacs-style extensibility without the decades of accompanying
cruft.  In Wily, even global search and replace, that
  <span class="foreignphrase">
   <em>sine qua non</em> </span>
  of Unix editors, is
supplied by an external program.  The built-in commands relate almost
exclusively to windowing operations.  Wily is designed from the ground
up to use the mouse as much, and as well, as possible.
</p>
<p>
  Wily attempts to replace not only conventional editors but
conventional terminal windows such as
xterm(1)
as well.  In Wily, any piece of text within the main window (which
contains multiple non-overlapping Wily windows) can be an action or a
search expression.  The left mouse button is used to select text, the
middle button to execute text as a command (either built-in or
external), and the right button to search either Wily's buffers or the
file system for text.  No permanent or popup menus are
required.
</p>
<p>
  In Wily, the keyboard is used
  <em>only</em>
  to enter
text.  Shortcuts are achieved not by special use of the keyboard, but
by holding down more than one mouse button at the same time.  These
shortcuts are always equivalent to using the middle button on some
built-in command.
</p>
<p>
  Wily can also be used as the front
end for C, Python, or Perl programs, reporting to them whenever a
window is changed or an execute or search command is performed with
the mouse.  These plugins function analogously to Emacs modes, but
don't run in the same address space with Wily; instead, they
communicate with it via a very simple set of remote procedure calls.
Wily comes packaged with an
  <em>xterm</em> analog
and a mail tool which uses it as the editing front end.
</p>
<p>
  Because Wily depends on the mouse so heavily, it cannot be used
on a character-cell-only console display; nor can it be used over a
remote link without X forwarding.  As an editor, Wily is designed for
editing plain text; it has only two fonts (one proportional and one
fixed-width) and has no mechanism that could support rich-text editing
or syntax awareness.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2963466" id="ftn.id2963466">[116]</a></sup>
  Younger readers may not be aware
that terminals used to print.  On paper.  Very
slowly.
</p>

<p><sup><a href="#id2963675" id="ftn.id2963675">[117]</a></sup>
  The religion of ed
is exemplified by a famous Usenet posting which the reader may be able
to find with a Web search for “Ed is the standard
editor”.  While it is clearly intended as parody, it is by no
means clear that the author was entirely joking.  Most Unix hackers
would read it as an example of “Ha ha, only
serious”.
</p>

<p><sup><a href="#id2963818" id="ftn.id2963818">[118]</a></sup>
  <a href="http://plan9.bell-labs.com/sys/doc/sam/sam.html">
   http://plan9.bell-labs.com/sys/doc/sam/sam.html</a>
</p>

<p><sup><a href="#id2967056" id="ftn.id2967056">[119]</a></sup>
  The designers of Emacs were
Richard M. Stallman, Bernie Greenberg, and Richard M. Stallman.  The
original Emacs was Stallman's invention, the first version with an
embedded Lisp was Greenberg's, and the now-definitive version is
Stallman's derived from Greenberg's.  No complete account of the
design history has been written in 2003, but Greenberg's
  <em>Multics Emacs: The History, Design, and Implementation</em>
  is illuminating and readily discoverable
via keyword search on the Web.
</p>
</div>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2967125" id="ftn.id2967125">[120]</a></sup>
  <a href="http://www.cs.yorku.ca/~oz/wily">
   http://www.cs.yorku.ca/~oz/wily</a>
</p>

<p><sup><a href="#id2967150" id="ftn.id2967150">[121]</a></sup>
  <a href="http://plan9.bell-labs.com/sys/doc/acme/acme.html">
   http://plan9.bell-labs.com/sys/doc/acme/acme.html</a>
</p>
</div>


<!-- FILE: ch13s03.html -->
<h3 id="ch13s03"><a href="#ch13s03">§</a>The Right Size for an Editor</h3>
<p>
  Now let us examine our case studies using the complexity
categories we developed at the beginning of this chapter.
</p>
<h4 id="id2967267"><a href="#id2967267">§</a>Identifying the Complexity Problems</h4>
<p>
  Every text editor has a certain amount of essential complexity.
At minimum, it has to maintain an internal buffer copy of the file or
files the user is editing. Functions to import and export file data
are a minimum requirement (usually from and to disk, though the stream
editor
sed(1)
is an interesting exception).  Some way to modify the buffer must be
supported, though we cannot specify what way without describing
specific features that are optional.  Our four examples show widely
varying levels of optional and accidental complexity beyond
this.
</p>
<p>
  Of all of these,
ed(1)
has the least complexity.  Almost the only non-orthogonal feature in
its command set is the fact that many of its commands can take a
‘p’ or ‘l’ suffix to print or list command
results.  Even after three decades of feature additions there are
fewer than thirty editing commands, and the normal working set for
most users will be less than a dozen.  There is not much in the way of
optional complexity that could be removed here, and it's hard to
identify any accidental complexity at all.  The user interface of
ed is strictly compact.
</p>
<p>
  On the flip side, the ed interface is
not really suitable for editing tasks even as basic as rapidly
flipping through a text file.  One has to limit one's objectives
pretty sharply for ed to become an
acceptable solution for interactive editing.
</p>
<p>
  Suppose, then, that we add “support visual browsing and
editing of multiple files” as an objective?  Then
Sam seems not very far from being the
minimal ed extension that could achieve
this.  The fact that the designers did not change the semantics of the
inherited ed commands is notable; they kept
an existing, orthogonal set and added a relatively small set of
capabilities that are themselves orthogonal.
</p>
<p>
  One large increase in optional (implementation) complexity is
Sam's infinite-undo capability.  Another
significant one is the new regular-expression-based loop and iteration
facility in the command language.  These, and the fact that the mouse
can be used as a selection device, are about all that distinguish
Sam from a hypothetical
ed with a mouse-and-windows
interface.
</p>
<p>
  Without a thorough code audit it's difficult to be sure, but at
the design level it's hard to identify any accidental complexity in
Sam.  The interface is at least semi-compact and arguably strictly compact.
This editor lives up to the very highest standards of Unix design
— unsurprisingly, given its provenance.
</p>
<p>
  By contrast, vi looks rather bloated
and flabby.  There are hundreds of commands, many of them
duplicative. These are at best optional complexity, and perhaps
accidental. At a guess, most users don't know more than 5% of the
command set.  With the example of Sam
before us, it's fair to wonder why the interface complexity of
vi is so high.
</p>
<p>
  In
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>
  we
described the effect of the absence of standard arrow keys on early
roguelike programs; vi was one of these.  When vi was built, its
author knew that many of his users would need to be able to use the
cursor motion keys traditional on Unix glass teletypes.  This made a
modal interface inevitable.  Once the hjkl keys had mode-dependent
meanings in an edit buffer, it was all too easy to fall into the habit
of adding new commands in an ad-hoc way.
</p>
<p>
  Sam, designed as it is to depend on a
bitmapped display with both arrow keys and a mouse, can be much
cleaner.  And it is.
</p>
<p>
  But the clutter of vi commands is a relatively superficial
problem.  It's interface complexity, yes, but of a kind most users can
and do ignore (the interface is semi-compact in the sense we developed
in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>).  The deeper problem is an
adhocity trap. Over the years, vi has had progressively more and more
special-purpose C code bolted onto it to perform tasks that Sam
refuses to do and that Emacs would attack with Lisp code modules and
subprocess control. The extensions are not, as in Emacs, libraries
loaded as needed; users pay the overhead for the resulting code bloat
all the time.  As a result, the size difference between a modern vi
and a modern Emacs is not nearly as great as one might expect; in
mid-2003 on an Intel-architecture machine, it's 1500KB for GNU Emacs
versus 900KB for vim.  There is a whole lot of both optional and
accidental complexity in that 900KB.
</p>
<p>
  For vi partisans, not having an embedded scripting language
— not being Emacs — has become an identity issue, a central
part of the shared myth that vi is a lightweight editor.  While vi
fans like to talk about filtering buffers with external programs and
scripts to do what Emacs's embedded scripting does, the reality is
that vi's “!” command cannot filter regions of an edit
buffer selected at finer granularity than a range of lines (Sam and
Wily, though they have no more subprocess management than vi does, can
at least filter arbitrary text ranges, not just line ranges).  All
knowledge of file formats and syntaxes that vary at a finer
granularity (and most do) has to be built in to C code if vi is going
to have it available at all.  There is thus little prospect that the
codebase-size ratio between Emacs and vi will improve in favor of vi;
indeed, it seems likely to get worse.
</p>
<p>
  Emacs is sufficiently large, and has
a sufficiently tangled history, to make separating its optional from
its accidental complexity quite a challenge.  We can at least begin by
trying to separate the dispensable accidents of the
Emacs design from its indispensable
essentials.
</p>
<p>
  Perhaps the most conspicuously dispensable part of the
Emacs design is Emacs
Lisp.  It
is essential to what Emacs does that it
features what we nowadays call an embedded scripting language, but
Emacs would be little different in
capability if that language had been Python or Java or Perl.  At the
time Emacs was designed in the 1970s,
however, Lisp was about the only language that had the characteristics
(including unlimited-extent types and garbage collection) to fit it to
the job.
</p>
<p>
  Much in the particulars of the way
  <em>emacs</em> handles event processing and drives a
bitmapped display (including the support for internationalization) is
accidental as well.  The one great schism in its history (the GNU
Emacs/XEmacs fork) was over these issues, and demonstrates that
nothing in the rest of the design prefers or requires any one event
model.
</p>
<p>
  On the other hand, the ability to bind arbitrary event
sequences to arbitrary built-in or user-defined functions is
indispensable.  The scripting language could change and the event model
could change, but without the anything-goes polymorphism in the way
they are connected, the Emacs design would
be both unrecognizable and crippled.  Extension modes would have
to fight each other for ownership of a limited event set, and
activating multiple cooperating modes on the same buffer would
be difficult or impossible.
</p>
<p>
  The huge library of extension modes shipped with
Emacs is accidental as well.  The
  <em>ability</em>
  to construct such extensions may be
essential, but the particular set we have is a product of history and
chance. They could all be different or replaced; the result would
still, recognizably, be Emacs.
</p>
<p>
  But subprocess interaction is indispensable.  Without it,
Emacs modes could not perform the expected
IDE-like integration and front-ending of many different tools.
</p>
<p>
  Experience with small editors that clone the default keybindings
and appearance of Emacs without emulating
its extensibility is instructive.  There have been several such
clones, of which the best known are probably
  <em>MicroEmacs</em> and
  <em>pico</em>, but none have ever acquired
significant mindshare.
</p>
<p>
  Having identified accident and essence in the
Emacs design helps us get a handle on which
of its complexity is optional and which accidental. But, more
importantly, they help us see past the superficial differences between
Emacs and the previous three editors we
have considered, to the really critical difference: the fact that the
objectives of the Emacs design are far more
broad.  Emacs wants to be a unified
interface to all tools that operate on text.
</p>
<p>
  Wily makes an interesting contrast with Emacs.  As with Sam, the
amount of optional complexity is low; the Wily user interface can be
succinctly but effectively described in a single page.
</p>
<p>
  But this elegance comes with a price; it is not possible to bind
functions to any keystrokes or input gestures other than a restricted
set of mouse chords.  Instead, every editor function other than very
basic text insertion and deletion has to be implemented with a program
outboard of the editor, either a standalone script or a specialized
symbiont process listening to Wily input events.  (The former
technique relies on outboard program startups being fast enough not to
produce noticeable interface lag, something which was emphatically not
the case in either Emacs's natal environment or under the Unixes it
was first ported to.)
</p>
<p>
  Optional complexity which Emacs would
implement in Lisp extension modes is instead distributed through
specialized symbionts; each has to know the special
Wily messaging interface. An advantage of
this approach is that such symbionts can be written in any language
the user chooses. In addition, the symbionts (because they run
outboard) cannot adversely affect each other or the
Wily core (which is not true of
Emacs modes). A disadvantage is that
Wily itself cannot directly do subprocess
interaction with ordinary Unix tools at all.
</p>
<p>
  In this and other ways,
  <em>wily's</em> distributed scripting is not as powerful as the embedded scripting of
Emacs.  The scope of Wily's objectives is correspondingly narrower;
the authors disclaim any interest in syntax-aware editing, or rich
text, for example, and neither Wily nor its Plan 9 ancestor
  <em>acme</em> can do these things.
</p>
<p>
  This brings us to another, and sharper way of posing the central
question of this chapter: When do large objectives justify a large
program?
</p>
<h4 id="id2967642"><a href="#id2967642">§</a>Compromise Doesn't Work</h4>
<p>
  The comparison between Sam and vi suggests strongly that, at
least where editors are concerned, attempts to compromise between the
minimalism of ed and the all-singing-all-dancing comprehensiveness of
Emacs don't work very well; vi attempts this, and ends up with neither
virtue.  Instead, it falls into an adhocity trap. Wily avoids the
adhocity trap, but cannot match the power of Emacs and must demand a
custom process interface from each of its interactive symbionts in
order to come anywhere close.
</p>
<p>
  Evidently something about editors tends to push them in the
direction of increasing complexity. In the case of
vi, that something is not hard to identify;
it's the desire for convenience.  While ed
may be theoretically adequate, very few people (other than perhaps Ken
Thompson himself) would forgo screen-oriented editing to make a
statement about software bloat.
</p>
<p>
  More generally, programs that mediate between the user and the
rest of the universe notoriously attract features.  This includes not
just editors but Web browsers, mail and newsgroup readers, and other
communications programs.  All tend to evolve in accordance with the
Law of Software Envelopment, aka Zawinski's Law: “Every program
attempts to expand until it can read mail. Those programs which cannot
so expand are replaced by ones which can”.
</p>
<p>
  Jamie Zawinski, inventor of the Law (and one of the principal
authors of the Netscape and Mozilla Web browsers), maintains more
generally that all really useful programs tend to turn into Swiss Army
knives. The commercial success of large, integrated application suites
outside the Unix world tends to confirm this, and directly challenges
the Unix philosophy of minimalism.
</p>
<p>
  To the extent Zawinski's Law is correct, it suggests that some
things want to be small and some want to be large, but the middle
ground is unstable.  The superficial problems with
vi can be put down to history, but the
deeper ones trace back to the combination of steady pressure to add
features with refusal to embed the scripting and subprocess-control
features that vi partisans associate with
excessive size.  On a different level, accepting that there would 
be two modes in the interface (insertion versus character-motion)
opened a can of worms — it became far too easy to add new
commands without thinking about their complexity impact on the
overall design.
</p>
<p>
  The examples of Emacs and
Wily further suggest
  <em>why</em>
  some things want to be large: so that several
related tasks can share context.  Editing and version control (or
editing and mail, editing and symbolic debugging, etc.) are separate
tasks from the point of view of the implementers — but users
would often prefer to have one big environment that lets them point at
pieces of text, rather than spend time and attention ping-ponging
between several programs that each have to have the same filename or
the contents of some cut buffer handed to them.
</p>
<p>
  More generally, let's suppose we view the entire Unix
environment as a single work of design by community.  Then the religion
of “small, sharp tools”, the pressure to keep interface
complexity and codebase size down, may lead right to a manularity trap
— the user has to maintain all the shared context himself,
because the tools won't do it for him.
</p>
<p>
  Returning to the specific context of editors, Sam shows us that
vi is the wrong thing.  Wily is a valiant
effort to avoid the vastness of Emacs that falls short because it
can't be syntax-aware.  But Wily, or some
realization of the Emacs design ideas cleaned up and stripped of
historical baggage, might be the right thing.  The value of optional
complexity depends on the objectives you choose, and the ability to
share context among all the text-oriented tools related to a task is
valuable.
</p>
<h4 id="id2967765"><a href="#id2967765">§</a>Is Emacs an Argument against the Unix Tradition?</h4>
<p>
  The traditional Unix view of the world, however, is so attached
to minimalism that it isn't very good at distinguishing between the
adhocity-trap problems of vi and the
optional complexity of Emacs.
</p>
 <blockquote>
  <p>
   The reason that vi and emacs never caught on among old-school
Unix programmers is that they are
   <em>ugly</em>.
This complaint may be “old Unix” speaking, but had it not
been for the singular taste of old Unix, “new Unix” would
not exist.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  Attacks on Emacs by vi users — along with attacks on vi by
the hard-core old-school types still attached to ed — are
episodes in a larger argument, a contest between the exuberance of
wealth and the virtues of austerity.  This argument correlates with
the tension between the old-school and new-school styles of
Unix.
</p>
<p>
  The “singular taste of old Unix” was partly a
consequence of poverty in exactly the same way that Japanese
minimalism was — one learns to do more with less most effectively
when having more is not an option.  But Emacs (and new-school Unix,
reinvented on powerful PCs and fast networks) is a child of wealth.
</p>
 <blockquote>
  <p>
   As, in a different way, was old-school Unix.  Bell Labs had enough
resources so that Ken was not confined by demands to have a
product yesterday.  Recall Pascal's apology for writing a long
letter because he didn't have enough time to write a short one.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  Ever since, Unix programmers have maintained a tradition that
exalts the elegant over the excessive.
</p>
<p>
  The vastness of Emacs, on the other
hand, did not originate under Unix, but was invented by Richard
M. Stallman
  within a very different culture that
flourished at the MIT Artificial Intelligence Lab in the 1970s.  The
MIT AI lab was one of the wealthiest corners of computer-science
academia; people learned to treat computing resources as cheap,
anticipating an attitude that would not be viable elsewhere until
fifteen years later. Stallman was unconcerned with minimalism;
he sought the maximum power and scope for his code.
</p>
<p>
  The central tension in the Unix tradition has always been
between doing more with less and doing more with more.  It recurs in a
lot of different contexts, often as a struggle between designs that
have the quality of clean minimalism and others that choose expressive
range and power even at the cost of high complexity.  For both sides,
the arguments for or against Emacs have
exemplified this tension since it was first ported to Unix in the
early 1980s.
</p>
<p>
  Programs that are both as useful and as large as
Emacs make Unix programmers uncomfortable
precisely because they force us to face the tension.  They suggest
that old-school Unix minimalism is valuable as a discipline, but
that we may have fallen into the error of dogmatism.
</p>
<p>
  There are two ways Unix programmers can address this problem.
One is to deny that large is actually large. The other is to develop
a way of thinking about complexity that is not a dogma.
</p>
<p>
  Our thought experiment with replacing Lisp and the extension
libraries gives us a new perspective on the oft-heard charge that
Emacs is bloated because its extension
library is so large.  Perhaps this is as unfair as charging that
  <em>/bin/sh</em> is bloated because the collection
of all shellscripts on a system is large.
Emacs could be considered a virtual machine
or framework around a collection of small, sharp tools (the modes)
that happen to be written in Lisp.
</p>
<p>
  On this view, the main difference between the shell and
Emacs is that Unix distributors don't ship
all the world's shellscripts along with the shell.  Objecting to
Emacs because having a general-purpose
language in it feels like bloat is approximately as silly as refusing
to use shellscripts because shell has conditionals and for loops.
Just as one doesn't have to learn shell to use shellscripts, one
doesn't have to learn Lisp to use Emacs.  If
Emacs has a design problem, it's not so
much the Lisp interpreter (the framework part) as the fact that the
mode library is an untidy heap of historical accretions — but
that's a source of complexity users can ignore, because they won't be
affected by what they don't use.
</p>
<p>
  This mode of argument is very comforting.  It can be applied to
other tool-integration frameworks, such as the (uncomfortably large)
GNOME and KDE desktop projects.  There is some force to it.
And yet, we should be suspicious of any ‘perspective’ that
offers to resolve all our doubts so neatly; it might be a
rationalization, not a rationale.
</p>
<p>
  Therefore, let's avoid the possibility of falling into denial
and accept that Emacs is both useful
and large — that it
  <em>is</em>
  an argument against
Unix minimalism.  What does our analysis of the kinds of complexity in
it, and the motives for it, suggest beyond that?  And is there reason
to believe that those lessons generalize?
</p>



<!-- FILE: ch13s04.html -->
<h3 id="ch13s04"><a href="#ch13s04">§</a>The Right Size of Software</h3>
<p>
  There is a hidden dual of the Unix gospel of small, sharp tools;
a background so implicit that many Unix practitioners do not notice 
it, any more than fish notice the water they swim in.  It is the
presence of frameworks.
</p>
<p>
  Small, sharp tools in the Unix style have trouble sharing data,
unless they live inside a framework that makes communication among
them easy. Emacs is such a framework, and
  <em>unified management of shared context</em>
  is what the
optional complexity of Emacs is buying.
The practical impact of unified management of shared context is that
the user is not burdened with low-level naming and resource-management
issues.
</p>
<p>
  In old-school Unix, the only framework was pipelines,
redirection, and the shell; the integration was done with scripts, and
the shared context was (essentially) the file system itself.  But that
was not the end of evolution.
</p>
<p>
  Emacs unifies the file system with a world of text buffers and
helper processes, largely leaving the shell framework behind.  Wily is
also about buffers and helpers, but incorporates the shell framework
into itself. Modern desktop environments provide a communication
framework for GUIs, also leaving the shell framework behind.  Each
framework has strengths and weaknesses of its own.  Frameworks become
homes to ecologies of tools — the shell to shellscripts, Emacs
to Lisp modes, and desktop environments to flocks of GUIs
communicating both via drag and drop and by more esoteric means such
as object brokers.
</p>
<p>
  This suggests a Rule of Minimality:
  <em>
   Choose the shared
context you want to manage, and build your programs as small as those
boundaries will allow.
</em>
  This is “as simple as
possible, but no simpler”, but it focuses attention on the
choice of shared context.  It applies not just to frameworks, but
to applications and program systems.
</p>
<p>
  It is, however, all too easy to get sloppy about how large your
shared context needs to be. The pressure behind Zawinski's Law is the
tendency of applications to want to share context for convenience.
It's easy to end up carrying around too much weight, too many
assumptions, and to write programs that are over-complex, bloated, and
huge.  The paradigmatic example in the 1990s was the way that the
mailto: URL induced the growth of huge mail clients
embedded in Web browsers.
</p>
<p>
  The corrective to this tendency comes straight from the
old-school Unix hymnbook.  It is the Rule of Parsimony:
  <em>
   Write a big program only when it is clear by demonstration
that nothing else will do
</em>
  —that is, when attempts to
partition the problem have been made and failed. This maxim implies an
astringent skepticism about large programs, and a strategy for
avoiding them: look for the small-program solution first. If a single
small program won't do the job, try building a toolkit of cooperating
small programs within an existing framework to attack it. Only if both
approaches fail are you free (in the Unix tradition) to build a large
program (or a new framework) without feeling you have failed the
design challenge.
</p>
<p>
  When you do write a framework, remember the Rule of Separation.
Frameworks should be mechanism, and have as little policy as possible.
In most cases, that is no policy at all. Factor as much behavior as
possible into modules that use the framework.  One of the benefits of
writing or reusing a framework is that it can help you separate what
would otherwise be big lumps of policy into separate modules, modes,
or tools — pieces that can be usefully recombined with
others.
</p>
<p>
  These rules are valuable heuristics, but the tension at the
heart of the Unix tradition does not resolve neatly into a set of
  <span class="foreignphrase">
   <em>a-priori</em> </span>
  prescriptions for optimal size
of any given project.  Circumstances alter cases, and exercising good
judgment and good taste is what software designers are for.  As in
Soto Zen, the journey
  <em>is</em>
  the destination;
enlightenment has to be rediscovered in every day of practice.
</p>



<!-- FILE: implementation.html -->
<h2 id="implementation"><a href="#implementation">§</a>Implementation</h2>


<!-- FILE: languageschapter.html -->
<h3 id="languageschapter"><a href="#languageschapter">§</a>Chapter 14. Languages</h3>
 <blockquote class="epigraph">
  <p>
   The limits of my language are the limits of my world.
  </p>
  <span>
   – Ludwig Wittgenstein

Tractatus Logico-Philosophicus 5.6, 1918
  </span>
 </blockquote>



<!-- FILE: ch14s01.html -->
<h3 id="ch14s01"><a href="#ch14s01">§</a>Unix's Cornucopia of Languages</h3>
<p>
  Unix supports a wider variety of application languages than does
any other single operating system; indeed, it may well have hosted
more different languages than every other operating system in the
history of computing combined.<sup><a href="#ftn.id2970798" id="id2970798">[122]</a></sup>
</p>
<p>
  There are at least two excellent reasons for this huge
diversity. One is the wide use of Unix as a research and teaching
platform. The other (far more relevant for working programmers) is the
fact that matching your application design with the proper
implementation language(s) can make an immense difference in your
productivity. Therefore the Unix tradition encourages the design of
domain-specific languages (as we mentioned in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  and
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>) and what are now generally
called
  <em>scripting languages</em> —those designed specifically to
glue together other applications and tools.
</p>
 <blockquote>
  <p>
   The term “scripting language” probably derives from
the term “script” that was applied to a potted input for
a normally interactive program, in particular sh or ed — a much
more felicitous term than the “runcom” we inherited from
Unix's ancestor CTSS.
“Script” appears in the V7 manual (1979).  I don't recall
who coined the name.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  In truth, the term ‘scripting language’ is a
somewhat awkward one.  Many of the the major languages usually so
described (Perl, Tcl, Python, etc.) have outgrown the group's
scripting origins and are now standalone general-purpose programming
languages of considerable power.  The term tends to obscure strong
similarities in style with other languages that are not usually lumped
in with this group, notably Lisp and Java.  The only argument for
continuing to use it is that nobody has yet invented a better
term.
</p>
<p>
  Part of the reason all these can be lumped together under the
rubric of ‘scripting language’ is that they all have
pretty much the same ontogeny.  Having a runtime to do interpretation
also makes it relatively easy to automate dynamic storage management.
Automating dynamic storage management almost requires using references
(opaque memory addresses that you can't do arithmetic on) rather than
passing value copies or explicit pointers around.  Using references
makes runtime polymorphism and OO an easy next step.
  <span class="foreignphrase">
   <em>Voila:</em> </span>
  the modern scripting
language!
</p>
<p>
  To apply the Unix philosophy effectively, you'll need to have
more than just C
  in your
toolkit. You'll need to learn how to use some of Unix's other
languages (especially the scripting languages), and how to be comfortable
mixing multiple languages in specialist roles within large program
systems.
</p>
<p>
  In this chapter we'll survey C and its most important
alternatives, discussing their strengths and weaknesses and the
sorts of tasks to which they are best matched. The languages
covered will be C, C++, shell, Perl, Tcl, Python, Java, and Emacs
Lisp. Each survey section will include case studies on applications
written using these languages, and references to other examples and
tutorial material. High-quality implementations of all these
languages are available in open source on the Internet.
</p>
<p>
  Warning: Choice of application language is one of the archetypal
religious issues in the Internet/Unix world. People get very attached
to these tools and will sometimes defend them past all reason. If this
chapter achieves its aim, zealots of all stripes may be offended by
this chapter, but everyone else will learn from it.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2970798" id="ftn.id2970798">[122]</a></sup>
  See the
  <a href="ftp://ftp.idiom.com/pub/compilers-list/free-compilers">
   Free
Compiler and Interpreter List</a>
  for
details.
</p>
</div>


<!-- FILE: why_not_c.html -->
<h3 id="why_not_c"><a href="#why_not_c">§</a>Why Not C?</h3>
<p>
  C is the native language of Unix. Since the early 1980s it has
come to dominate systems programming almost everywhere in the computer
industry. Outside of Fortran's dwindling niche in scientific and
engineering computing, and excluding the vast invisible dark mass of
COBOL financial applications at banks and insurance companies, C and
its offspring C++ have now (in 2003) dominated applications
programming almost completely for more than a decade.
</p>
<p>
  It may therefore seem perverse to assert that C and C++ are
nowadays almost always the wrong vehicle for beginning new
applications development. But it's true; C and C++ optimize for
machine efficiency at the expense of increased implementation and
(especially) debugging time. While it still makes sense to write
system programs and time-critical kernels of applications in C or C++,
the world has changed a great deal since these languages came to
prominence in the 1980s.  In 2003, processors are a thousand
times faster, memories are a thousand times larger, and disks are a
factor of
  <em>ten</em>
  thousand larger, for roughly
constant dollars.<sup><a href="#ftn.id2971041" id="id2971041">[123]</a></sup>
</p>
<p>
  These plunging costs change the economics of programming in a
fundamental way.  Under most circumstances it no longer makes sense
to try to be as sparing of machine resources as C permits.  Instead,
the economically optimal choice is to minimize debugging time and
maximize the long-term maintainability of the code by human beings.
Most sorts of implementation (including application prototyping) are
therefore better served by the newer generation of interpreted and
scripting languages.  This transition exactly parallels
the conditions that, last time around the wheel, led to the rise of
C/C++ and the eclipse of assembler programming.
</p>
<p>
  The central problem of C and C++ is that they require
programmers to do their own memory management — to declare
variables, to explicitly manage pointer-chained lists, to dimension buffers,
to detect or prevent buffer overruns, and to allocate and deallocate
dynamic storage.  Some of this task can be automated away by
unnatural acts like retrofitting C with a garbage collector such as
the Boehm-Weiser implementation, but the design of C is such that this
cannot be a complete solution.
</p>
<p>
  C memory management is an enormous source of complication and
error. One study (cited in <sup><a href="#Boehm" title="[Boehm]">[Boehm]</a></sup>)
estimates that 30% or 40% of development time is devoted to storage
management for programs that manipulate complex data structures.  This
did not even include the impact on debugging cost.  While hard figures
are lacking, many experienced programmers believe that
memory-management bugs are the single largest source of persistent
errors in real-world code.<sup><a href="#ftn.id2968237" id="id2968237">[124]</a></sup>
  Buffer overruns are a
common cause of crashes and security holes.  Dynamic-memory management
is particularly notorious for spawning insidious and hard-to-track
bugs, such as memory leaks and stale-pointer problems.
</p>
<p>
  Not so long ago, manual memory management made sense anyway.
But there are no ‘small systems’ any more, not in
mainstream applications programming. Under today's conditions, an
implementation language that automates away memory management (and
buys an order of magnitude decrease in bugs at the expense of using a
bit more cycles and core) makes a lot more sense.
</p>
<p>
  A recent paper <sup><a href="#Prechelt" title="[Prechelt]">[Prechelt]</a></sup>
musters an impressive array of statistical evidence for a claim that
programmers with experience in both worlds will find very plausible:
programmers are just about twice as productive in scripting
languages
  as they are in C or C++. This accords well with the 30%–40% penalty
estimate noted earlier, plus debugging overhead.  The performance
penalty of using a scripting language
  is very often insignificant for
real-world programs, because real-world programs tend to be limited by
waits for I/O events, network latency, and cache-line fills rather
than by the efficiency with which they use the CPU itself.
</p>
<p>
  The Unix world has been slowly coming around to this point of
view in practice, especially since 1990 or so, as is shown by the
increasing popularity of Perl and other scripting languages. But the
evolution of practice has not yet (as of mid-2003) led to a
wholesale change in conscious attitudes; many
Unix programmers are still absorbing the lesson
Perl
  and
Python
  have
been teaching.
</p>
<p>
  We can see the same trend happening, albeit more slowly, outside
the Unix world — for example, in the continuing shift from C++
to Visual Basic evident in applications development under Microsoft
Windows and NT, and the move toward
Java
  in the
mainframe world.
</p>
<p>
  The arguments against C and C++ apply with equal force to other
conventional compiled languages such as Pascal, Algol, PL/I, FORTRAN,
and compiled Basic dialects. Despite occasional heroic efforts such as
Ada, the differences between conventional languages remain superficial
when set against their basic design decision to leave memory
management to the programmer.  Though high-quality open-source
implementations of most languages ever written are available under
Unix, no other conventional languages remain in widespread use in the
Unix or Windows worlds; they have been abandoned in favor of C and
C++.  Accordingly we will not survey them here.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2971041" id="ftn.id2971041">[123]</a></sup>
  Outside the Unix world, this
three-orders-of-magnitude improvement in hardware performance has been
masked to a significant extent by a corresponding drop in software
performance.
</p>

<p><sup><a href="#id2968237" id="ftn.id2968237">[124]</a></sup>
  The severity of this problem
is attested to by the rich slang Unix programmers have developed for
describing different varieties: ‘aliasing bug’,
‘arena corruption’, ‘memory leak’,
‘buffer overflow’, ‘stack smash’,
‘fandango on core’, ‘stale pointer’,
‘heap trashing’, and the rightly dreaded ‘secondary
damage’.  See the
  <a href="http://www.catb.org/~esr/jargon">
   Jargon
File</a>
  for elucidation.
</p>
</div>


<!-- FILE: ch14s03.html -->
<h3 id="ch14s03"><a href="#ch14s03">§</a>Interpreted Languages and Mixed Strategies</h3>
<p>
  Languages that avoid manual memory management do it by having a
memory manager built into their runtime executable somewhere.
Typically, runtime environments in these languages are split into a
program part (the running script itself) and the interpreter part,
with the interpreter managing dynamic storage. On Unixes (and other
modern operating systems) the interpreter core can be shared by
multiple program parts, reducing the effective overhead for each
one.
</p>
<p>
  Scripting is nowhere near a new idea
in the Unix world. As far back as the mid-1970s, in an era of far
smaller machines, the Unix shell (the interpreter for commands typed
to a Unix console) was designed as a full interpreted programming
language. It was common even then to write programs entirely in
shell, or
to use the shell to write glue logic that knit together canned
utilities and custom programs in C into wholes greater than the sum of
their parts. Classical introductions to the Unix environment (such as
  <em>The Unix Programming Environment</em> <sup><a href="#Kernighan-Pike84" title="[Kernighan-Pike84]">[Kernighan-Pike84]</a></sup>) have dwelt
heavily on this tactic, and with good reason: it was one of Unix's
most important innovations.
</p>
<p>
  Advanced shell programming mixes languages freely, employing
both binaries and interpreted elements from half a dozen or more
other languages for subtasks. Each language does what it does best,
each component is a module with narrow interfaces to the others,
and the global complexity of the whole is much lower than it would
be had it been coded as a single monster monolith in a general-purpose
language.
</p>



<!-- FILE: ch14s04.html -->
<h3 id="ch14s04"><a href="#ch14s04">§</a>Language Evaluations</h3>
<p>
  Mixing languages is a knowledge-intensive (rather than coding-intensive)
style of programming. To make it work, you have to have both
working knowledge of a suitable variety of languages and expertise
about what they're best at and how to fit them together. In this
section, we will try to point you at references to help you with the
first and an overview to convey the second. For each language
surveyed we will include case studies of successful programs that
exemplify its strengths.
</p>
<h4 id="c_language"><a href="#c_language">§</a>C</h4>
<p>
  Despite the memory-management problem, there are some
application niches for which C is still king. Programs that require maximum speed, have
real-time requirements, or are tightly coupled to the OS kernel are
good candidates for C.
</p>
<p>
  Programs that must be portable across multiple operating systems
may also be good candidates for C. Some of the alternatives to C that
we shall discuss below are, however, increasingly penetrating major
non-Unix operating systems; in the near future, portability may be less a
distinguishing advantage of C.
</p>
<p>
  Sometimes the leverage to be gained from existing programs like
parser generators or GUI builders that generate C code is so great
that it justifies C coding of the rest of a small application.
</p>
<p>
  And, of course, C proved indispensable to the developers of all
its alternatives. Dig down through enough implementation layers
under any of the other languages surveyed here and you will find a
core implemented in pure, portable C. These languages inherit 
many of the advantages of C.
</p>
<p>
  Under modern conditions, it's perhaps best to think of C as a
high-level assembler for the Unix virtual machine (recall the
discussion of the success of C as a case study in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>).  C standards have exported many of the
facilities of this virtual machine, such as the standard I/O library,
to other operating systems.  C is where you go when you want to get as
close as possible to the bare metal but stay portable.
</p>
<p>
  One good reason to learn C, even if your programming needs are
satisfied by a higher-level language, is that it can help you learn to
think at hardware-architecture level.  The best reference and tutorial
on C for people who are already programmers is still
  <em>The C Programming Language</em><sup><a href="#Kernighan-Ritchie" title="[Kernighan-Ritchie]">[Kernighan-Ritchie]</a></sup>.
</p>
<p>
  Porting C code between Unix variants is almost always possible
and usually easy, but specific areas of variation (like
signals and process control) can be tricky to get right.  We
highlight some of these issues in
  <a href="#portabilitychapter" title="Chapter 17. Portability">
   Chapter 17</a>.  Differing C bindings on other
operating systems can of course cause C portability problems, although
Windows NT at least theoretically supports an ANSI/POSIX-compliant C
API.
</p>
<p>
  High-quality C compilers are available as open-source software
over the Internet; the best-known and most widely used is the Free
Software Foundation's GNU C compiler (part of GCC, the GNU Compiler
Collection), which has become the native C of
all open-source Unix systems and many even in the closed-source
world. GCC ports are even available for
Microsoft's
  family of operating systems. GCC sources
are available at the FSF's
  <a href="ftp://ftp.gnu.org/pub/gnu">
   FTP
site</a>.
</p>
<p>
  Summing up: C's best side is resource efficiency and
closeness to the machine.  Its worst side is that programming 
in it is a resource-management hell.
</p>
<h5 id="fetchmail"><a href="#fetchmail">§</a>
  C Case Study:
fetchmail
 </h5>
<p>
  The best case study for C is the Unix kernel itself, for which a
language that naturally supports hardware-level operations is
actually a strong advantage. But
  <em>fetchmail</em> is a good example of the kind of
user-land utility that is still best coded in C.
</p>
<p>
  <em>fetchmail</em> does only the simplest kind
of dynamic-memory management; its only complex data structure is a
singly-linked list of per-mailserver control blocks built just once,
at startup time, and changed only in fairly trivial ways
afterwards. This substantially erodes the case against using C by
sidestepping C's greatest weakness.
</p>
<p>
  On the other hand, these control blocks are fairly complex
(including all of string, flag, and numeric data) and would be
difficult to handle as coherent fast-access objects in an
implementation language without an equivalent of the C struct
feature. Most of the alternatives to C are weaker than C in this
respect (Python
  and Java
  being notable exceptions).
</p>
<p>
  Finally,
  <em>fetchmail</em> requires the
ability to parse a fairly complex specification syntax for
per-mail-server control information. In the Unix world this sort of
thing is classically handled by using C code generators that grind out
source code for a tokenizer and grammar parser from declarative
specifications. The existence of
  <em>yacc</em> and
  <em>lex</em> was a point in favor of C.
</p>
<p>
  <em>fetchmail</em> might reasonably have been coded in
Python,
albeit with possibly significant loss of performance. Its size and
data-structure complexity would have excluded shell and
Tcl
  right off
and strongly counterindicated Perl, and the application domain is outside
the natural scope of Emacs Lisp. A Java
  implementation wouldn't have been an
unreasonable path, but Java's object-oriented style and garbage
collection would have offered little purchase on
  <em>fetchmail</em> 's specific problems over what
C
  already
yields. Nor could C++
  have done much to simplify the
relatively simple internal logic of
  <em>fetchmail</em>.
</p>
<p>
  However, the real reason
  <em>fetchmail</em> is
a C program is that it evolved by gradual mutation from an ancestor
already written in C.  The existing implementation has been
extensively tested on many different platforms and against many odd
and quirky servers.  Carrying all that implicit knowledge through to a
re-implementation in a different language would be messy and
difficult.  Furthermore,
  <em>fetchmail</em> depends
on imported code for functions (like NTLM authentication) that don't
seem to be available above C level.
</p>
<p>
  <em>fetchmail</em> 's interactive configurator,
which did not have a C legacy problem, is written in Python; we'll
discuss that case along with that language.
</p>
<h4 id="cc_language"><a href="#cc_language">§</a>C++</h4>
<p>
  When C++ was first released to the world in the mid-1980s
object-oriented (OO)
  languages were being widely touted
as the silver bullet for the software-complexity problem. C++'s OO
features appeared to be an overwhelming advantage over the ancestral
C, and partisans expected that it would rapidly make the older
language obsolete.
</p>
<p>
  This has not happened. Part of the fault can be laid to problems
in C++ itself; the requirement that it be backward-compatible with C
forced a great many compromises on the design.  Among other things,
that requirement prevented C++ from going to fully automatic
dynamic-memory management and addressing C's most serious problem.
Later, feature arms races between different compiler implementers,
unconstrained by a weak and premature standardization effort, pushed
C++ to become rather baroque and excessively complicated.
</p>
<p>
  Another part of the fault must be laid to the failure of
OO
  itself
to live up to expectations.  We examined this problem in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>, observing the tendency of OO methods to
lead to thick glue layers and maintenance problems.  Today
(2003), inspection of open-source archives (in which choice of
language reflects developers' judgments rather than corporate
mandates) reveals that C++ usage is still heavily concentrated in GUIs,
multimedia toolkits and games (the major success areas for OO
design), and little used elsewhere.
</p>
<p>
  It may be that C++'s realization of OO
  is particularly problem-prone. There
is some evidence that C++ programs have higher life-cycle costs than
equivalents in C, FORTRAN, or Ada. Whether this is a problem with
OO
  or
specifically with C++ or both remains unclear, though there is reason
to suspect both are implicated <sup><a href="#Hatton98" title="[Hatton98]">[Hatton98]</a></sup>.
</p>
<p>
  In recent years, C++ has incorporated some important non-OO ideas.  It has exceptions similar to those in Lisp; that
  is, it is possible to throw an object or value up the call stack until it is caught by a handler.  STL (Standard
  Template Library) provides generic programming; that is, it is possible to code algorithms that are independent of the
  type signature of their data and have them compiled to do the right thing at runtime. (Only languages that do
  compile-time static type-checking need this; more dynamic languages simply pass around typeless references and support
  type identification at runtime.)
</p>
<p>
  Efficient compiled language; upward-compatible with C;
object-oriented platform; vehicle for cutting-edge techniques like STL
and generics — C++ tries to be all things to all people, but the cost
is more complexity than the mind of any individual programmer can
handle. As we noted in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>, the language's principal designer has
conceded that he doesn't expect any one programmer to grasp it
all. Unix hackers do not react well to this; one anonymous but famous
characterization is “C++: an octopus made by nailing extra legs
onto a dog”.
</p>
<p>
  When all is said and done, however, C++'s most fundamental
problem is that it is basically just another conventional language. It
confines the memory-management problem better than it did before the
invention of the Standard Template Library, and a lot better than C
does, but the confinement is brittle; it breaks unless your code
uses objects and only objects. For many types of application its
OO
  features are not significant, and simply add complexity to C without
yielding much advantage. Open-source C++ compilers are available; if
C++ were unequivocally superior to C it would now dominate.
</p>
<p>
  Summing up: C++'s best side is its combination of compiled
efficiency with facilities for OO
  and generic programming.  Its worst
side is that it is baroque and complex, and tends to encourage
over-complex designs.
</p>
<p>
  Consider using C++ if an existing C++ toolkit or service library
offers powerful leverage for your application, or if you're in one of
the application areas mentioned above for which an
OO
  language is known to be a large win.
</p>
<p>
  The classic C++ reference is Stroustrup's
  <em>The C++ Programming Language</em><sup><a href="#Stroustrup" title="[Stroustrup]">[Stroustrup]</a></sup>. You will find an excellent
beginner's tutorial on C++ and basic OO methods in
  <em>C++: A Dialog</em><sup><a href="#Heller" title="[Heller]">[Heller]</a></sup>.
  <em>C++ Annotations</em> <sup><a href="#Brokken" title="[Brokken]">[Brokken]</a></sup> is a condensed introduction to C++
for expert C programmers.
</p>
<p>
  The Gnu Compiler Collection
  includes a C++ compiler. The language
is therefore universally available on Unix and on
Microsoft
  operating systems; comments made under C
above also apply here.  Strong collections of open-source
  <a href="http://www.boost.org/">
   support libraries</a>
  are available.
However, portability is compromised by the fact that (as of
mid-2003) actual C++ implementations implement widely varying subsets of the
draft ISO standard now in preparation.<sup><a href="#ftn.id2969184" id="id2969184">[125]</a></sup>
</p>
<h5 id="id2969192"><a href="#id2969192">§</a>C++ Case Study: The Qt Toolkit</h5>
<p>
  The Qt interface toolkit is one of the notable C++ success
stories in today's open-source world. It provides a widget set and API
for writing graphical user interfaces under X, one deliberately (and
rather effectively) designed to emulate the visual look and feel of
Motif, MacOS Platinum, or the Microsoft
Windows
  interface.  Qt actually provides more
than just GUI services; it also provides a portable application layer,
with classes for XML, file access, sockets, threads, timers, time/date
handling, database access, various abstract data types, and
Unicode.
</p>
<p>
  The Qt toolkit is a critical and visible component of the KDE
project, the senior of the open-source world's two efforts to
produce a competitive GUI and integrated set of desktop
productivity tools.
</p>
<p>
  Qt's C++ implementation exhibits the strengths of an
OO
  language for encapsulating user-interface components. In a language
supporting objects, a visual hierarchy of interface widgets can be
cleanly expressed in the code by a hierarchy of class instances. While
this sort of thing can be simulated in C
  with explicit indirection through
hand-rolled method tables, such code is much cleaner in C++.
Comparison with the notoriously baroque C API of Motif is
instructive.
</p>
<p>
  The Qt source code and reference documentation are available at the
  <a href="http://www.trolltech.com/">
   Trolltech site</a>.
</p>
<h4 id="sh"><a href="#sh">§</a>Shell</h4>
<p>
  The ‘Bourne shell’ (
  <em>sh</em>)
of Version 7 Unix was Unix's first (and for many years its only)
portable interpreted language. Today the ancestral Bourne shell has
largely been displaced by variants of the upward-compatible Korn
Shell
  (
  <em>ksh</em>); the single most important of these
is the Bourne Again Shell, bash.
</p>
<p>
  A few other shells exist and are used interactively, but are not
significant as programming languages; of these, the best known is
probably the C shell
  <em>csh</em>, which is
notoriously<sup><a href="#ftn.id2969353" id="id2969353">[126]</a></sup>
  unsuitable for writing
scripts.
</p>
<p>
  Simple shell programs are extremely easy and natural to write.
The Unix tradition of rapid prototyping in interpretive languages
began with shell.
</p>
 <blockquote>
  <p>
   I wrote the very first version of netnews as a 150-line
shellscript.  It had multiple newsgroups and cross-posting;
newsgroups were directories and cross-posting was implemented
as multiple links to the article.  It was far too slow to
use for production, but the flexibility permitted endless
experimentation with the protocol design.
  </p>
  <span>
   – Steven M. Bellovin
  </span>
 </blockquote>
<p>
  As program size gets larger, however, they tend to become rather
ad-hoc. Some parts of shell syntax (notably its quoting and
statement-syntax rules) can be very confusing. These drawbacks
generally relate to compromises in the programming-language part of
the shell's design made to preserve its utility as an interactive
command-line interpreter.
</p>
<p>
  Programs are described as being ‘in shell’ even when
they are not pure shell but include heavy use of
C
  filters like
sort(1)
and of standard text-processing minilanguages like
sed(1)
or
awk(1). This
sort of programming has been in decline for some years, however;
nowadays such elaborate glue logic is generally written in
Perl
  or
Python, with
shell being reserved for the simplest kinds of wrappers (for which
these languages would be overkill) and system boot-time initialization
scripts (which cannot assume they are available).
</p>
<p>
  Such basic shell programming should be adequately covered in any
introductory Unix book.
  <em>The Unix Programming Environment</em><sup><a href="#Kernighan-Pike84" title="[Kernighan-Pike84]">[Kernighan-Pike84]</a></sup> remains one of
the best sources on intermediate and advanced shell programming.  Korn
shell implementations or clones are present on every Unix.
</p>
<p>
  Complex shellscripts often have portability problems, not so
much because of the shell itself but because they make assumptions
about what other programs are available as components.  While Bourne
and Korn-shell clones have been sporadically available on non-Unix
operating systems, shell programs are not (practically speaking) at
all portable off Unix.
</p>
<p>
  Summing up: shell's best side is that it is very natural and
quick for small scripts.  Its worst side is that large shellscripts
depend on lots of auxiliary commands that aren't necessarily
identically behaved nor even present on all target machines.  Nor
is it easy to analyze the dependencies in a large shellscript.
</p>
<p>
  It is almost never necessary to build or install a shell, since all
Unix systems and Unix emulators come equipped with them.  The standard
shell on Linux
  and other leading-edge Unix variants is
now
  <em>bash</em>.
</p>
<h5 id="xmlto"><a href="#xmlto">§</a>Case Study: xmlto</h5>
<p>
  <em>xmlto</em> is a driver script
that calls all the commands needed to render an XML-DocBook document
as HTML, PostScript, plain text, or in any one of several other
formats (we'll take a closer look at DocBook in
  <a href="#documentationchapter" title="Chapter 18. Documentation">
   Chapter 18</a>).  It is written
in bash.
</p>
<p>
  <em>xmlto</em> handles the details
of calling an XSLT engine with appropriate stylesheet, then handing
off the result to a postprocessor.  For HTML and XHTML the XSLT
transformation does the entire job.  For plain text, the XML is also
processed into HTML, but then handed to a postprocessor —
lynx(1)
in its
  <code>-dump</code> mode, which renders HTML to flat text.
For PostScript, the XML is transformed to XML FO (formatting
objects)
  which a
postprocessor then massages into
  <em>TeX</em> macros, to DVI
  format via
tex(1),
and then finally to PostScript via the well-known
dvi2ps(1)
tool.
</p>
<p>
  <em>xmlto</em> consists of a
single front-end shellscript.  It calls any one of several script
plugins, each named after the target format.  Each plugin is a
shellscript.  Depending on how it's called, it either supplies a
stylesheet for the front end to apply, or calls the appropriate
postprocessor(s) with various canned arguments.
</p>
<p>
  This architecture means that all the information about a given
output format lives in one place (the corresponding script plugin), so
adding new output types can be done without disturbing the front-end
code at all.
</p>
<p>
  <em>xmlto</em> is a good example of a
medium-sized shell application.  Neither C
  nor C++ would have made sense
because they are awkward for scripting.  Any of the other scripting
languages in this chapter could have been used for this job; but it's
all simple command dispatching, with no internal data structures or
complex logic, so shell is good enough. Shell has the significant
advantage of being ubiquitous on the intended target systems.
</p>
<p>
  In theory this script could run on any system supporting
  <em>bash</em>.  The real constraint is the
requirement for one of the XSLT engines and all the postprocessors
needed to be present on the system.  In practice, this script is not
likely to run anywhere but under one of the modern open-source
Unixes.
</p>
<h5 id="id2975671"><a href="#id2975671">§</a>Case Study: Sorcery Linux</h5>
<p>
  Sorcerer GNU/Linux is a Linux
  distribution that you install as a small,
bootable foothold system just powerful enough to run
bash(1)
and a couple of download utilities.  With this code in place, you can
invoke Sorcery, the Sorcerer package system.
</p>
<p>
  Sorcery handles installing, removing, and integrity-checking
software packages.  When you “cast spells”, Sorcery
downloads the source code, compiles it, installs it, and saves a list
of files that were installed (along with a build log and checksums for
all the files).  Installed packages can be “dispelled” or
removed. Package listing and integrity checks are also available.
More details are available at the
  <a href="http://sorcerer.wox.org">
   Sorcery project site</a>.
</p>
<p>
  The Sorcery system is written entirely in shell.  Program
installation procedures tend to be small, simple programs for which
shell is appropriate.  In this particular application, the main
drawback of shell is neutralized because Sorcery's authors can
guarantee that the helper programs they need will be present in the
foothold system.
</p>
<h4 id="perl"><a href="#perl">§</a>Perl</h4>
<p>
  Perl is shell on steroids. It was specifically designed to
replace
awk(1),
and expanded to replace shell as the ‘glue’ for
mixed-language script programming.
  It was first released in 1987.
</p>
<p>
  Perl's strongest point is its extremely powerful built-in
facilities for pattern-directed processing of textual, line-oriented
data formats; it is unsurpassed at this. It also includes far stronger
data structures than shell, including dynamic arrays of mixed element
types and a ‘hash’ or ‘dictionary’ type that
supports convenient and fast lookup of name-value pairs.
</p>
<p>
  Additionally, Perl includes a rather complete and
well-thought-out internal binding of virtually the entire Unix API,
drastically reducing the need for C
  and making it suitable for jobs like
simple TCP/IP
  clients
and even servers. Another strong advantage of Perl is that a large and
vigorous open-source community has grown up around it. Its home on
the net is the
  <a href="http://www.cpan.org">
   Comprehensive Perl
Archive Network</a>. Dedicated Perl hackers have written hundreds
of freely reusable Perl modules for many different programming
tasks. These include everything from structure-walking of directory
trees through X toolkits for GUI building, through excellent canned
facilities for supporting HTTP robots and CGI programming.
</p>
<p>
  Perl's main drawback is that parts of it are irredeemably ugly,
complicated, and must be used with caution and in stereotyped ways
lest they bite (its argument-passing conventions for functions are a
good example of all three problems). It is harder to get started in
Perl than it is in shell. Though small programs in Perl can
be extremely powerful, careful discipline is required to maintain
modularity and keep a design under control as program size
increases. Because some limiting design decisions early in Perl's
history could not be reversed, many of the more advanced features have
a fragile, klugey feel about them.
</p>
<p>
  The definitive reference on Perl is
  <em>Programming Perl</em><sup><a href="#Wall2000" title="[Wall2000]">[Wall2000]</a></sup>. This book has nearly
everything you will ever need to know in it, but is notoriously badly
organized; you will have to dig to find what you want. A more
introductory and narrative treatment is available in
  <em>Learning Perl</em> <sup><a href="#Schwartz-Christiansen" title="[Schwartz-Christiansen]">[Schwartz-Christiansen]</a></sup>.
</p>
<p>
  Perl is universal on Unix systems.  Perl scripts at the same
major release level tend to be readily portable between Unixes
(provided they don't use extension modules). Perl implementations are
available (and even well documented) for the
Microsoft
  family of operating systems and on
MacOS
  as well. Perl/Tk provides cross-platform GUI capability.
</p>
<p>
  Summing up: Perl's best side is as a power tool for small glue
scripts involving a lot of regular-expression grinding.  Its worst
side is that it is ugly, spiky, and nigh-unmaintainable in large
volumes.
</p>
<h5 id="id2975926"><a href="#id2975926">§</a>A Small Perl Case Study: blq</h5>
<p>
  The
  <em>blq</em> script is a tool
for querying block lists (lists of Internet sites that have been
identified as habitual sources of unsolicited bulk email, aka spam).
You can find current sources at the
  <a href="http://www.unicom.com/sw/blq/">
   <em>blq</em> project page</a>.
</p>
<p>
  <em>blq</em> is a good example of
a small Perl script, illustrating both the strengths and weaknesses of
the language. It makes intensive use of regular-expression matching.
On the other hand, the Net::DNS Perl extension module it uses has to
be conditionally included, because it is not guaranteed to be present
in any given Perl installation.
</p>
<p>
  <em>blq</em> is exceptionally
clean and disciplined as Perl code goes, and I recommend it as an
example of good style (the other Perl tools referenced from the
  <em>blq</em> project page are good examples as
well).  But parts of the code are unreadable unless you are familiar
with very specific Perl idioms — the very first line of code,
  <code>$0 =~ s!.*/!!;</code>, is an example.  While all languages
have some of this kind of opacity, Perl has it worse than most.
</p>
<p>
  Tcl
  and
Python
  are
both good for small scripts of this type, but both lack the Perl
convenience features for regular-expression matching that
  <em>blq</em> uses heavily; an implementation in
either would have been reasonable, but probably less
compact
  and
expressive.  An Emacs Lisp
  implementation would have been even
faster to write and more compact than the Perl one, but probably
painfully slow to use.
</p>
<h5 id="id2976082"><a href="#id2976082">§</a>A Large Perl Case Study: keeper</h5>
<p>
  <em>keeper</em> is the tool used to file
incoming packages and maintain both FTP and WWW index files for the
huge Linux
  free-software archives at ibiblio. You
can find sources and documentation in the
  <a href="http://www.ibiblio.org">
   search tools subdirectory of the ibiblio
archive</a>.
</p>
<p>
  <em>keeper</em> is a good example of a
medium-to-large interactive Perl application. The command-line
interface is line-oriented and patterned after a specialized shell or
directory editor; note the embedded help facilities. The working parts
make heavy use of file and directory handling, pattern matching, and
pattern-directed editing. Note the ease with which
  <em>keeper</em> generates Web pages and
electronic-mail notifications from programmatic templates. Note also
the use of a canned Perl module to automate walking various functions
over directory trees.
</p>
<p>
  At about 3300 lines, this application is probably pushing the
size and complexity limit of what one should attempt in a single Perl
program. Nevertheless, most of it was written in a period of six
days. In C,
C++,
  or
Java
  it would
have taken a minimum of six weeks and been extremely difficult to
debug or modify after the fact. It is way too large for pure
Tcl. A
Python
  version would probably be structurally cleaner, more readable, and
more maintainable — but also more verbose (especially near the
pattern-matching parts).  An Emacs Lisp
  mode could readily do the job, but
Emacs is not well suited for use over a
telnet link that is often slowed to a crawl by server
congestion.
</p>
<h4 id="tcl"><a href="#tcl">§</a>Tcl</h4>
<p>
  Tcl (Tool Command Language) is a small language interpreter
designed to link with compiled
C
  libraries, providing
scripted control of C code (
  <em>
   extended
scripts
</em>).  Its original application was to
control libraries for electronic simulators (SPICE-like applications).
Tcl is also suitable for
  <em>embedded scripts</em>
  —that 
is, scripts called from within C programs and returning values to
those programs.  Tcl had its first general public release in
1990.
</p>
<p>
  Some facilities built on top of Tcl have achieved wide use outside
the Tcl community itself. The two most important of these are:
</p>
 <div>
  <ul>
   <li>
    <p>
     The Tk toolkit, a kinder and gentler X interface that makes it
easy to rapidly build buttons, dialog boxes, menu trees, and
scrolling text widgets and collect input from them.
    </p>
   </li>
   <li>
    <p>
     Expect, a language that makes it relatively easy to script
fully interactive programs with widely variable responses.
    </p>
   </li>
  </ul>
 </div>
<p>
  The Tk toolkit is so important that the language is often
referred to as Tcl/Tk. Tk is also frequently used with
Perl
  and
Python.
</p>
<p>
  The main advantage of Tcl itself is that it is extremely
flexible and radically simple. The syntax is very odd (based on a
positional parser) but totally consistent. There are no reserved
words, and there is no syntactic distinction between a function call
and ‘built in’ syntax; thus the Tcl language interpreter
itself can be effectively redefined from within Tcl (which is what
makes projects like
  <em>Expect</em> reasonable).
</p>
<p>
  The main drawback of Tcl is that the pure language has only weak
facilities for namespace control and modularity, and two of them
(<code>upvar</code> and <code>uplevel</code>) are rather
dangerous if not used with great caution. Also, there are no data
structures other than association lists.  Tcl therefore scales up very
poorly — it is difficult to organize and debug pure Tcl programs of
even moderate size (more than a few hundred lines) without tripping
over your own feet. In practice, almost all large Tcl programs use one
of several OO
  extensions to the language.
</p>
<p>
  The oddities of the syntax can at first be a problem as well; the
distinction between string quotes and braces will probably give you
headaches for a while, and the rules for when things need to be quoted
or braced are a bit tricky.
</p>
<p>
  Pure Tcl only provides access to a relatively small
and commonly used part of the Unix API (essentially just file handling,
process-spawning, and sockets). Indeed, Tcl has the flavor of an
experiment in seeing how small a scripting
language
  can get and still be useful.  Tcl extensions (similar to Perl modules)
provide a richer set of capabilities, but are (like CPAN modules) not
guaranteed to be installed everywhere.
</p>
<p>
  The original Tcl reference is
  <em>Tcl and the Tk Toolkit</em><sup><a href="#Ousterhout94" title="[Ousterhout94]">[Ousterhout94]</a></sup>, but that book has
been largely superseded by
  <em>Practical Programming in Tcl and Tk</em><sup><a href="#Welch" title="[Welch]">[Welch]</a></sup>.  Brian Kernighan has written a
description of a real-world Tcl project <sup><a href="#Kernighan95" title="[Kernighan95]">[Kernighan95]</a></sup> that summarizes Tcl's strengths and weaknesses
as a rapid-prototyping and production tool; his contrast with
Microsoft Visual Basic is particularly balanced and
instructive.
</p>
<p>
  The Tcl world doesn't have one central repository run by a core
group analogous to Perl's or Python's, but several excellent
websites both point to each other and cover most Tcl tool and
extension development. Look at the
  <a href="http://www.tcltk.com">
   Tcl Developer Xchange</a>
  first; among
other things, it offers Tcl sources of an interactive Tcl tutorial.
There is also a
  <a href="http://sourceforge.net/foundry/tcl-foundry/">
   Tcl foundry at
SourceForge</a>.
</p>
<p>
  Tcl scripts have portability problems similar to those of shell
scripts; the language itself is highly portable, but the components it
calls may not be.  Tcl implementations exist for the Microsoft family
of operating systems, MacOS, and many other platforms. Tcl/Tk scripts
will run on any platform with GUI capabilities.
</p>
<p>
  Summing up: Tcl's best side is its spare,
compact
  design
and the
extensibility
  of the Tcl interpreter.  Its worst side is the odd positional parser
and the weakness of its data structures and namespace controls; the
latter defect makes it scale poorly for large projects.
</p>
<h5 id="id2976538"><a href="#id2976538">§</a>Case Study: TkMan</h5>
<p>
  <em>TkMan</em> is a browser for Unix man pages
and Texinfo documents.  At roughly 1200 lines, it is quite large to be
written in pure Tcl, but the code is unusually well-modularized and
mature.  It uses Tk to provide a GUI interface quite a bit nicer than
either the stock
man(1)
or
xman(1)
utilities support.
</p>
<p>
  TkMan makes a good case study because it exhibits almost the
full gamut of Tcl techniques.  Highlights include Tk integration, 
scripted control of other Unix applications (such as the Glimpse 
search engine), and the use of Tcl to parse Texinfo markup.
</p>
<p>
  Any of the other languages would have made for a less direct
interface to the Tk GUI that constitutes most of this code.
</p>
<p>
  A Web search for “TkMan” should turn up sources
and documentation.
</p>
<h5 id="id2976607"><a href="#id2976607">§</a>Moodss: A Large Tcl Case Study</h5>
<p>
  The Moodss system is a graphical monitoring application for
system administrators.  It can watch logs and gather statistics for
MySQL, Linux, SNMP networks, and
Apache, and presents a
digested view of them through spreadsheet-like GUI panels called
‘dashboards’. Monitoring modules can be written in
Python
  or
Perl
  as well as
Tcl.  The code is polished, mature, and considered an exemplar in the
Tcl community.  There is a
  <a href="http://jfontain.free.fr/moodss/">
   project website</a>.
</p>
<p>
  The Moodss core consists of about 18,000 lines of Tcl.  It uses
several Tcl extensions including a custom object system; the Moodss author
admits that without these “writing such a big application would 
not have been possible”.
</p>
<p>
  Again, any of the other languages would have made for a less direct
interface to the Tk GUI that constitutes most of this code.
</p>
<h4 id="python_language"><a href="#python_language">§</a>Python</h4>
<p>
  Python is a scripting language
  designed for close integration with
C. It can both
import data from and export data to dynamically loaded C libraries,
and can be called as an embedded scripting language from C. Its syntax
is rather like a cross between that of C and the Modula family, but
has the unusual feature that block structure is actually controlled by
indentation (there is no analog of explicit begin/end or C curly
brackets).  Python was first publicly released in 1991.
</p>
<p>
  The Python language is a very clean, elegant design with
excellent modularity features. It offers designers the option to write
in an object-oriented style but does not force that choice (it can be
coded in a more classically procedural C-like way). It has a type
system comparable in expressive power to
Perl's,
including dynamic container objects and association lists, but less
idiosyncratic (actually, it is a matter of record that
Perl's
  object
system was built in imitation of Python's). It even pleases
Lisp
  hackers
with anonymous lambdas (function-valued objects that can be passed
around and used by iterators). Python ships with the Tk toolkit, which
can be used to easily build GUI interfaces.
</p>
<p>
  The standard Python distribution includes client classes for
most of the important Internet protocols (SMTP, FTP, POP3, IMAP, HTTP)
and generator classes for HTML. It is therefore very well suited to
building protocol robots and network administrative plumbing. It is
also excellent for Web CGI work, and competes successfully with
Perl
  at the
high-complexity end of that application area.
</p>
<p>
  Of all the interpreted languages we describe, Python and
Java
  are the
two most clearly suited for scaling up to large complex projects
with many cooperating developers. In many ways Python is simpler than
Java, and its friendliness to rapid prototyping may give it an edge
over Java for standalone use in applications that are neither hugely
complex nor speed critical. An implementation of Python in Java,
designed to facilitate mixed use of these two languages, is available
and in production use; it is called Jython.
</p>
<p>
  Python cannot compete with C
  or C++
  on raw execution speed (though using a
mixed-language strategy on today's fast processors probably makes that
relatively unimportant). In fact it's generally thought to be the
least efficient and slowest of the major scripting languages, a price
it pays for runtime type polymorphism.  Beware of rejecting Python on
these grounds, however; most applications do not actually need better
performance than Python offers, and even those that appear to are
generally limited by external latencies such as network or disk waits
that entirely swamp the effects of Python's interpretive
overhead. Also, by way of compensation, Python is exceptionally easy
to combine with C, so performance-critical Python modules can be readily
translated into that language for substantial speed gains.
</p>
<p>
  Python loses in expressiveness to
Perl
  for small
projects and glue scripts heavily dependent on regular-expression
capability. It would be overkill for tiny projects, to which
shell
  or
Tcl
  might be
better suited.
</p>
<p>
  Like Perl, Python has a well-established development community
with a
  <a href="http://www.python.org">
   central website</a>
  carrying a great many useful Python implementations, tools and
extension modules.
</p>
<p>
  The definitive Python reference is
  <em>Programming Python</em><sup><a href="#Lutz" title="[Lutz]">[Lutz]</a></sup>. Extensive
on-line documentation on Python extensions is also available at the
Python website.
</p>
<p>
  Python programs tend to be quite portable between Unixes and even
across other operating systems; the standard library is powerful
enough to significantly cut the use of nonportable helper programs.
Python implementations are available for
Microsoft
  operating systems and for
MacOS. Cross-platform GUI development is
possible with either Tk or two other toolkits. Python/C applications
can be ‘frozen’, quasi-compiled into pure C sources that
should be portable to systems with no Python installed.
</p>
<p>
  Summing up: Python's best side is that it encourages clean,
readable code and combines accessibility with scaling up well to large
projects.  Its worst side is inefficiency and slowness, not just
relative to compiled languages but relative to other scripting
languages as well.
</p>
<h5 id="id2976960"><a href="#id2976960">§</a>A Small Python Case Study: imgsizer</h5>
<p>
  Imgsizer is a utility that rewrites WWW pages so that
image-inclusion tags get the right image size parameters
automatically plugged in (this speeds up page loading on many
browsers). You can find sources and documentation in the URL
  <a href="http://www.ibiblio.org">
   WWW tools
subdirectory of the ibiblio archive</a>.
</p>
<p>
  <em>imgsizer</em> was originally written in Perl, and was a nearly ideal example of the sort of small, pattern-driven
  text-processing tool at which Perl excels.  It was later translated to Python to take advantage of Python's library
  support for HTTP fetching; this eliminated a dependency on an external page-fetching utility.  Observe the use of
  file(1) and ImageMagick identify(1) as specialist tools for extracting the pixel sizes of images.
</p>
<p>
  The dynamic string handling and sophisticated regular-expression matching required would have made <em>imgsizer</em>
  quite painful to write in C or C++; that version would also have been much larger and harder to read. Java would have
  solved the implicit memory-management problem, but is hardly more expressive than C or C++ at text pattern matching.
</p>
<h5 id="id2977085"><a href="#id2977085">§</a>A Medium-Sized Python Case Study: fetchmailconf</h5>
<p>
  In <a href="#interfacechapter" title="Chapter 11. Interfaces"> Chapter 11</a> we examined the
  <em>fetchmail</em> / <em>fetchmailconf</em> pair as an example of one way to separate implementation from interface.
  Python's strengths are well illustrated by <em>fetchmailconf</em>. </p> <p> <em>fetchmailconf</em> uses the Tk toolkit
  to implement a multi-panel GUI configuration editor (Python bindings also exist for GTK+ and other toolkits, but Tk
  bindings ship with every Python interpreter).
</p>
<p>
  In expert mode, the GUI supports editing of about sixty
attributes divided among three panel levels. Attribute widgets include
a mix of checkboxes, radio buttons, text fields, and scrolling
listboxes. Despite this complexity, the first fully-functional version
of the configurator took me less than a week to design and code,
counting the four days it took to learn Python and Tk.
</p>
<p>
  Python excels at rapid prototyping of GUI interfaces, and (as
  <em>fetchmailconf</em> illustrates) such prototypes are often deliverable.
Perl
  and
Tcl
  have similar
strengths in this area (including the Tk toolkit, which was written
for Tcl) but are hard to control at the complexity level
(approximately 1400 lines) of
  <em>fetchmailconf</em>. Emacs
Lisp
  is
not suited for GUI programming. Choosing Java
  would have increased the complexity
overhead of this programming task without delivering significant
benefits for this nonspeed-intensive application.
</p>
<h5 id="id2977218"><a href="#id2977218">§</a>A Large Python Case Study: PIL</h5>
<p>
  PIL, the Python Imaging Library, supports the manipulation of
bitmap graphics. It supports many popular formats, including
PNG, JPEG, BMP, TIFF,
PPM, XBM, and GIF. Python programs can use it to convert and transform
images; supported transformations include cropping, rotation, scaling,
and shearing. Pixel editing, image convolution, and color-space
conversions are also supported. The PIL distribution includes Python
programs that make these library facilities available from the
command line. Thus PIL can be used either for batch-mode image
transformation or as a strong toolkit over which to implement
program-driven image processing of bitmaps.
</p>
<p>
  The implementation of PIL illustrates the way Python can be
readily augmented with loadable object-code extensions to the Python
interpreter. The library core, implementing fundamental operations on
bitmap objects, is written in
C
  for speed. The upper
levels and sequencing logic are in Python, slower but much easier to
read and modify and extend.
</p>
<p>
  The analogous toolkit would be difficult or impossible to write
in Emacs Lisp
  or shell, which don't have or don't document
a C extension interface at all.  Tcl
  has a good C extension facility, but
PIL would be an uncomfortably large project in Tcl.
Perl
  has such
facilities (Perl XS), but they are ad-hoc, poorly documented, complex,
and unstable by comparison to Python's and use of them is
rare. Java's
  Native Method Interface appears to provide a facility roughly
comparable to Python's; PIL would probably have made a reasonable Java
project.
</p>
<p>
  The PIL code and documentation is available at the
  <a href="http://www.pythonware.com/products/pil/">
   project
website</a>.
</p>
<h4 id="java"><a href="#java">§</a>Java</h4>
<p>
  The Java programming language was designed to be “write
once, run anywhere” and to support embedding interactive
programs (or
  <em>applets</em>) in Web pages that would
be runnable from any browser. Thanks to a series of technical and
strategic blunders by its owner, Sun
Microsystems, it has failed in both its original
objectives.  But it is still sufficiently strong at both systems and
applications programming to be seriously challenging
C
  and C++.  Java was announced in 1995.
</p>
<p>
  Java is cleverly designed to capture the huge benefit of
automatic memory management and the lesser but not insignificant
benefit of supporting OO
  design, while being far smaller and
simpler than C++. It retains a broadly C-like syntax
that most programmers will find comfortable. It includes support for
callouts to dynamically-loaded C and calling Java as an embedded
language from C.  Nor is it trivial that Sun
  has done an excellent job of making
good Java documentation available on the Web.
</p>
<p>
  Against Java, we can say that (compared to, say,
Python) some
parts of it appear over-complex and others deficient. Java's
class-visibility and implicit-scoping rules are baroque. The interface
facility avoids complex problems with multiple inheritance at the cost
of being only slightly less difficult to understand and use in itself.
Features like inner and anonymous classes can lead to very confusing
code. The absence of reliable destructor methods means that it is
difficult to ensure proper management of resources other than memory,
such as mutexes and file locks.  Significant parts of the Unix
operating-system facilities are not accessible from stock Java,
including signals, poll, and select.  While Java's I/O facilities are
very powerful, simple reading of text files is not simple.
</p>
<p>
  There is a particularly invidious problem, resembling Windows
DLL hell, with libraries.  Java has no method to manage
different library versions. This can create huge problems in
environments like application servers, where the server might come
equipped with one version of (say) an XML library, but the application
ships with a different (usually newer) version.  The only handle on
such problems is the
  <code>CLASSPATH</code> environment variable,
a source of chronic deployment problems.
</p>
<p>
  Furthermore, Sun's handling of the Java language has been both
politically and technically obtuse. Java's first GUI toolkit, AWT, was
a mess that had to be essentially replaced. Withdrawing the language
from ECMA/ISO standardization further nettled many developers already
upset by features of the Sun Community Source License (SCSL).
Restrictions in the SCSL continue to hamper open-source
implementations of Java 1.2 and their J2EE (Java 2 Enterprise Edition)
specification.  This compromises Java's original objective of
universal portability.
</p>
<p>
  Sadly, browser applets are dead.
Microsoft's
  decision not to support Java 1.2 in Internet Explorer effectively
killed them.  However, Java seems to have found a secure niche in the
computing ecology, for ‘servlets’ running within Web
application servers.  It has also become commonly used for a lot of
in-house corporate programming not directly tied to databases or
webservers.  It has become major competition for both Microsoft's
ASP/COM platform and Perl CGIs.  Finally, it is in widespread and
increasing use as a language for teaching introductory programming (a
role for which it is extremely well suited).
</p>
<p>
  Overall, we can fairly judge Java to be superior to
C++
  (which is
both far more complex and does less to attack the memory-management
problem) for all but systems programming and the most speed-critical
applications.  Experience seems to show that Java programmers are
somewhat less likely to fall into the trap of excessive
OO
  layering than are C++ programmers, though this remains a significant
problem.
</p>
<p>
  How Java will fare in equilibrium with the other languages
we describe here is unclear as yet, and may depend largely on project
scale. We may expect its proper niche to resemble
Python's. Like Python, it cannot compete with
C
  or
C++
  on raw
execution speed, nor against Perl
  on small projects that use
pattern-driven editing heavily. It is (more definitely than Python)
overkill for small projects. We may guess that Python will have an
edge in smaller projects and Java in larger ones, but the verdict of
experience is not yet in.
</p>
<p>
  The best single reference on paper is probably
  <em>Java In A Nutshell</em><sup><a href="#FlanaganJava" title="[FlanaganJava]">[FlanaganJava]</a></sup>, but this is
not the best tutorial introduction; that would probably be
  <em>Thinking in Java</em> <sup><a href="#Eckel" title="[Eckel]">[Eckel]</a></sup>. Trails to all the world's Java websites begin at
  <a href="http://java.sun.com">
   Sun's Java site</a>, which also
has complete HTML documentation available for download for free. The
  <a href="http://dmoz.org/Computers/Programming/Languages/Java/">
   Open
Directory Java Page</a>
  also collects useful Java links.
</p>
<p>
  Java implementations are available for all Unixes, for
Microsoft operating systems, MacOS, and many other platforms.
</p>
<p>
  Sources for Kaffe, an open-source Java implementation with class
libraries conforming to most of JDK 1.1 and portions of JDK 1.2,
are available at the
  <a href="http://www.kaffe.org/">
   Kaffe project site</a>.
</p>
<p>
  There is a Java front end for GCC. GCJ can compile Java code to
either Java bytecode or native code, and can compile Java bytecode to
native code as well. It comes packaged with open-source class
libraries that implement most of JDK 1.2, and a Java bytecode
interpreter called
  <em>gij</em>. Details are at the
  <a href="http://gcc.gnu.org/java/">
   GCJ project page</a>.
</p>
<p>
  There is a Java IDE for Emacs at the
  <a href="http://jdee.sunsite.dk/">
   JDEE project site</a>.
</p>
<p>
  Java portability is excellent at the language level.  Incomplete
library implementations (especially older JDK 1.1 versions that don't
support the newer JDK 1.2) can be an issue.
</p>
<p>
  Java's best side is that it comes close enough to
achieving write-once-run-anywhere to be useful as an OS-independent
environment of its own.  Its worst side is that the Java 1/Java 2
split compromises that goal in deeply frustrating ways.
</p>
<h5 id="id2977737"><a href="#id2977737">§</a>Case Study: FreeNet</h5>
<p>
  Freenet is a peer-to-peer networking project that is intended to
make censorship and content suppression
impossible.<sup><a href="#ftn.id2977747" id="id2977747">[127]</a></sup>
  Freenet developers envision the
following applications:
</p>
 <div>
  <ul>
   <li>
    <p>
     Uncensorable dissemination of controversial information: Freenet
protects freedom of speech by enabling anonymous and uncensorable
publication of material ranging from grassroots alternative journalism
to banned exposés.
    </p>
   </li>
   <li>
    <p>
     Efficient distribution of high-bandwidth content: Freenet's
adaptive caching and mirroring is being used to distribute Debian
Linux software updates.
    </p>
   </li>
   <li>
    <p>
     Universal personal publishing: Freenet enables anyone to have a
website, without space restrictions or compulsory advertising, even if
the would-be webmaster doesn't own a computer.
    </p>
   </li>
  </ul>
 </div>
<p>
  Freenet addresses these goals by providing a virtual space in
which to publish documents that is not tied to any specific machine.
Published information and Freenet's own internal data indexes are
replicated and distributed across the network in such a way that even
Freenet administrators don't know at any given time where all the physical
copies are located.  Privacy for people browsing or submitting to
Freenet is protected by strong cryptography.
</p>
<p>
  Java was a good choice for this project for at least two reasons.
First: the goals of the project put a heavy premium on having
compatible implementations on the widest possible variety of machines,
so Java's high portability is a dominating advantage.  Second: the
nature of the project is such that the network API is important,
and Java has a strong one built in.
</p>
<p>
  C is traditional for infrastructure projects of this kind that
have high performance demands, but the lack of a standardized network
API would have made porting a significant difficulty.  C++ would have
had the same difficulty.  Tcl, Perl, or Python
  might have reduced the porting burden,
but at a greater cost in performance.  Emacs Lisp
  would
have been painfully slow and totally inappropriate.
</p>
<h4 id="emacs_lisp_language"><a href="#emacs_lisp_language">§</a>Emacs Lisp</h4>
<p>
  Emacs Lisp is a scripting language
  used to program the behavior of the
Emacs text editor.  Its first public release was in 1984.
</p>
<p>
  Emacs Lisp is not a general-purpose language in quite the same
way as the others surveyed in this chapter; while it is powerful
enough to theoretically be used as such, it is traditionally employed
only to write control programs for the
Emacs editor itself and does not
communicate as fluently with other software as would a modern
scripting language.
</p>
<p>
  Nevertheless, there is a significant range of applications in
which Emacs Lisp is more effective than anything else. Many of these
have to do with providing a front-end for development tools such as
the C compiler and linker,
make(1),
version-control systems, and symbolic debuggers; we'll discuss these
in
  <a href="#toolschapter" title="Chapter 15. Tools">
   Chapter 15</a>.
</p>
<p>
  More generally, Emacs is to pattern-
or syntax-directed
  <em>interactive</em>
  editing what
Perl
  is to
pattern-directed
  <em>batch</em>
  editing. Any application
that involves interactively hacking a special file format or text
database is an excellent candidate to be prototyped (and possibly
delivered) as an Emacs mode (an Emacs Lisp
program that specializes the editor's behavior).
</p>
<p>
  Emacs Lisp is also valuable for building applications that have
to be closely integrated with a text editor, or that function
primarily as text browsers with some editing capability. User agents
for email and Usenet
  news fall in this category. So do certain kinds of database front
ends.
</p>
<p>
  Emacs Lisp is a Lisp. It follows as the night the day that it
manages memory automatically and is far more elegant and powerful than
most conventional languages, or indeed most
  <em>unconventional</em>
  languages; it can compete with
Java
  or
Python
  on
this level and laugh at C
  or C++, Perl, shell or Tcl. Lisp's perennial problem of lacking a
standardized OS binding for portability is solved by the Emacs core,
which in effect
  <em>is</em>
  its OS binding.
</p>
<p>
  Lisp's other perennial problem — being a resource hog
— is no longer a real issue on modern machines. Parody
expansions like ‘Emacs Makes A Computer Slow’ and
‘Eventually Munches All Computer Storage’ used to be
common (in fact the Emacs distribution itself includes a list of
them). But many other commonly used categories of programs (such as
Web browsers) have nowadays grown larger and more complex than Emacs,
which has come to appear rather moderate by comparison.
</p>
<p>
  The definitive Emacs Lisp reference is
  <em>
   The GNU Emacs
Lisp Reference Manual
</em>, which may be browseable through your
Emacs's ‘info’ help system. If not, it can be downloaded from the
  <a href="ftp://ftp.gnu.org/pub/gnu">
   FSF FTP
   site</a>. If you
find that impenetrable,
  <em>Writing GNU Emacs Extensions</em><sup><a href="#Glickstein" title="[Glickstein]">[Glickstein]</a></sup> may help.
</p>
<p>
  Portability of Emacs Lisp programs is excellent.
Emacs implementations are available for all
Unixes, the Microsoft operating systems, and Mac
OS.
</p>
<p>
  Summing up: Emacs Lisp's best point is that it combines an
excellent base language, Lisp, with powerful domain primitives for
text manipulation.  Its worst point is poor performance and
difficulties using it in communication with other programs.
</p>
<p>
  For more information, see the discussion of
  <em>Emacs</em> under editors in the next
chapter.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2969184" id="ftn.id2969184">[125]</a></sup>
  The last C++ standard,
dating from 1998, was widely implemented but weak, especially in the 
area of libraries.
</p>

<p><sup><a href="#id2969353" id="ftn.id2969353">[126]</a></sup>
  See Tom Christiansen's essay
  <em>Csh Programming Considered Harmful</em>, which should be readily
findable via Web search.
</p>

<p><sup><a href="#id2977747" id="ftn.id2977747">[127]</a></sup>
  There is a
  <a href="http://freenetproject.org">
   Freenet project
website</a>.
</p>
</div>


<!-- FILE: ch14s05.html -->
<h3 id="ch14s05"><a href="#ch14s05">§</a>Trends for the Future</h3>
<p>
   Table 14.1 gives a rough indication of today's distribution of language usage.  We give figures from both
   SourceForge<sup><a href="#ftn.id2978184" id="id2978184">[128]</a></sup> and Freshmeat,<sup><a href="#ftn.id2978197"
   id="id2978197">[129]</a></sup> the two most important new-release sites, as of March 2003.
</p>
<p>
  The SourceForge figures are soft in several ways: Notably,
SourceForge's query interface doesn't permit filtering on OS and
language simultaneously, so some of these numbers represent MacOS and
Windows projects.  The effect is probably to exaggerate
C++
  and
Java's
  share
considerably. However, Unix-based projects dominate sufficiently (by
about a 3:1 ratio) so that the effect on the figures for languages other
than these is probably not too distorting.
</p>
<p>
  The Freshmeat sample is smaller, but the site hosts only
Unix-based releases — and it counts actual releases, not the
huge clutter of failed and inactive SourceForge projects.  It is thus
interesting that the population figures track SourceForge's by about a
1:2 ratio except in precisely the cases (C++ and Java) where we would
expect them to be out of proportion because of the absence of Windows
projects.
</p>

 <table class="border">
	 <caption>Table 14.1. Language choices.</caption>
   <thead>
    <tr>
     <th>
      Language
     </th>
     <th>
      SourceForge
     </th>
     <th>
      Freshmeat
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      C
     </td>
     <td>
      10296
     </td>
     <td>
      4845
     </td>
    </tr>
    <tr>
     <td>
      C++
     </td>
     <td>
      9880
     </td>
     <td>
      2098
     </td>
    </tr>
    <tr>
     <td>
      Shell
     </td>
     <td>
      1058
     </td>
     <td>
      487
     </td>
    </tr>
    <tr>
     <td>
      Perl
     </td>
     <td>
      4394
     </td>
     <td>
      2508
     </td>
    </tr>
    <tr>
     <td>
      Tcl
     </td>
     <td>
      649
     </td>
     <td>
      328
     </td>
    </tr>
    <tr>
     <td>
      Python
     </td>
     <td>
      2222
     </td>
     <td>
      948
     </td>
    </tr>
    <tr>
     <td>
      Java
     </td>
     <td>
      8032
     </td>
     <td>
      1900
     </td>
    </tr>
    <tr>
     <td>
      Emacs Lisp
     </td>
     <td>
      ?
     </td>
     <td>
      31
     </td>
    </tr>
   </tbody>
  </table>

<p>
  This chapter was first drafted in 1997; at time of writing
it is mid-2003. That is a long enough time base that the relative
positions of the languages we surveyed above have changed somewhat
since first writing, indicating adoption trends that may suggest
what their futures will be like. (Community size is an important
predictor of the quality and amount of work that will go into
improving the most-used open-source implementations of these
languages; both growth and decline tend to be
self-reinforcing.)
</p>
<p>
  Broadly speaking, C
  and C++
  and Emacs Lisp
  have remained stable across the
1997-2003 time period, appealing to much the same constituencies in
2003 as they did in 1997. C has gained slowly at the expense of older
conventional languages such as FORTRAN; C++, on the other hand, has
lost some ground to Java.
</p>
<p>
  Perl
  usage has grown respectably, but the language itself has been stagnant
for some time. Perl's internals are notoriously grubby; it's been
understood for years that the language's implementation needs to be
rewritten from scratch, but an attempt in 1999 failed and another
seems presently stalled in mid-2003.  Nevertheless, Perl is still
the 800-pound gorilla of scripting
languages, and dominates Web scripting and
CGI.
</p>
<p>
  Tcl
  has
been in a period of relative decline, or at least of diminishing
visibility.  In 1996 a widely-reported and plausible estimate of
community sizes held that for every Python
  hacker there were five
Tcl
  hackers and
twelve Perl
  hackers. Today the SourceForge figures suggest those ratios are about
3:1:7.  However, Tcl is reported to be very widely used for scripting
of specialized components in several industries, including electronic
design automation, radio and television broadcasting, and the film
industry.
</p>
<p>
  Python
  has risen in popularity as rapidly as Tcl
  has fallen. Though the
Perl
  community
is still twice the size of Python's, a visible tendency of the
brightest Perl hackers to migrate to Python has been rather ominous
for the former language — especially as there is no migration at
all in the opposite direction.
</p>
<p>
  Java
  has
become widely used at sites already invested in Sun
Microsystems
  technology and is in increasing deployment as an instructional
language in undergraduate computer science curricula. Elsewhere,
however, it is only marginally more popular than it was in 1997. Sun's
determination to stick to a proprietary licensing model has prevented
the major breakout many observers then predicted; under
Linux
  and in the wider open-source community Java has not made the headway
against C that it has elsewhere.
</p>
<p>
  No new general-purpose language has emerged to seriously
challenge those we've surveyed here. PHP is making inroads in Web
development, challenging Perl CGIs (as well as ASP and server-side
Java) but is
almost never used for standalone programming.  Non-Emacs
Lisp
  dialects,
a once-promising area that seemed headed for a renaissance in the
mid-1990s, have continued to fade. Recent efforts such as Ruby (a sort
of Python-Perl-Smalltalk cross developed in Japan) and Squeak (an
open-source Smalltalk port) look promising, but have so far neither
attracted hackers far outside their development groups nor
demonstrated staying power.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2978184" id="ftn.id2978184">[128]</a></sup>
  <a href="http://sourceforge.net/softwaremap/trove_list.php?form_cat=160">
   Query
for statistics</a>.
</p>

<p><sup><a href="#id2978197" id="ftn.id2978197">[129]</a></sup>
  <a href="http://freshmeat.net/browse/160/?topic_id=160">
   Query for
statistics</a>.
</p>
</div>


<!-- FILE: ch14s06.html -->
<h3 id="ch14s06"><a href="#ch14s06">§</a>Choosing an X Toolkit</h3>
<p>
  An issue related to choice of language is choice of X toolkit
for GUI programming.  Recall the discussion in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>
  of how X separates mechanism from
policy.  Each possible choice of toolkit will give you a slightly
different look and feel.
</p>
<p>
  Your choice of X toolkit will be connected to your choice of
application language in two ways: first, because some languages ship
with a binding to a preferred toolkit, and second because some
toolkits only have bindings to a limited set of languages.
</p>
<p>
  Java, of
course, has its own cross-platform toolkits built in, so your choice
will be between AWT (universally deployed) and Swing (more capable,
more complex, slower, and only in JDK 1.2/Java 2). The remainder of
this section focuses on the other languages we have
surveyed. Similarly, if you're using Tcl, Tk comes bundled.  There
probably is not a lot of point in evaluating alternatives.
</p>
<p>
  The once-ubiquitous Motif toolkit is effectively dead. It
couldn't keep up with the newer toolkits distributed without license fees
or restrictions.  These attracted more developer effort until they
surged past closed-source toolkits in capability and features;
nowadays, the competition is all in open source.
</p>
<p>
  The four toolkits to consider seriously in 2003 are Tk,
GTK, Qt, and wxWindows, with GTK and Qt being the clear front runners.
All four have ports on MacOS and Windows, so any choice will give you
the capability to do cross-platform development.
</p>
<p>
  The Tk toolkit is the oldest of the four and has the advantage
of incumbency; it's native in Tcl and bindings to it are shipped with
the stock version of Python.  Libraries to provide language
bindings to Tk are generally available for C
  and C++.  Unfortunately, Tk also shows its age
in that its standard widget set is both limited and rather ugly.  On
the other hand, the Tk Canvas widget has capabilities that other
toolkits still match only with difficulty.
</p>
<p>
  GTK began life as a replacement for Motif, and was invented to
support the GIMP.  It is
now the preferred toolkit of the GNOME project and is used by hundreds
of GNOME applications. The native API is C; bindings are available for
C++,
Perl, and
Python, but
do not ship with the stock language distributions.  It's the only one
of these four with a native C binding.
</p>
<p>
  Qt is a toolkit associated with the KDE project.  It is natively
a C++
  library;
bindings are available for Python
  and Perl
  but do not ship with the stock
interpreters. Qt has a reputation for having the best-designed and
most expressive API of these four, but adoption was initially hindered
by controversy over early versions of the Qt license and was further
slowed down by the fact that a C binding was slow in coming.
</p>
<p>
  wxWindows is also natively C++
  with bindings available in
Perl
  and
Python.  The
wxWindows developers emphasize their support for cross-platform
development heavily and appear to regard it as the main selling point
of the toolkit.  Another selling point is that wxWindows is actually a
wrapper around the native (GTK, Windows, and MacOS 9) widgets on each
platform, so applications written using it retain a native look and
feel.
</p>
<p>
  As of mid-2003 few detailed comparisons have been written, but a Web search for “X toolkit comparison” may turn up
  some useful hits. Table 14.2 summarizes the state of play.
</p>

  <table class="border">
	  <caption>Table 14.2. Summary of X Toolkits.</caption>
   <thead>
    <tr>
     <th rowspan="2">
      Toolkit
     </th>
     <th rowspan="2">
      Native language
     </th>
     <th rowspan="2">
      Shipped with
     </th>
     <th colspan="5">
      Bindings
     </th>
    </tr>
    <tr>
     <th>
      C
     </th>
     <th>
      C++
     </th>
     <th>
      Perl
     </th>
     <th>
      Tcl
     </th>
     <th>
      Python
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      Tk
     </td>
     <td>
      Tcl
     </td>
     <td>
      Tcl, Python
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
    </tr>
    <tr>
     <td>
      GTK
     </td>
     <td>
      C
     </td>
     <td>
      Gnome
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
    </tr>
    <tr>
     <td>
      Qt
     </td>
     <td>
      C++
     </td>
     <td>
      KDE
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
    </tr>
    <tr>
     <td>
      wxWindows
     </td>
     <td>
      C++
     </td>
     <td>
      —
     </td>
     <td>
      —
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
     <td>
      Y
     </td>
    </tr>
   </tbody>
  </table>
<p>
  Architecturally, these libraries are all written at about the
same abstraction level.  GTK and Qt use a slot-and-signal apparatus
for event-handling so similar that ports between them have been
reported to be almost trivial.  Your choice among them will probably
be conditioned more by the availability of bindings to your chosen
development language than anything else.
</p>



<!-- FILE: toolschapter.html -->
<h3 id="toolschapter"><a href="#toolschapter">§</a>Chapter 15. Tools</h3>
 <blockquote class="epigraph">
  <p>
   Unix is user-friendly — it's just choosy about who its
friends are.
  </p>
  <span>
   – Anonymous
  </span>
 </blockquote>



<!-- FILE: ch15s01.html -->
<h3 id="ch15s01"><a href="#ch15s01">§</a>A Developer-Friendly Operating System</h3>
<p>
  Unix has a long-established reputation as a good environment to
develop under. It's well equipped with tools written by programmers
for programmers. These automate away many of the grubby little
tasks that would otherwise distract you from concentrating on the
most important (and most enjoyable!) aspect of development— your design.
</p>
<p>
  While all the tools you'll need are there and individually well
documented, they're not knit together by an integrated development
environment (IDE). Finding and assembling them into a kit that
suits your needs has traditionally taken considerable effort.
</p>
<p>
  If you're used to a good IDE — the kind of GUI-driven
combination of editor, configuration-manager, compiler, and
debugger now common on Macintosh and Windows systems — the Unix
approach may seem casual, murky, and primitive. But there's
actually method in it.
</p>
<p>
  IDEs make a lot of sense for single-language programming in a
tool-poor environment. If what you're doing is confined to grinding
out C
  or
C++
  code by hand
and the yard, they're quite appropriate.  Under Unix, however, your
languages and implementation options are a lot more varied. It's
common to use multiple code generators, custom configurators, and many
other standard and custom tools.
</p>
<p>
  IDEs do exist under Unix (there are several good open-source
ones, including emulations of the major Macintosh and Windows
IDEs). But it's difficult to control an open-ended variety of
programming tools with them, and they're not much used. Unix
encourages a more flexible style, one less exclusively centered on
the edit/compile/debug loop.
</p>
<p>
  In this chapter we introduce you to the tactics of
development under Unix — building code, managing code
configurations, profiling, debugging, and automating away a lot
of the drudgery associated with these tasks so you can concentrate on
the fun parts. As usual, the exposition focuses more on the
architectural picture than the how-to details. When you
  <em>want</em>
  how-to details, most of the tools in this
chapter are well described in
  <em>Programming with GNU Software</em><sup><a href="#Loukides-Oram" title="[Loukides-Oram]">[Loukides-Oram]</a></sup>.
</p>
<p>
  Many of these tools automate things that you could do yourself
by hand, albeit more slowly and with a higher error rate.  The
one-time cost of climbing the learning curve should be more than
paid off by the ability to write programs more efficiently, and
spend less attention on low-level details and more on design.
</p>
<p>
  Unix programmers traditionally learn how to use these tools by
osmosis from other programmers, and by exploration over a period of
years. If you're a novice, pay careful attention; we're going to try
to jump you over a big section of the Unix learning curve by showing
you what is possible right at the outset. If you are an experienced
Unix programmer in a hurry, you can skip this chapter — but
maybe you shouldn't. There might just be some bit of useful lore here
that even you don't know.
</p>



<!-- FILE: ch15s02.html -->
<h3 id="ch15s02"><a href="#ch15s02">§</a>Choosing an Editor</h3>
<p>
  The first and most basic tool of development is a text editor
suitable for modifying and writing programs.
</p>
<p>
  Literally dozens of text editors are available under Unix;
writing one seems to be one of the standard finger exercises for
budding open-source
hackers. Most of
these are ephemera, not suitable for extended use by anyone other than
their authors. A few are emulations of non-Unix editors, useful as
transition aids for programmers used to other operating systems. You
can browse through a wide variety at SourceForge or ibiblio or any
other major open-source archive.
</p>
<p>
  For serious editing work, two editors completely dominate the
Unix programming scene. Each is available in a couple of minor variant
implementations, but has a standard version you can rely on finding on
any modern Unix system. These two editors are
  <em>vi</em> and
  <em>Emacs</em>.
We discussed them in
  <a href="#complexitychapter" title="Chapter 13. Complexity">
   Chapter 13</a>
  as part of our discussion of the right
size of software.
</p>
<p>
  As we noted in
  <a href="#complexitychapter" title="Chapter 13. Complexity">
   Chapter 13</a>, these two editors express sharply
contrasting design philosophies, but both are extremely popular and
command great loyalty from identifiable core user populations. Surveys
of Unix programmers consistently indicate about a 50/50 split between
them, with all other editors barely registering.
</p>
<p>
  In our earlier examinations of
  <em>vi</em> and
  <em>Emacs</em>, we were primarily concerned with
their optional complexity and the surrounding design-philosophy issues.
Many other things are worth knowing about these editors, both as a
matter of practicality and of Unix cultural literacy.
</p>
<h4 id="vi_literacy"><a href="#vi_literacy">§</a>Useful Things to Know about vi</h4>
<p>
  The name of
  <em>vi</em> is an abbreviation for
“visual editor” and is pronounced
  <span class="phonetic">
   /vee eye/
  </span>
  (not
  <span class="phonetic">
   /vie/
  </span>
  and
  <em>definitely</em>
  not
  <span class="phonetic">
   /siks/
  </span>
  !).
</p>
<p>
  <em>vi</em> was not quite the earliest
screen-oriented editor; that palm goes to the Rand editor,
  <em>re</em>, that ran on Version 6 Unix in the 1970s. But
  <em>vi</em> is the longest-lived screen-oriented
editor built for Unix that is still in use, and is a hallowed part of
Unix tradition.
</p>
<p>
  The original
  <em>vi</em> was the version
present in the earliest BSD software distributions
  beginning in 1976; it is now obsolete. Its
replacement was ‘new vi’ which shipped with 4.4BSD and is
found on modern 4.4BSD variants such as BSD/OS, FreeBSD, and NetBSD
systems. There are several variants with extended features, notably
  <em>vim</em>,
  <em>vile</em>,
  <em>elvis</em>, and
  <em>xvi</em>;
of these
  <em>vim</em> is probably the most popular
and is found on many Linux
  systems. All the variants are rather
similar and share a core command set unchanged from the original
  <em>vi</em>.
</p>
<p>
  Ports of
  <em>vi</em> are available for the
Windows operating systems
  and MacOS.
</p>
<p>
  Most introductory Unix books include a chapter describing basic <em>vi</em> usage. One place a <em>vi</em> FAQ is
  available is the <a href="http://www.faqs.org/faqs/editor-faq/vi/"> Editor FAQ/vi</a>; you can find many other copies
  with a WWW keyword search for page titles including “vi” and “FAQ”.
</p>
<h4 id="id2979540"><a href="#id2979540">§</a>Useful Things to Know about Emacs</h4>
<p>
  <em>Emacs</em> stands for ‘EDiting
MACroS’ (pronounce it
  <span class="phonetic">
   /ee´·maks/
  </span>).  It was originally
written in the late 1970s as a set of macros in an editor called TECO,
then reimplemented several times in different ways.  In an amusing
twist, modern Emacs implementations include a TECO emulation
mode.
</p>
<p>
  In our earlier discussion of editors and optional complexity, we
noted that many people consider Emacs
excessively heavyweight.  However, investing the time to learn it can
yield rich rewards in productivity.  Emacs
supports many powerful editing modes that offer help with the syntax
of various programming languages and markups.  We'll see later in this
chapter how Emacs can be used in
combination with other development tools to give capabilities
comparable to (and in many ways surpassing) those of conventional
IDEs.
</p>
<p>
  The standard Emacs, universally available on modern Unixes, is <em>GNU Emacs</em>; this is what generally runs if you
  type <code>emacs</code> to a Unix shell prompt. GNU Emacs sources and documentation are available at the <a
  href="ftp://gnu.org/pub/gnu"> Free Software Foundation archive site</a>.
</p>
<p>
  The only major variant is called <em>XEmacs</em>; it has a better X interface but otherwise quite similar capabilities
  (it forked from Emacs 19). <em>XEmacs</em> has a <a href="http://www.xemacs.org"> home page</a>. Emacs (and Emacs
  Lisp) is universally available under modern Unixes. It has been ported to MS-DOS (where it works poorly) and Windows
  95 and NT (where it is said to work reasonably well).
</p>
<p>
  Emacs includes its own interactive
tutorial and very complete on-line documentation; you'll find
instructions on how to invoke both on the default
Emacs startup screen. A good introduction
on paper is
  <em>Learning GNU Emacs</em> <sup><a href="#Cameron" title="[Cameron]">[Cameron]</a></sup>.
</p>
<p>
  The keystroke commands used in the Unix ports of
Netscape/Mozilla and Internet Explorer text windows (in forms and the
mailer) are copied from the stock Emacs
bindings for basic text editing.  These bindings are the closest thing
to a cross-platform standard for editor keystrokes.
</p>
<h4 id="id2979678"><a href="#id2979678">§</a>The Antireligious Choice: Using Both</h4>
<p>
  Many people who regularly use both
  <em>vi</em> and
Emacs tend to use them for different
things, and find it valuable to know both.
</p>
<p>
  In general,
  <em>vi</em> is best for small jobs
— quick replies to mail, simple tweaks to system configuration,
and the like. It is especially useful when you're using a new system
(or a remote one over a network) and don't have your
Emacs customization files handy.
</p>
<p>
  Emacs comes into its own for extended
editing sessions in which you have to handle complex tasks, modify
multiple files, and use results from other programs during the
session. For programmers using X on their console (which is typical on
modern Unixes), it's normal to start up
Emacs shortly after login time in a large
window and leave it running forever, possibly visiting dozens of files
and even running programs in multiple Emacs
subwindows.
</p>



<!-- FILE: ch15s03.html -->
<h3 id="ch15s03"><a href="#ch15s03">§</a>Special-Purpose Code Generators</h3>
<p>
  Unix has a long-standing tradition of hosting tools that are
specifically designed to generate code for various special purposes.
The venerable monuments of this tradition, which go back to Version 7
and earlier days, and were actually used to write the original
Portable C Compiler back in the 1970s, are
lex(1)
and
yacc(1).
Their modern, upward-compatible successors are
flex(1)
and
bison(1),
part of the GNU
  toolkit and still heavily used today.  These programs have set an
example that is carried forward in projects like GNOME's
  <em>Glade</em> interface builder.
</p>
<h4 id="id2979797"><a href="#id2979797">§</a>yacc and lex</h4>
<p>
  <em>yacc</em> and
  <em>lex</em> are tools for generating language
parsers.  We observed in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>
  that your first minilanguage is all
too likely to be an accident rather than a design.  That accident is
likely to have a hand-coded parser that costs you far too much
maintenance and debugging time — especially if you have not
realized it is a parser, and have thus failed to properly separate it
from the remainder of your application code.  Parser generators are
tools for doing better than an accidental, ad-hoc implementation; they
don't just let you express your grammar specification at a higher
level, they also wall off all the parser's implementation complexity
from the rest of your code.
</p>
<p>
  If you reach a point where you are planning to implement a
minilanguage from scratch, rather than by extending or embedding an
existing scripting language
  or parsing XML,
  <em>yacc</em> and
  <em>lex</em> will probably be your most important tools after your
C
  compiler.
</p>
<p>
  <em>lex</em> and
  <em>yacc</em> each generate code for a single
function — respectively, “get a token from the input
stream” and “parse a sequence of tokens to see if it
matches a grammar”.  Usually, the
  <em>yacc</em> -generated parser function calls a
Lex-generated tokenizer function each time it wants to get another
token.  If there are no user-written C callbacks at all in the
  <em>yacc</em> -generated parser, all it will do is a
syntax check; the value returned will tell the caller if the input
matched the grammar it was expecting.
</p>
<p>
  More usually, the user's C code, embedded in the generated
parser, populates some runtime data structures as a side-effect of
parsing the input.  If the minilanguage is declarative, your
application can use these runtime data structures directly.  If your
design was an imperative minilanguage, the data structures might
include a parse tree which is immediately fed to some kind of
evaluation function.
</p>
<p>
  <em>yacc</em> has a rather ugly interface,
through exported global variables with the name prefix
  <code>yy_</code>.  This is because it predates structs in C; in
fact,
  <em>yacc</em> predates C itself; the first
implementation was written in C's predecessor B.  The crude
though effective algorithm
  <em>yacc</em> -generated
parsers use to try to recover from parse errors (pop tokens until an
explicit error production is matched) can also lead to
problems, including memory leaks.
</p>
 <blockquote>
  <p>
   If you are building parse trees, using malloc to make nodes, and
you start popping things off the stack in error recovery, you don't
get to recover (free) the storage.  In general, Yacc can't do it,
since it doesn't know enough about what's on the stack.  If the yacc
parser were in C++, it could assume that the values were classes and
“destruct” them.  In “real” compilers, parse
tree nodes are generated using an arena-based allocator, so the nodes
don't leak, but there is a logical leak anyway that needs to be
thought about to make industrial-strength error recovery.
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>
<p>
  <em>lex</em> is a lexical analyzer generator.
It's a member of the same functional family as
grep(1)
and
awk(1),
but more powerful because it enables you to arrange for arbitrary C
code to be executed on each match.  It accepts a declarative
minilanguage and emits skeleton C code.
</p>
<p>
  A crude but useful way to think about what a
  <em>lex</em> -generated tokenizer does is as a sort
of inverse
grep(1).
Where
grep(1)
takes a single regular expression and returns a list of matches in the
incoming data stream, each call to a
  <em>lex</em> -generated tokenizer takes a list of
regular expressions and indicates which expression occurs next in the
datastream.
</p>
 <blockquote>
  <p>
   Splitting input analysis into tokenizing input and parsing
the token stream is a useful tactic even if you're not using Yacc and
Lex and your “tokens” are nothing like the usual ones in
a compiler.  More than once I've found that splitting input handling
into two levels made the code much simpler and easier to understand,
despite the complexity added by the split itself.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  <em>lex</em> was written to automate the task
of generating lexical analyzers (tokenizers) for compilers.  It turned
out to have a surprisingly wide range of uses for other kinds of
pattern recognition, and has since been described as “the
Swiss-army knife of Unix programming”.<sup><a href="#ftn.id2980161" id="id2980161">[130]</a></sup>
</p>
<p>
  If you are attacking any kind of pattern-recognition or
state-machine problem in which all the possible input stimuli will fit
in a byte,
  <em>lex</em> may enable you to generate
code that will be more efficient and reliable than a hand-crafted
state machine.
</p>
 <blockquote>
  <p>
   John Jarvis at Holmdel [an AT&amp;T laboratory] used
   <em>lex</em> to find faults in circuit boards, by
scanning the board, using a chain-encoding technique to represent the
edges of areas on the board, and then using Lex to define patterns
that would catch common fabrication errors.
  </p>
  <span>
   – Mike Lesk
  </span>
 </blockquote>
<p>
  Most importantly, the
  <em>lex</em> specification minilanguage is much higher-level and more
compact
  than
equivalent handcrafted C.  Modules are available to use
  <em>flex</em>, the open-source version, with
Perl
  (find them
with a Web search for “lex perl”), and a work-alike
implementation is part of
  <em>PLY</em> in
Python.
</p>
<p>
  <em>lex</em> generates parsers that are up
to an order of magnitude slower than hand-coded parsers.  This is
not a good reason to hand-code, however; it's an argument for
prototyping with
  <em>lex</em> and hand-hacking
only if prototyping reveals an actual bottleneck.
</p>
<p>
  <em>yacc</em> is a parser generator.  It, too,
was written to automate part of the job of writing compilers.  It
takes as input a grammar specification in a declarative minilanguage
resembling BNF (Backus-Naur Form) with C code associated with each
element of the grammar.  It generates code for a parser function
that, when called, accepts text matching the grammar from an input
stream.  As each grammar element is recognized, the parser function
runs the associated C code.
</p>
<p>
  The combination of
  <em>lex</em> and
  <em>yacc</em> is very effective for writing language
interpreters of all kinds.  Though most Unix programmers never get to
do the kind of general-purpose compiler-building that these tools were
meant to assist, they're extremely useful for writing parsers for
run-control file syntaxes and domain-specific minilanguages.
</p>
<p>
  <em>lex</em> -generated tokenizers are very
fast at recognizing low-level patterns in input streams, but the
regular-expression minilanguage that
  <em>lex</em> knows is not good at counting things, or recognizing recursively
nested structures.  For parsing those, you want
  <em>yacc</em>.  On the other hand, while you
theoretically could write a
  <em>yacc</em> grammar to
do its own token-gathering, the grammar to specify that would be
hugely bloated and the parser extremely slow.  For tokenizing input,
you want
  <em>lex</em>.  Thus, these tools are
symbiotic.
</p>
<p>
  If you can implement your parser in a higher-level language than
C (which we recommend you do; see
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>
  for discussion), then look for equivalent
facilities like Python's PLY (which covers both
  <em>lex</em> and
  <em>yacc</em>)<sup><a href="#ftn.id2985990" id="id2985990">[131]</a></sup>
  or Perl's
  PY
and Parse::Yapp modules, or Java's
  CUP,<sup><a href="#ftn.id2986024" id="id2986024">[132]</a></sup>
  Jack,<sup><a href="#ftn.id2986040" id="id2986040">[133]</a></sup>
  or Yacc/M<sup><a href="#ftn.id2986056" id="id2986056">[134]</a></sup>
  packages.
</p>
<p>
  As with macro processors, one of the problems with code
generators and preprocessors is that compile-time errors in the
generated code may carry line numbers that are relative to the
generated code (which you don't want to edit) rather than the
generator input (which is where you need to make corrections).
  <em>yacc</em> and
  <em>lex</em> address this by generating the same
  <code>#line</code> constructs that the C
  preprocessor does; these set the current line number for error
reporting so the numbers will come out right. Any program that
generates C
  or
C++
  should do
likewise.
</p>
<p>
  More generally, well-designed procedural-code generators
should never require the user to hand-alter or even look at the
generated parts.  Getting those right is the code generator's
job.
</p>
<h5 id="id2986148"><a href="#id2986148">§</a>Case Study: The fetchmailrc Grammar</h5>
<p>
  The canonical demonstration example that seems to have appeared
in every
  <em>lex</em> and
  <em>yacc</em> tutorial ever written is a toy
interactive calculator program that parses and evaluates arithmetic
expressions entered by the user.  We will spare you yet another
repetition of this cliche; if you are interested, consult the source
code of the
bc(1)
and
dc(1)
calculator implementations from the GNU project, or the paradigm example
‘hoc’<sup><a href="#ftn.id2986209" id="id2986209">[135]</a></sup>
  from <sup><a href="#Kernighan-Pike84" title="[Kernighan-Pike84]">[Kernighan-Pike84]</a></sup>.
</p>
<p>
  Instead, the grammar of
  <em>fetchmail</em> 's
  run-control-file parser provides a good medium-sized case study in
  <em>lex</em> and
  <em>yacc</em> usage.  There are a couple of points of interest here.
</p>
<p>
  The
  <em>lex</em> specification, in
  <code>rcfile_l.l</code>, is a very typical implementation of a
shell-like syntax.  Note how two complementary rules support either
single or double-quoted strings; this is a good idea in general.  The
rules for accepting (possibly signed) integer literals and discarding
comments are also pretty generic.
</p>
<p>
  The
  <em>yacc</em> specification, in
  <code>rcfile_y.y</code>, is long but straightforward. It does
not perform any
  <em>fetchmail</em> actions, just
sets bits in a list of internal control blocks. After startup,
  <em>fetchmail</em> 's normal mode of operation is
just to repeatedly walk that list, using each record to drive a
retrieval session with a remote site.
</p>
<h4 id="id2986324"><a href="#id2986324">§</a>Case Study: Glade</h4>
<p>
  We looked at
  <em>Glade</em> in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>
  as a good example of a
declarative minilanguage. We also noted that its back end produces a
result by generating code in any one of several languages.
</p>
<p>
  <em>Glade</em> is a good modern example of an
application-code generator.  What makes it Unixy in spirit are the
following features, which most GUI builders (especially most
proprietary GUI builders) don't have:
</p>
 <div>
  <ul>
   <li>
    <p>
     Rather than being glued together as one monster
monolith, the
     <em>Glade</em> GUI and
     <em>Glade</em> code generator obey the Rule of
Separation (following the “separated engine and
interface” design pattern).
    </p>
   </li>
   <li>
    <p>
     The GUI and code generator are connected by an (XML-based) textual
data file format that can be read and modified by other tools.
    </p>
   </li>
   <li>
    <p>
     Multiple target languages (as opposed to just
C
     or
C++) are supported.  More
could easily be added.
    </p>
   </li>
  </ul>
 </div>
<p>
  The design implies that it should also be possible to
replace the
  <em>Glade</em> GUI editor component,
should that ever become desirable.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2980161" id="ftn.id2980161">[130]</a></sup>
  The common latter-day description of Perl as a 
“Swiss-army chainsaw” is derivative.
</p>

<p><sup><a href="#id2985990" id="ftn.id2985990">[131]</a></sup>
  PLY is
  <a href="http://systems.cs.uchicago.edu/ply/">
   downloadable</a>.
</p>

<p><sup><a href="#id2986024" id="ftn.id2986024">[132]</a></sup>
  CUP is
  <a href="http://www.cs.princeton.edu/~appel/modern/java/CUP/">
   downloadable</a>.
</p>

<p><sup><a href="#id2986040" id="ftn.id2986040">[133]</a></sup>
  Jack is
  <a href="http://www.javaworld.com/javaworld/jw-12-1996/jw-12-jack.html">
   downloadable</a>.
</p>

<p><sup><a href="#id2986056" id="ftn.id2986056">[134]</a></sup>
  Yacc/M is
  <a href="http://david.tribble.com/yaccm.html">
   downloadable</a>.
</p>

<p><sup><a href="#id2986209" id="ftn.id2986209">[135]</a></sup>
  <a href="http://cm.bell-labs.com/cm/cs/upe/">
   http://cm.bell-labs.com/cm/cs/upe/</a>
</p>
</div>


<!-- FILE: ch15s04.html -->
<h3 id="ch15s04"><a href="#ch15s04">§</a>make: Automating Your Recipes</h3>
<p>
  Program sources by themselves don't make an application. The way
you put them together and package them for distribution matters,
too. Unix provides a tool for semi-automating these processes;
make(1).
  <em>Make</em> is covered in most introductory Unix
books. For a really thorough reference, you can consult
  <em>Managing Projects with Make</em> <sup><a href="#Oram-Talbot" title="[Oram-Talbot]">[Oram-Talbot]</a></sup>. If you're using
  <em>GNU make</em> (the most advanced make, and the
one normally shipped with open-source Unixes) the treatment in
  <em>Programming with GNU Software</em> <sup><a href="#Loukides-Oram" title="[Loukides-Oram]">[Loukides-Oram]</a></sup> may be better in some
respects. Most Unixes that carry
  <em>GNU make</em> will also support GNU Emacs; if yours does you will probably find a
complete make manual on-line through Emacs's
  <em>info</em> documentation system.
</p>
<p>
  Ports of
  <em>GNU make</em> to DOS and Windows
are available from the FSF.
</p>
<h4 id="id2986550"><a href="#id2986550">§</a>Basic Theory of make</h4>
<p>
  If you're developing in C
  or C++, an important part of the recipe for
building your application will be the collection of compilation and
linkage commands needed to get from your sources to working
binaries. Entering these commands is a lot of tedious detail work, and
most modern development environments include a way to put them in
command files or databases that can automatically be re-executed to
build your application.
</p>
<p>
  Unix's make(1) program, the original of all these facilities, was designed specifically to help C programmers manage
  these recipes. It lets you write down the dependencies between files in a project in one or more ‘makefiles’. Each
  makefile consists of a series of <em>productions</em>; each one tells <em>make</em> that some given target file
  depends on some set of source files, and says what to do if any of the sources are newer than the target. You don't
  actually have to write down all dependencies, as the <em>make</em> program can deduce a lot of the obvious ones from
  filenames and extensions.
</p>
<p>
  For example: You might put in a makefile that the binary
  <code>myprog</code> depends on three object files
  <code>myprog.o</code>,
  <code>helper.o</code>, and
  <code>stuff.o</code>. If you have source files
  <code>myprog.c</code>,
  <code>helper.c</code>, and
  <code>stuff.c</code>,
  <em>make</em> will
know without being told that each
  <code>.o</code> file depends
on the corresponding
  <code>.c</code> file, and supply its own
standard recipe for building a
  <code>.o</code> file from a
  <code>.c</code> file.
</p>
 <blockquote>
  <p>
   Make originated with a visit from Steve Johnson (author of
   <em>yacc</em>, etc.), storming into my office, cursing
the Fates that had caused him to waste a morning debugging a correct
program (bug had been fixed, file hadn't been compiled,
   <code>cc *.o</code> was therefore unaffected).  As I had spent a part of the
previous evening coping with the same disaster on a project I was
working on, the idea of a tool to solve it came up.  It began with an
elaborate idea of a dependency analyzer, boiled down to something much
simpler, and turned into Make that weekend.  Use of tools that were
still wet was part of the culture. Makefiles were text files, not
magically encoded binaries, because that was the Unix ethos:
printable, debuggable, understandable stuff.
  </p>
  <span>
   – Stuart Feldman
  </span>
 </blockquote>
<p>
  When you run <code>make</code> in a project directory, the
  <em>make</em> program looks at all productions and
timestamps and does the minimum amount of work necessary to make sure
derived files are up to date.
</p>
<p>
  You can read a good example of a moderately complex makefile in
the sources for
  <em>fetchmail</em>.
In the subsections below we'll refer to it again.
</p>
<p>
  Very complex makefiles, especially when they call subsidiary
makefiles, can become a source of complications rather than
simplifying the build process.  A now-classic warning is issued
in
  <em>Recursive Make Considered Harmful</em>.<sup><a href="#ftn.id2986827" id="id2986827">[136]</a></sup>
  The argument in this paper has
become widely accepted since it was written in 1997, and has come
near to reversing previous community practice.
</p>
<p>
  No discussion of
make(1)
would be complete without an acknowledgement that it includes one of
the worst design botches in the history of Unix. The use of tab
characters as a required leader for command lines associated with a
production means that the interpretation of a makefile can change
drastically on the basis of invisible differences in whitespace.
</p>
 <blockquote>
  <p>
   Why the tab in column 1? Yacc was new, Lex was brand new. I
hadn't tried either, so I figured this would be a good excuse to
learn. After getting myself snarled up with my first stab at Lex, I
just did something simple with the pattern newline-tab. It
worked, it stayed. And then a few weeks later I had a user population
of about a dozen, most of them friends, and I didn't want to screw up
my embedded base. The rest, sadly, is history.
  </p>
  <span>
   – Stuart Feldman
  </span>
 </blockquote>
<h4 id="id2986902"><a href="#id2986902">§</a>make in Non-C/C++ Development</h4>
<p>
  <em>make</em> is not just useful for C/C++
recipes, however.  Scripting languages like those we described in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>
  may not require
conventional compilation and link steps, but there are often other
kinds of dependencies that
make(1)
can help you with.
</p>
<p>
  Suppose, for example, that you actually generate part of your
code from a specification file, using one of the techniques from
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>. You can use
  <em>make</em> to tie the spec file and the generated
source together. This will ensure that whenever you change the spec
and remake, the generated code will automatically be rebuilt.
</p>
<p>
  It's quite common to use makefile productions to express recipes
for making documentation as well as code. You'll often see this
approach used to automatically generate PostScript or other derived
documentation from masters written in some markup language (like HTML
or one of the Unix document-macro languages we'll survey in
  <a href="#documentationchapter" title="Chapter 18. Documentation">
   Chapter 18</a>). In fact, this sort of use is so
common that it's worth illustrating with a case study.
</p>
<h5 id="id2986982"><a href="#id2986982">§</a>Case Study: make for Document-File Translation</h5>
<p>
  In the
fetchmail
  makefile,
for example, you'll see three productions that relate files named
  <code>FAQ</code>,
  <code>FEATURES</code>, and
  <code>NOTES</code> to HTML sources
  <code>fetchmail-FAQ.html</code>,
  <code>fetchmail-features.html</code>, and
  <code>design-notes.html</code>.
</p>
<p>
  The HTML files are meant to be accessible on the fetchmail Web
page, but all the HTML markup makes them uncomfortable to look at
unless you're using a browser. So the
  <code>FAQ</code>,
  <code>FEATURES</code>, and
  <code>NOTES</code> are
flat-text files meant to be flipped through quickly with an editor or
pager program by someone reading the
  <em>fetchmail</em> sources themselves (or, perhaps, distributed to FTP sites that don't
support Web access).
</p>
<p>
  The flat-text forms can be made from their HTML masters by using
the common open-source program
lynx(1).
  <em>lynx</em> is a Web browser for text-only
displays; but when invoked with the
  <code>-dump</code> option it
functions reasonably well as an HTML-to-ASCII formatter.
</p>
<p>
  With the productions in place, the developer can edit the HTML
masters without having to remember to manually rebuild the flat-text
forms afterwards, secure in the knowledge that
  <code>FAQ</code>,
  <code>FEATURES</code>, and
  <code>NOTES</code> will be properly rebuilt whenever they are
needed.
</p>
<h4 id="id2987148"><a href="#id2987148">§</a>Utility Productions</h4>
<p>
  Some of the most heavily used productions in typical makefiles
don't express file dependencies at all. They're ways to bundle up
little procedures that a developer wants to mechanize, like making
a distribution package or removing all object files in order to do
a build from scratch.
</p>
 <blockquote>
  <p>
   Non-file productions were intentional and in there from day
one. ‘Make all’ and ‘clean’ were my own
conventions from earliest days.  One of the older Unix jokes is
“Make love” which results in “Don't know how to
make love”.
  </p>
  <span>
   – Stuart Feldman
  </span>
 </blockquote>
<p>
  There is a well-developed set of conventions about what utility
productions should be present and how they should be named.
Following these will make your makefile much easier to understand
and use.
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     <code>all</code> </span>
   </dt>
   <dd>
    <p>
     Your
     <code>all</code> production should make every
executable of your project. Usually the
     <code>all</code> production doesn't have an explicit rule; instead it refers to all of
your project's top-level targets (and, not accidentally, documents
what those are). Conventionally, this should be the first production in
your makefile, so it will be the one executed when the developer types
     <code>make</code> with no argument.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>test</code> </span>
   </dt>
   <dd>
    <p>
     Run the program's automated test suite, typically consisting of
a set of unit tests<sup><a href="#ftn.id2987288" id="id2987288">[137]</a></sup>
     to find regressions, bugs, or other deviations
from expected behavior during the development process. The
‘test’ production can also be used by end-users of the
software to ensure that their installation is functioning correctly.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>clean</code> </span>
   </dt>
   <dd>
    <p>
     Remove all files (such as binary executables and object files)
that are normally created when you
     <code>make all</code>.  A <code>make clean</code>
     should reset the process of building the software to a good initial state.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>dist</code> </span>
   </dt>
   <dd>
    <p>
     Make a source archive (usually with the
tar(1)
program) that can be shipped as a unit and used to rebuild the program
on another machine. This target should do the equivalent of depending
on <code>all</code> so that a <code>make dist</code>
     automatically rebuilds the whole project before making the
distribution archive — this is a good way to avoid last-minute
embarrassments, like not shipping derived files that are actually
needed (like the flat-text
     <code>README</code>
     in <em>fetchmail</em>, which is actually generated from an HTML source).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>distclean</code> </span>
   </dt>
   <dd>
    <p>
     Throw away everything but what you would include if you were
bundling up the source with
     <code>make dist</code>. This may be the the same as <code>make clean</code>
     but should be included
as a production of its own anyway, to document what's going on. When
it's different, it usually differs by throwing away local
configuration files that aren't part of the normal
     <code>make all</code> build sequence (such as those generated by autoconf(1);
we'll talk about autoconf(1) in
     <a href="#portabilitychapter" title="Chapter 17. Portability">
      Chapter 17</a>).
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>realclean</code> </span>
   </dt>
   <dd>
    <p>
     Throw away everything you can rebuild using the makefile. This
may be the same as
     <code>make distclean</code>, but should be
included as a production of its own anyway, to document what's going
on. When it's different, it usually differs by throwing away files
that are derived but (for whatever reason) shipped with the project
sources anyway.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>install</code> </span>
   </dt>
   <dd>
    <p>
     Install the project's executables and documentation in system
directories so they will be accessible to general users (this
typically requires root privileges). Initialize or update any
databases or libraries that the executables require in order to
function.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>uninstall</code> </span>
   </dt>
   <dd>
    <p>
     Remove files installed in system directories by
     <code>make install</code>
     (this typically requires root privileges). This should completely and perfectly reverse a
     <code>make install</code>.  The presence of an uninstall production implies a
kind of humility that experienced Unix hands look for as a sign of
thoughtful design; conversely, not having an uninstall production is
at best careless, and (when, for example, an installation creates
large database files) can be quite rude and thoughtless.
    </p>
   </dd>
  </dl>
 </div>
<p>
  Working examples of all the standard targets are available for
inspection in the
  <em>fetchmail</em> makefile. By studying all of them together you will see a pattern
emerge, and (not incidentally) learn much about the
  <em>fetchmail</em> package's structure. One of the
benefits of using these standard productions is that they form an
implicit roadmap of their project.
</p>
<p>
  But you need not limit yourself to these utility productions.
Once you master
  <em>make</em>, you'll find yourself
more and more often using the makefile machinery to automate little
tasks that depend on your project file state. Your makefile is a
convenient central place to put these; using it makes them readily
available for inspection and avoids cluttering up your workspace with
trivial little scripts.
</p>
<h4 id="id2987644"><a href="#id2987644">§</a>Generating Makefiles</h4>
<p>
  One of the subtle advantages of Unix
  <em>make</em> over the dependency databases built
into many IDEs is that makefiles are simple text files — files
that can be generated by programs.
</p>
<p>
  In the mid-1980s it was fairly common for large Unix program
distributions to include elaborate custom shellscripts that would
probe their environment and use the information they gathered to
construct custom makefiles.  These custom configurators reached absurd
sizes.  I wrote one once that was 3000 lines of shell, about twice as
large as any single module in the program it was configuring —
and this was not unusual.
</p>
<p>
  The community eventually said “Enough!” and various
people set out to write tools that would automate away part or all of
the process of maintaining makefiles. These tools generally tried to
address two issues:
</p>
<p>
  One issue is
  <em>portability</em>. Makefile
generators are commonly built to run on many different hardware
platforms and Unix variants. They generally try to deduce things about
the local system (including everything from machine word size up to
which tools, languages, service libraries, and even document
formatters it has available). They then try to use those deductions to
write makefiles that exploit the local system's facilities and
compensate for its quirks.
</p>
<p>
  The other issue is
  <em>
   dependency
derivation
</em>. It's possible to deduce a great deal about the
dependencies of a collection of C sources by analyzing the sources
themselves (especially by looking at what include files they use and
share). Many makefile generators do this in order to mechanically
generate
  <em>make</em> dependencies.
</p>
<p>
  Each different makefile generator tackles these objectives in a
slightly different way. Probably a dozen or more generators have
been attempted, but most proved inadequate or too difficult to drive
or both, and only a few are still in live use. We'll survey the major
ones here. All are available as open-source software on the
Internet.
</p>
<h5 id="id2987736"><a href="#id2987736">§</a>makedepend</h5>
<p>
  Several small tools have tackled the rule automation part of the
problem exclusively. This one, distributed along with the X windowing
system from MIT, is the fastest and most useful and comes
preinstalled under all modern Unixes, including all
Linuxes.
</p>
<p>
  <em>makedepend</em> takes a collection of
C
  sources and
generates dependencies for the corresponding
  <code>.o</code> files from their
  <code>#include</code> directives. These can be
appended directly to a makefile, and in fact makedepend is defined to
do exactly that.
</p>
<p>
  <em>makedepend</em> is useless for anything
but C projects. It doesn't try to solve more than one piece of the
makefile-generation problem. But what it does it does quite
well.
</p>
<p>
  <em>makedepend</em> is sufficiently documented by its manual page. If you type
  <code>man makedepend</code> at a terminal window you will quickly learn what you need to know about
invoking it.
</p>
<h5 id="id2987839"><a href="#id2987839">§</a>Imake</h5>
<p>
  <em>Imake</em> was written in an attempt to
mechanize makefile generation for the X window
system. It
builds on
  <em>makedepend</em> to tackle both the
dependency-derivation and portability problems.
</p>
<p>
  <em>Imake</em> system effectively replaces
conventional makefiles with Imakefiles. These are written in a more
compact and powerful notation which is (effectively) compiled into
makefiles. The compilation uses a rules file which is system-specific
and includes a lot of information about the local environment.
</p>
<p>
  <em>Imake</em> is well suited to X's
particular portability and configuration challenges and universally
used in projects that are part of the X distribution. However, it has
not achieved much popularity outside the X developer community. It's
hard to learn, hard to use, hard to extend, and produces generated
makefiles of mind-numbing size and complexity.
</p>
<p>
  The
  <em>Imake</em> tools will be available on
any Unix that supports X, including Linux. There has been one heroic
effort <sup><a href="#DuBois" title="[DuBois]">[DuBois]</a></sup> to make the mysteries of
  <em>Imake</em> comprehensible to non-X-programming
mortals. These are worth learning if you are going to do X
programming.
</p>
<h5 id="id2987944"><a href="#id2987944">§</a>autoconf</h5>
<p>
  <em>autoconf</em> was written by people who
had seen and rejected the
  <em>Imake</em> approach. It generates per-project
  <code>configure</code> shellscripts that are like the old-fashioned custom script
configurators. These
  <code>configure</code> scripts can
generate makefiles (among other things).
</p>
<p>
  <em>Autoconf</em> is focused on portability
and does no built-in dependency derivation at all. Although it is
probably as complex as
  <em>Imake</em>, it is much
more flexible and easier to extend. Rather than relying on a
per-system database of rules, it generates
  <code>configure</code> shell code that goes out and searches
your system for things.
</p>
<p>
  Each
  <code>configure</code> shellscript is built from a
per-project template that you have to write, called
  <code>configure.in</code>. Once generated, though, the
  <code>configure</code> script will be self-contained and can
configure your project on systems that don't carry
autoconf(1)
itself.
</p>
<p>
  The
  <em>autoconf</em> approach to makefile
generation is like imake's in that you start by writing a makefile
template for your project. But
  <em>autoconf</em> 's
  <code>Makefile.in</code> files are basically just makefiles
with placeholders in them for simple text substitution; there's no
second notation to learn. If you want dependency derivation, you must take
explicit steps to call
makedepend(1)
or some similar tool — or use
automake(1).
</p>
<p>
  <em>autoconf</em> is documented by an on-line
manual in the GNU
  <em>info</em> format. The source scripts
of autoconf are available from the FSF
  archive site, but are
also preinstalled on many Unix and Linux
  versions. You should be able to
browse this manual through your Emacs's help system.
</p>
<p>
  Despite its lack of direct support for dependency derivation,
and despite its generally ad-hoc approach, in mid-2003
  <em>autoconf</em> is clearly the most popular of the
makefile generators, and has been for some years. It has eclipsed
  <em>Imake</em> and driven at least one major
competitor (
  <em>metaconfig</em>) out of use.
</p>
<p>
  A reference,
  <em>GNU Autoconf, Automake and Libtool</em>
  is available <sup><a href="#Vaughan" title="[Vaughan]">[Vaughan]</a></sup>. We'll have
more to say about
  <em>autoconf</em>, from a slightly
different angle, in
  <a href="#portabilitychapter" title="Chapter 17. Portability">
   Chapter 17</a>.
</p>
<h5 id="id2988205"><a href="#id2988205">§</a>automake</h5>
<p>
  <em>automake</em> is an attempt to add
  <em>Imake</em> -like dependency derivation as a layer
on top of
autoconf(1). You
write
  <code>Makefile.am</code> templates in a broadly
  <em>Imake</em> -like notation;
automake(1)
compiles them to
  <code>Makefile.in</code> files, which
  <em>autoconf</em> 's
  <code>configure</code> scripts then operate
on.
</p>
<p>
  <em>automake</em> is still relatively new
technology in mid-2003. It is used in several
FSF
  projects but has not yet been widely adopted elsewhere.  While its
general approach looks promising, it is as yet rather brittle —
it works when used in stereotyped ways but tends to break badly if you
try to do anything unusual with it.
</p>
<p>
  Complete on-line documentation is shipped with
  <em>automake</em>, which can be downloaded from the
FSF
  archive site.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2986827" id="ftn.id2986827">[136]</a></sup>
  <a href="http://www.tip.net.au/~millerp/rmch/recu-make-cons-harm.html">
   Available
on the Web</a>.
</p>

<p><sup><a href="#id2987288" id="ftn.id2987288">[137]</a></sup>
  A unit test is test code attached to a
module to verify correct performance.  Use of the term ‘unit
test’ suggests that the test is written concurrently
with the code by the developer of the code, and implies a discipline
in which module releases aren't considered complete until they have
attached test code. The term and the concept originated in the
“Extreme Programming” methodology popularized by Kent
Beck, but has gained wide acceptance among Unix programmers since
about 2001.
</p>
</div>


<!-- FILE: ch15s05.html -->
<h3 id="ch15s05"><a href="#ch15s05">§</a>Version-Control Systems</h3>
<p>
  Code evolves. As a project moves from first-cut prototype to
deliverable, it goes through multiple cycles in which you explore
new ground, debug, and then stabilize what you've accomplished. And
this evolution doesn't stop when you first deliver for production.
Most projects will need to be maintained and enhanced past the 1.0
stage, and will be released multiple times.  Tracking all that 
detail is just the sort of thing computers are good at and 
humans are not.
</p>
<h4 id="id2988357"><a href="#id2988357">§</a>Why Version Control?</h4>
<p>
  Code evolution raises several practical problems that can be
major sources of friction and drudgery — thus a serious drain on
productivity. Every moment spent on these problems is a moment not
spent on getting the design and function of your project right.
</p>
<p>
  Perhaps the most important problem is
  <em>reversion</em>.  If you make a change, and discover
it's not viable, how can you revert to a code version that is known
good? If reversion is difficult or unreliable, it's hard to risk
making changes at all (you could trash the whole project, or make many
hours of painful work for yourself).
</p>
<p>
  Almost as important is
  <em>change tracking</em>. You
know your code has changed; do you know why? It's easy to forget the
reasons for changes and step on them later. If you have collaborators
on a project, how do you know what they have changed while you weren't
looking, and who was responsible for each change?
</p>
 <blockquote>
  <p>
   Amazingly often, it is useful to ask what
   <em>you</em>
   have changed since the last known-good
version, even if you have no collaborators.  This often uncovers
unwanted changes, such as forgotten debugging code.  I now do this
routinely before checking in a set of changes.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  Another issue is
  <em>bug tracking</em>. It's quite common
to get new bug reports for a particular version after the code has
mutated away from it considerably. Sometimes you can recognize
immediately that the bug has already been stomped, but often you
can't. Suppose it doesn't reproduce under the new version. How do you
get back the state of the code for the old version in order to
reproduce and understand it?
</p>
<p>
  To address these problems, you need procedures for keeping a
history of your project, and annotating it with comments that
explain the history. If your project has more than one developer,
you also need mechanisms for making sure developers don't overwrite
each others' versions.
</p>
<h4 id="id2988464"><a href="#id2988464">§</a>Version Control by Hand</h4>
<p>
  The most primitive (but still very common) method is all
hand-hacking. You snapshot the project periodically by manually
copying everything in it to a backup. You include history comments
in source files. You make verbal or email arrangements with other
developers to keep their hands off certain files while you hack
them.
</p>
<p>
  The hidden costs of this hand-hacking method are high,
especially when (as frequently happens) it breaks down. The
procedures take time and concentration; they're prone to error, and
tend to get slipped under pressure or when the project is in
trouble — that is, exactly when they are most needed.
</p>
<p>
  As with most hand-hacking, this method does not scale well.  It
restricts the granularity of change tracking, and tends to lose
metadata details such as the order of changes, who did them, and why.
Reverting just a part of a large change can be tedious and time
consuming, and often developers are forced to back up farther than
they'd like after trying something that doesn't work.
</p>
<h4 id="id2988503"><a href="#id2988503">§</a>Automated Version Control</h4>
<p>
  To avoid these problems, you can use a
  <em>
   version-control
system
</em>
  (VCS), a suite of programs that automates away most of
the drudgery involved in keeping an annotated history of your
project and avoiding modification conflicts.
</p>
<p>
  Most VCSs share the same basic logic. To use one, you start by
  <em>registering</em>
  a collection of source files —
that is, telling your VCS to start archive files describing their
change histories. Thereafter, when you want to edit one of these
files, you have to
  <em>check out</em>
  the file —
assert an exclusive lock on it. When you're done, you
  <em>
   check
in
</em>
  the file, adding your changes to the archive, releasing
the lock, and entering a change comment explaining what you
did.
</p>
<p>
  The history of the project is not necessarily linear. All VCSs
in common use actually allow you to maintain a tree of variant
versions (for ports to different machines, say) with tools for merging
branches back into the main “trunk” version.  This
feature becomes important as the size and dispersion of the 
development group increases.  It needs to be used with care, 
however; multiple active variants of the code base can be 
very confusing (just associated bug reports to the right version
are not necessarily easy), and automated merging of branches does
not guaranteed that the combined code works.
</p>
<p>
  Most of the rest of what a VCS does is convenience: labeling,
and reporting features surrounding these basic operations, and tools
which allow you to view differences between versions, or to group a
given set of versions of files as a named
  <em>release</em>
  that can be examined or reverted to at any time without losing later
changes.
</p>
<p>
  VCSs have their problems. The biggest one is that using a VCS
involves extra steps every time you want to edit a file, steps
that developers in a hurry tend to want to skip if they have to be
done by hand. Near the end of this chapter we'll discuss a way to
solve this problem.
</p>
<p>
  Another problem is that some kinds of natural operations tend to
confuse VCSs. Renaming files is a notorious trouble spot; it's not
easy to automatically ensure that a file's version history will be
carried along with it when it is renamed.  Renaming problems are
particularly difficult to resolve when the VCS supports
branching.
</p>
<p>
  Despite these difficulties, VCSs are a huge boon to productivity
and code quality in many ways, even for small single-developer
projects. They automate away many procedures that are just tedious
work. They help a lot in recovering from mistakes. Perhaps most
importantly, they free programmers to experiment by guaranteeing
that reversion to a known-good state will always be easy.
</p>
<p>
  (VCSs, by the way, are not merely good for program code; the
manuscript of this book was maintained as a collection of files
under
  <em>RCS</em> while it was being written.)
</p>
<h4 id="id2988625"><a href="#id2988625">§</a>Unix Tools for Version Control</h4>
<p>
  Historically, three VCSs have been of major significance in the
Unix world, and we'll survey them here. For an extended introduction
and tutorial, consult
  <em>Applying RCS and SCCS</em> <sup><a href="#Bolinger-Bronson" title="[Bolinger-Bronson]">[Bolinger-Bronson]</a></sup>.
</p>
<h5 id="id2988648"><a href="#id2988648">§</a>Source Code Control System (SCCS)</h5>
<p>
  The first was
  <em>SCCS</em>, the original
Source Code Control System developed by Bell Labs around 1980 and
featured in System III
  Unix.
  <em>SCCS</em> seems to have been the first serious attempt at a unified source-code
management system; concepts that it pioneered are still found at some
level in all later ones, including commercial Unix and Windows
products such as ClearCase.
</p>
<p>
  <em>SCCS</em> itself is, however, now
obsolete; it was proprietary Bell Labs software.  Superior open-source
alternatives have since been developed, and most of the Unix world has
converted to those.
  <em>SCCS</em> is still in use to
manage old projects at some commercial vendors, but can no longer be
recommended for new projects.
</p>
<p>
  No complete open-source implementation of
  <em>SCCS</em> exists. A clone called CSSC
(Compatibly Stupid Source Control) is in development under the
sponsorship of the FSF.
</p>
<h5 id="id2988732"><a href="#id2988732">§</a>Revision Control System (RCS)</h5>
<p>
  The superior open-source alternatives began with RCS (Revision
Control System), born at Purdue University a few years after
  <em>SCCS</em> and originally distributed with 4.3BSD
Unix. It is
logically similar to
  <em>SCCS</em> but has a cleaner
command interface, and good facilities for grouping together entire
project releases under symbolic names.
</p>
<p>
  <em>RCS</em> is currently the most widely
used version control system in the Unix world. Some other Unix
version-control systems use it as a back end or underlayer. It is well
suited for single-developer or small-group projects hosted at a single
development shop.
</p>
<p>
  The
  <em>RCS</em> sources are maintained and
distributed by the FSF. Free ports are available for
Microsoft operating systems
  and VAX VMS.
</p>
<h5 id="id2988824"><a href="#id2988824">§</a>Concurrent Version System (CVS)</h5>
<p>
  CVS (Concurrent Version System) began life as a front end to
  <em>RCS</em> developed in the early 1990s, but the
model of version control it uses was different enough that it
immediately qualified as a new design. Modern implementations don't
rely on
  <em>RCS</em>.
</p>
<p>
  Unlike
  <em>RCS</em> and
  <em>SCCS</em>,
  <em>CVS</em> doesn't exclusively lock files when they're checked out. Instead, it
tries to reconcile nonconflicting changes mechanically when they're
checked back in, and requests human help on conflicts. The design
works because patch conflicts are much less common than one might
intuitively think.
</p>
<p>
  The interface of
  <em>CVS</em> is significantly
more complex than that of
  <em>RCS</em>, and it needs
a lot more disk space. These properties make it a poor choice for small
projects. On the other hand,
  <em>CVS</em> is well
suited to large multideveloper efforts distributed across several
development sites connected by the
Internet.
  <em>CVS</em> tools on a client machine can
easily be told to direct their operations to a repository located on a
different host.
</p>
<p>
  The open-source community makes heavy use of
  <em>CVS</em> for projects such as GNOME and
Mozilla. Typically, such
  <em>CVS</em> repositories
allow anyone to check out sources remotely. Anyone can, therefore,
make a local copy of a project, modify it, and mail change patches to
the project maintainers. Actual write access to the repository is more
limited and has to be explicitly granted by the project maintainers. A
developer who has such access can perform a commit option from his
modified local copy, which will cause the local changes to get made
directly to the remote repository.
</p>
<p>
  You can see an example of a well-run
  <em>CVS</em> repository, accessible over the
Internet, at the
  <a href="http://cvs.gnome.org">
   GNOME CVS
site</a>. This site illustrates the use of
  <em>CVS</em> -aware browsing tools such as Bonsai,
which are useful in helping a large and decentralized group of
developers coordinate their work.
</p>
<p>
  The social machinery and philosophy accompanying the use of
  <em>CVS</em> is as important as the details of the
tools. The assumption is that projects
  <em>will</em>
  be
open and decentralized, with code subject to peer review and
inspection even by developers who are not officially members of the
project group.
</p>
<p>
  Just as importantly,
  <em>CVS</em> 's
nonlocking philosophy means that projects can't be blocked by a lock
if a programmer disappears in the middle of making some changes.
  <em>CVS</em> thus allows developers to avoid the
“single person point of failure” problem; in turn, this
means that project boundaries can be fluid, casual contributions are
relatively easy, and projects are not required to have an elaborate
hierarchy of control.
</p>
<p>
  The
  <em>CVS</em> sources are maintained and
distributed by the FSF.
</p>
<p>
  <em>CVS</em> has significant problems. Some
are merely implementation bugs, but one basic problem is that your
project's file namespace is not versioned in the same way changes to
files themselves are. Thus,
  <em>CVS</em> is easily
confused by file renamings, deletions, and additions.  Also,
  <em>CVS</em> records changes on a per-file basis,
rather than as
  <em>sets</em>
  of changes made to files.  This
makes it harder to back out to specific versions, and harder to handle
partial check-ins.  Fortunately, none of these problems are intrinsic
to the nonlocking style, and they have been successfully addressed by
newer version-control systems.
</p>
<h5 id="id2989087"><a href="#id2989087">§</a>Other Version-Control Systems</h5>
<p>
  <em>CVS</em> 's design problems are sufficient
to have created demand for a better open-source VCS. Several such
efforts are under way as of 2003. The most notable of these are
  <em>Aegis</em> and
  <em>Subversion</em>.
</p>
<p>
  <a href="http://www.pcug.org.au/~millerp/aegis/aegis.html">
   Aegis</a>
  has the longest history of any of these alternatives, has hosted
its own development since 1991, and is a mature production system.
It features a heavy emphasis on regression-testing and
validation.
</p>
<p>
  <a href="http://subversion.tigris.org/">
   Subversion</a>
  is
positioned as “CVS done right”, with the known design
problems fully addressed, and in 2003 probably has the best
near-term prospect of replacing
  <em>CVS</em>.
</p>
<p>
  The
  <a href="http://www.bitkeeper.com">
   BitKeeper</a>
  project
explores some interesting design ideas related to change-sets and
multiple distributed code repositories. Linus Torvalds uses Bitkeeper 
for the Linux kernel sources.  Its non-open-source license
is, however, controversial, and has significantly retarded the
acceptance of the product.
</p>



<!-- FILE: ch15s06.html -->
<h3 id="ch15s06"><a href="#ch15s06">§</a>Runtime Debugging</h3>
<p>
  Anyone who has been programming longer than a week knows that
getting the syntax of your programming language right is the
  <em>easy</em>
  part of debugging. The hard part comes after that,
when you need to understand why your syntactically correct program
doesn't behave as you expect.
</p>
<p>
  The Unix tradition encourages developers to anticipate this
problem by designing for transparency — in particular, designing
programs in such a way that their internal data flows are readily
monitored with the naked eye and simple tools, and readily mentally
modeled. This is a topic we covered in detail in
  <a href="#transparencychapter" title="Chapter 6. Transparency">
   Chapter 6</a>.  Design for
transparency is valuable both for preventing bugs and for easing the
runtime-debugging task.
</p>
<p>
  Design for transparency is not, however, sufficient in itself.
When you are debugging a program at runtime, it's extremely useful to
be able to examine the state of your program at runtime, set
breakpoints, and execute pieces of it down to the single-statement
level in a controlled way. Unix has a long tradition of hosting
programs to help you with this. Open-source Unixes feature a powerful
one called
  <em>gdb</em> (yet another
FSF
  project) that supports C
  and C++
  debugging.
</p>
<p>
  Perl,
Python,
Java, and Emacs
Lisp
  all
support standard packages or programs (included with their base
distributions) that allow you to set breakpoints, control execution,
and do general runtime-debugger things. Tcl, designed as a small language for small
projects, has no such facility (though it does have a trace facility
that can be used to watch variables at runtime).
</p>
<p>
  Remember the Unix philosophy. Spend your time on design quality, not
the low-level details, and automate away everything you can —
including the detail work of runtime debugging.
</p>



<!-- FILE: ch15s07.html -->
<h3 id="ch15s07"><a href="#ch15s07">§</a>Profiling</h3>
<p>
  As a general rule, 90% of the execution time of your program
will be spent in 10% of its code. Profilers are tools that help you
identify the 10% of hot spots that constrain the speed of your
program. This is a good thing for making it faster.
</p>
<p>
  But in the Unix tradition, profilers have a far more important
function. They enable you
  <em>not</em>
  to optimize the other 90%!
This is good, and not just because it saves you work. The
  <em>really</em>
  valuable effect is that not optimizing that 90%
holds down global complexity and reduces bugs.
</p>
<p>
  You may recall that we quoted Donald
Knuth
  observing “Premature optimization is the root of all
evil”
  in
  <a href="#philosophychapter" title="Chapter 1. Philosophy">
   Chapter 1</a>, and that
Rob Pike
  and Ken
Thompson
  had a
few pungent observations on the topic as well. These were the voices
of experience. Do good design.  Think about what's
  <em>right</em>
  first. Tune for efficiency later.
</p>
<p>
  Profilers help you do this. If you get in the good habit of
using them, you can get rid of the bad habit of premature
optimization. Profilers don't just change the way you work; they
change how you think.
</p>
<p>
  Profilers for compiled languages rely on instrumenting object
code, so they are even more platform-dependent than compilers. On the
other hand, a compiled-language profiler doesn't care about the source
language of the programs it instruments. Under Unix, the single
profiler
gprof(1)
handles C,
C++, and all
other compiled languages.
</p>
<p>
  Perl,
Python, and
Emacs Lisp
  have their own profilers included in
their basic distributions; these are portable across all platforms on
which the host languages themselves run. Java
  has built-in profiling.
Tcl
  has no
profiling support as yet.
</p>



<!-- FILE: ch15s08.html -->
<h3 id="ch15s08"><a href="#ch15s08">§</a>Combining Tools with Emacs</h3>
<p>
  One of the things the Emacs editor is
very good at is acting as a front end for other development tools (we
discussed this from a philosophical angle in
  <a href="#complexitychapter" title="Chapter 13. Complexity">
   Chapter 13</a>).  In fact, nearly every tool we've
discussed in this chapter can be driven from within an
Emacs editor session through front ends
that give them greater utility than they would have running
standalone.
</p>
<p>
  To illustrate this, we'll walk you through the use of these
tools with Emacs in a typical
build/test/debug cycle. For details on them, see
Emacs's own on-line help system; this
section just gives you an overview, to motivate you to learn
more.
</p>
<p>
  Read and learn — not just about
Emacs, but about the mental habit of
looking for synergies between programs, and creating them. Try to read
this section as instruction in philosophy, not just technique.
</p>
<h4 id="id2989559"><a href="#id2989559">§</a>Emacs and make</h4>
<p>
  <em>Make</em>, for example, can be started with the Emacs command
  <code>ESC-x compile</code> followed by an Enter. This command will run make(1)
in the current directory, capturing the output in an Emacs buffer.
</p>
<p>
  This by itself wouldn't be very useful. But
Emacs's
  <em>make</em> mode knows about the error message format (featuring a source file and
line number) emitted by Unix C
  compilers and many other tools.
</p>
<p>
  If anything run by
  <em>make</em> issues error
messages, the command <code>Ctl-X `</code> (control-X-backquote)
will try to parse them and take you to each error location in turn,
popping open a window on the appropriate file and taking the cursor to
the error line.<sup><a href="#ftn.id2989640" id="id2989640">[138]</a></sup>
</p>
<p>
  This makes it extremely easy to step through an entire build,
fixing any syntax that has been broken since the last compile.
</p>
<h4 id="id2989677"><a href="#id2989677">§</a>Emacs and Runtime Debugging</h4>
<p>
  For catching runtime errors, Emacs
offers similar integration with your symbolic debugger — that
is, you can use an Emacs mode to set
breakpoints in your programs and examine their runtime state. You run
the debugger by sending it commands through an
Emacs window. Whenever the debugger stops
on a breakpoint, the message the debugger ships back about the source
location is parsed and used to pop up a window on the source around the
breakpoint.
</p>
<p>
  Emacs's Grand Unified Debugger mode
supports all the major C debuggers:
gdb(1),
sdb(1),
dbx(1),
and
xdb(1). It
also supports Perl
  symbolic debugging using the perldb
module, and the standard debuggers for both
Java
  and
Python. Facilities built into Emacs Lisp
itself support interactive debugging of Emacs Lisp
code.
</p>
<p>
  At time of writing (mid-2003) there is not yet support for
Tcl
  debugging
from within Emacs. The design of Tcl is
such that it seems unlikely to be added.
</p>
<h4 id="id2989781"><a href="#id2989781">§</a>Emacs and Version Control</h4>
<p>
  Once you've corrected your program's syntax and fixed its
runtime bugs, you may want to save the changes into a
version-controlled archive. If you've only tried running
version-control tools from the shell, it's hard to blame you for
sloughing off this important step. Who wants to have to remember to
run checkout/checkin commands around every edit operation?
</p>
<p>
  Fortunately, Emacs offers help here
too. Code built into Emacs implements a
simple-to-use front end for
  <em>SCCS</em>,
  <em>RCS</em>,
  <em>CVS</em>, or
Subversion. The single command <code>Ctl-x v v</code> tries to
deduce the next logical version-control operation to do on the file
you are visiting. The operations this includes are registering a file,
checking out and locking it, and checking it back in (accepting a
change comment in a pop-up buffer).<sup><a href="#ftn.id2989834" id="id2989834">[139]</a></sup>
</p>
<p>
  Emacs also helps you view the change
history of version-controlled files, and helps you back out changes
you don't want. It makes it easy to apply version-control operations
to whole sets or project directory trees of files. In general, it does
a pretty good job of making version-control operations painless.
</p>
<p>
  The implications of these features are larger than you might
guess before you've gotten used to it. You'll find, once you get used
to fast and easy version control, that it's extremely
liberating. Because you know you can always revert to a known-good
state, you'll find you feel more free to develop in a fluid and
exploratory way, trying lots of changes out to see their
effects.
</p>
<h4 id="id2989869"><a href="#id2989869">§</a>Emacs and Profiling</h4>
<p>
  Surprise...this is perhaps the only phase of the development
cycle in which Emacs front-ending does
  <em>not</em>
  offer substantial help. Profiling is an
intrinsically batchy operation — instrument your program, run
it, view the statistics, speed-tune the code with an editor,
repeat. There isn't much room for Emacs
leverage in the profiling-specific parts of this cycle.
</p>
<p>
  Nevertheless, there's a good tutorial reason for us to think
about Emacs and profiling. If you found
yourself analyzing a
  <em>lot</em>
  of profiling reports, it
might pay you to write a mode in which a mouse click or keystroke on a
profile report line visited the source of the relevant function. This
actually would be fairly easy to do using the
Emacs ‘tags’ code. In fact, by
the time you read this, some other reader may already have written
such a mode and contributed it to the public
Emacs code base.
</p>
<p>
  The real point here is again a philosophical one. Don't drudge
— drudging wastes your time and productivity! If you find yourself
spending a lot of time on the low-level mechanical parts of
development, step back. Apply the Unix philosophy. Use your toolkit
to automate or semi-automate the task.
</p>
<p>
  Then give back something in return for all you've inherited, by
posting your solution as open-source software to the Internet. Help
liberate your fellow programmers from drudgery, too.
</p>
<h4 id="id2989926"><a href="#id2989926">§</a>Like an IDE, Only Better</h4>
<p>
  Earlier in this chapter we asserted that
Emacs can give you capabilities resembling
those of a conventional integrated development environment, only
better. By now you should have enough facts in hand to see how that
can be true. You can run entire development projects from inside
Emacs, driving the low-level mechanics with
a few keystrokes and saving yourself the mental effort and disruption
of constantly switching contexts.
</p>
<p>
  The Emacs-enabled development style
trades away some capabilities of advanced IDEs, like graphical views
of program structure. But those are frills. What
Emacs gives you in return is flexibility
and control. You're not limited by the imagination of the IDE designer:
you can tweak, customize, and add task-related intelligence
using Emacs Lisp. Also, Emacs is better at
supporting mixed-language development than conventional IDEs.
</p>
<p>
  Finally, you're not limited to accepting what one small group of
IDE developers sees fit to support. By keeping an eye on the
open-source community, you can benefit from the work of thousands of your
peers, Emacs-using developers facing
challenges much like yours. This is much more effective — and
much more fun.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2989640" id="ftn.id2989640">[138]</a></sup>
  Look at
p+processes-&gt;compile
under the Emacs help menu for more
information on these and related compilation-control
commands.
</p>

<p><sup><a href="#id2989834" id="ftn.id2989834">[139]</a></sup>
  See the subsection
of the Emacs on-line documentation titled
  <em>Version Control</em>
  for more details on these and related
commands.
</p>
</div>


<!-- FILE: reusechapter.html -->
<h3 id="reusechapter"><a href="#reusechapter">§</a>Chapter 16. Reuse</h3>
 <blockquote class="epigraph">
  <p>
   When the superior man refrains from acting, his force is felt
for a thousand miles.
  </p>
  <span>
   – Tao Te Ching (as popularly mistranslated)
  </span>
 </blockquote>
<p>
  Reluctance to do unnecessary work is a great virtue in
programmers. If the Chinese sage Lao-Tze were alive today and still
teaching the way of the Tao, he would probably be mistranslated as:
When the superior programmer refrains from coding, his force is felt
for a thousand miles. In fact, recent translators have suggested that
the Chinese term
  <span class="foreignphrase">
   <em>wu-wei</em> </span>
  that has
traditionally been rendered as “inaction” or
“refraining from action” should probably be read as
“least action” or “most efficient action” or
“action in accordance with natural law”, which is an even
better description of good engineering practice!
</p>
<p>
  Remember the Rule of Economy.  Re-inventing fire and the wheel
for every new project is terribly wasteful.  Thinking time is precious
and very valuable relative to all the other inputs that go into
software development; accordingly, it should be spent solving new
problems rather than rehashing old ones for which known solutions
already exist. This attitude gives the best return both in the
“soft” terms of developing human capital and in the
“hard” terms of economic return on development
investment.
</p>
 <blockquote>
  <p>
   Reinventing the wheel is bad not only because it
wastes time, but because reinvented wheels are often square.  There is an
almost irresistible temptation to economize on reinvention time by
taking a shortcut to a crude and poorly-thought-out version, which
in the long run often turns out to be false economy.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  The most effective way to avoid reinventing the wheel is to
borrow someone else's design and implementation of it. In other
words, to reuse code.
</p>
<p>
  Unix supports reuse at every level from individual library
modules up to entire programs, which Unix helps you script and
recombine.  Systematic reuse is one of the most important
distinguishing behaviors of Unix programmers, and the experience of
using Unix should teach you a habit of trying to prototype solutions
by combining existing components with a minimum of new invention,
rather than rushing to write standalone code that will only be used
once.
</p>
<p>
  The virtuousness of code reuse is one of the great
apple-pie-and-motherhood verities of software development.  But many
developers entering the Unix community from a basis of experience in
other operating systems have never learned (or have unlearned) the
habit of systematic reuse.  Waste and duplicative work is rife, even
though it seems to be against the interests both of those who pay for
code and those who produce it.  Understanding why such dysfunctional
behavior persists is the first step toward changing it.
</p>



<!-- FILE: ch16s01.html -->
<h3 id="ch16s01"><a href="#ch16s01">§</a>The Tale of J. Random Newbie</h3>
<p>
  Why do programmers reinvent wheels?  There are many reasons,
reaching all the way from the narrowly technical to the psychology of
programmers and the economics of the software production system.  The
damage from the endemic waste of programming time reaches all these
levels as well.
</p>
<p>
  Consider the first, formative job experience of J. Random
Newbie, a programmer fresh out of college.  Let us assume that he (or
she) has been taught the value of code reuse and is brimming with
youthful zeal to apply it.
</p>
<p>
  Newbie's first project puts him on a team building some large
application.  Let's say for the sake of example that it's a GUI
intended to help end users intelligently construct queries for and
navigate through a large database.  The project managers have
assembled what they deem to be a suitable collection of tools and
components, including not merely a development language but many
libraries as well.
</p>
<p>
  The libraries are crucial to the project.  They package many
services — from windowing widgets and network connections on up
to entire subsystems like interactive help — that would
otherwise require immense quantities of additional coding, with a
severe impact on the project's budget and its ship date.
</p>
<p>
  Newbie is a little worried about that ship date.  He may lack
experience, but he's read
  <em>Dilbert</em> and heard a
few war stories from experienced programmers.  He knows management has
a tendency to what one might euphemistically call
“aggressive” schedules.  Perhaps he has read Ed Yourdon's
  <em>Death March</em> <sup><a href="#Yourdon" title="[Yourdon]">[Yourdon]</a></sup>, which as long ago as 1996 noted
that a majority of projects are on a time and resource budget at least
50% too tight, and that the trend is for that squeeze to get worse.
</p>
<p>
  But Newbie is bright and energetic.  He figures his best chance
of succeeding is to learn to use the tools and libraries that have
been handed to him as intelligently as possible.  He limbers up his
typing fingers, hurls himself at the challenge...and enters hell.
</p>
<p>
  Everything takes longer and is more painful than he expects.
Beneath the surface gloss of their demo applications, the components
he is re-using seem to have edge cases in which they behave
unpredictably or destructively — edge cases his code tickles
daily.  He often finds himself wondering what the library programmers
were thinking.  He can't tell, because the components are inadequately
documented — often by technical writers who aren't programmers
and don't think like programmers.  And he can't read the source code
to learn what it is actually doing, because the libraries are opaque
blocks of object code under proprietary licenses.
</p>
<p>
  Newbie has to code increasingly elaborate workarounds for
component problems, to the point where the net gain from using the
libraries starts to look marginal.  The workarounds make his code
progressively grubbier.  He probably hits a few places where a library
simply cannot be made to do something crucially important that is
theoretically within its specifications.  Sometimes he is sure there
is some way to actually make the black box perform, but he can't
figure out what it is.
</p>
<p>
  Newbie finds that as he puts more strain on the libraries, his
debugging time rises exponentially.  His code is bedeviled with
crashes and memory leaks that have trace paths leading into the
libraries, into code he can't see or modify.  He knows most of those
trace paths probably lead back out to his code, but without source it
is very difficult to trace through the bits he didn't write.
</p>
<p>
  Newbie is growing horribly frustrated.  He had heard in college
that in industry, a hundred lines of finished code a week is
considered good performance. He had laughed then, because he was many
times more productive than that on his class projects and the code he
wrote for fun.  Now it's not funny any more.  He is wrestling not
merely with his own inexperience but with a cascade of problems
created by the carelessness or incompetence of others — problems
he can't fix, but can only work around.
</p>
<p>
  The project schedule is slipping.  Newbie, who dreamed of being
an architect, finds himself a bricklayer trying to build with bricks
that won't stack properly and that crumble under load-bearing
pressure.  But his managers don't want to hear excuses from a novice
programmer; complaining too loudly about the poor quality of the
components is likely to get him in political trouble with the senior
people and managers who selected them.  And even if he could win that
battle, changing components would be a complicated proposition
involving batteries of lawyers peering narrowly at licensing
terms.
</p>
<p>
  Unless Newbie is very, very lucky, he is not going to be able to
get library bugs fixed within the lifetime of his project.  In his
saner moments, he may realize that the working code in the libraries 
doesn't draw his attention the way the bugs and omissions do. He'd love
to sit down for a clarifying chat with the component developers; he
suspects they can't be the idiots their code sometimes suggests, just
programmers like him working within a system that frustrates their
attempts to do the right thing.  But he can't even find out who they are
— and if he could, the software vendor they work for probably
wouldn't let them talk to him.
</p>
<p>
  In desperation, Newbie starts making his own bricks —
simulating less stable library services with more stable ones and
writing his own implementations from scratch.  His replacement code,
because he has a complete mental model of it that he can refresh by
rereading, tends to work relatively well and be easier to debug than
the combination of opaque components and workarounds it
replaces.
</p>
<p>
  Newbie is learning a lesson; the less he relies on other
peoples' code, the more lines of code he can get written.  This lesson
feeds his ego.  Like all young programmers, deep down he thinks he is
smarter than anyone else.  His experience seems, superficially, to be
confirming this.  He begins building his own personal toolkit, one
better fitted to his hand.
</p>
<p>
  Unfortunately, the roll-your-own reflexes Newbie is acquiring
are a short-term local optimization that will cause long-term
problems.  He may get more lines of code written, but the actual value
of what he produces is likely to drop substantially relative to what
it would have been if he were doing successful reuse.  More code does
not equal better code, not when it's written at a lower level and
largely devoted to reinventing wheels.
</p>
<p>
  Newbie has at least one more demoralizing experience in store,
when he changes jobs.  He is likely to discover that he can't take his
toolkit with him.  If he walks out of the building with code he wrote
on company time, his old employers could well regard this as
intellectual-property theft.  His new employers, knowing this, are not
likely to react well if he admits to reusing any of his old
code.
</p>
<p>
  Newbie could well find his toolkit is useless even if he can
sneak it into the building at his new job.  His new employers may use
a different set of proprietary tools, languages, and libraries. It is
likely he will have to learn a somewhat new set of techniques and
reinvent a new set of wheels each time he changes projects.
</p>
<p>
  Thus do programmers have reuse (and other good practices that
go with it, like modularity and transparency) systematically
conditioned out of them by a combination of technical problems,
intellectual-property barriers, politics, and personal ego needs.
Multiply J. Random Newbie by a hundred thousand, age him by decades,
and have him grow more cynical and more used to the system year by
year.  There you have the state of much of the software industry, a
recipe for enormous waste of time and capital and human skill —
even
  <em>before</em>
  you factor in vendors' market-control
tactics, incompetent management, impossible deadlines, and all the
other pressures that make doing good work difficult.
</p>
<p>
  The professional culture that springs from J. Random Newbie's
experiences will reflect them in the large.  Programming shops will
have a ferocious Not Invented Here complex.  They will be poisonously
ambivalent about code reuse, pushing inadequate but heavily marketed
vendor components on their programmers in order to meet schedule
crunches, while simultaneously rejecting reuse of the programmers' own
tested code.  They will churn out huge volumes of ad-hoc, duplicative
software produced by programmers who know the results will be garbage but
are glumly resigned to never being able to fix anything but their own
individual pieces.
</p>
<p>
  The closest equivalent of code reuse to emerge in such a
culture will be a dogma that code once paid for can never be thrown
away, but must instead be patched and kluged even when all parties
know that it would be better to scrap and start anew.  The
products of this culture will become progressively more bloated and
buggy over time even when every individual involved is trying his or
her hardest to do good work.
</p>



<!-- FILE: ch16s02.html -->
<h3 id="ch16s02"><a href="#ch16s02">§</a>Transparency as the Key to Reuse</h3>
<p>
  We field-tested the tale of J. Random Newbie on a number of
experienced programmers.  If you the reader are one yourself, we
expect you responded to it much as they did: with groans of
recognition.  If you are not a programmer but you manage programmers,
we sincerely hope you found it enlightening.  The tale is intended to
illustrate the ways in which different levels of pressure against reuse
reinforce each other to create a magnitude of problem not linearly
predictable from any individual cause.
</p>
<p>
  So accustomed are most of us to the background assumptions of
the software industry that it can take considerable mental effort
before the primary causes of this problem can be separated from the
accidents of narrative.  But they are not, in the end, very
complex.
</p>
<p>
  At the bottom of most of J. Random Newbie's troubles (and the
large-scale quality problems they imply) is
transparency
  — or, rather, the lack of it.  You can't fix what you can't see
inside.  In fact, for any software with a nontrivial API, you can't
even properly
  <em>use</em>
  what you can't see inside.
Documentation is inadequate not merely in practice but in principle;
it cannot convey all the nuances that the code embodies.
</p>
<p>
  In
  <a href="#transparencychapter" title="Chapter 6. Transparency">
   Chapter 6</a>, we
observed how central transparency is to good software.
Object-code-only components destroy the transparency of a software
system, On the other hand, the frustrations of code reuse are far less
likely to bite when the code you are attempting to reuse is available
for reading and modification. Well-commented source code is its own
documentation. Bugs in source code can be fixed. Source can be
instrumented and compiled for debugging to make probing its behavior
in obscure cases easier. And if you need to change its behavior, you
can do that.
</p>
<p>
  There is another vital reason to demand source code.  A lesson
Unix programmers have learned through decades of constant change is
that source code lasts, object code doesn't.  Hardware platforms
change, service components like support libraries change, the
operating system grows new APIs and deprecates old ones.  Everything
changes — but opaque binary executables cannot adapt to change.
They are brittle, cannot be reliably forward-ported, and have to be
supported with increasingly thick and error-prone layers of emulation
code.  They lock users into the assumptions of the people who built
them.  You need source because, even if you have neither the
intention nor the need to change the software, you will have to
rebuild it in new environments to keep it running.
</p>
<p>
  The importance of transparency and the code-legacy problem are
reasons that you should require the code you reuse to be open to
inspection and modification.<sup><a href="#ftn.id2990172" id="id2990172">[140]</a></sup>
  It is not a complete argument for what
is now called ‘open source’; because ‘open
source’ has rather stronger implications than simply requiring
code to be transparent and visible.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2990172" id="ftn.id2990172">[140]</a></sup>
  NASA, which consciously
builds software intended to have a service life of decades, has learned
to insist on source-code availability for all space avionics
software.
</p>
</div>


<!-- FILE: ch16s03.html -->
<h3 id="ch16s03"><a href="#ch16s03">§</a>From Reuse to Open Source</h3>
<p>
  In the early days of Unix, components of the operating system,
its libraries, and its associated utilities were passed around as
source code; this openness was a vital part of the Unix culture.  We
described in
  <a href="#historychapter" title="Chapter 2. History">
   Chapter 2</a>
  how,
when this tradition was disrupted after 1984, Unix lost its initial
momentum. We have also described how, a decade later, the rise of the
GNU
  toolkit and
Linux
  prompted a rediscovery of the value of open-source code.
</p>
<p>
  Today, open-source code is again one of the most powerful tools
in any Unix programmer's kit. Accordingly, though the explicit concept
of “open source” and the most widely used
open-source
  licenses are decades younger than Unix itself, it's important to
understand both to do leading-edge development in today's
Unix culture.
</p>
<p>
  Open source
  relates to code reuse in much the way romantic love relates to sexual
reproduction — it's possible to explain the former in terms of
the latter, but to do so is to risk overlooking much of what makes the
former interesting.  Open source does not reduce to merely being a
tactic for supporting reuse in software development.  It is an
emergent phenomenon, a social contract among developers and users that
tries to secure several advantages related to transparency.
As such, there are several different ways to approaching an
understanding of it.
</p>
<p>
  Our historical description earlier in this book chose one angle
by focusing on causal and cultural relationships between Unix and open
source.  We'll discuss the institutions and tactics of open-source
development in
  <a href="#opensourcechapter" title="Chapter 19. Open Source">
   Chapter 19</a>. In discussing the theory and practice
of code reuse, it's useful to think of open source more specifically,
as a direct response to the problems we dramatized in the tale of
J. Random Newbie.
</p>
<p>
  Software developers want the code they use to be transparent.
Furthermore, they don't want to lose their toolkits and their
expertise when they change jobs.   They get tired of being victims, fed
up with being frustrated by blunt tools and intellectual-property
fences and having to repeatedly re-invent the wheel.
</p>
<p>
  These are the motives for open source that flow from J. Random
Newbie's painful initiatory experience with reuse.  Ego needs play a
part here, too; they give pervasive emotional force to what would
otherwise be a bloodless argument about engineering best practices.
Software developers are like every other kind of craftsman and
artificer; they want, not so secretly, to be artists.  They have the
drives and needs of artists, including the desire to have an audience.
They not only want to reuse code, they want their code to be reused.
There is an imperative here that goes beyond and overrides short-term
economic goal-seeking and that cannot be satisfied by closed-source
software production.
</p>
<p>
  Open source is a kind of ideological preemptive strike on all
these problems.  If the root of most of J. Random Newbie's problems
with reuse is the opacity of closed-source code, then the
institutional assumptions that produce closed-source code must be
smashed.  If corporate territoriality is a problem, it must be
attacked or bypassed until the corporations have caught on to how
self-destructive their territorial reflexes are.  Open source is what
happens when code reuse gets a flag and an army.
</p>
<p>
  Accordingly, since the late 1990s, it no longer makes any
sense to try to recommend strategies and tactics for code reuse
without talking about open source, open-source practices, open-source
licensing, and the open-source community.  Even if those issues could
be separated elsewhere, they have become inextricably bound together
in the Unix world.
</p>
<p>
  In the remainder of this chapter, we'll survey various issues
associated with re-using open-source code: evaluation, documentation,
and licensing. In
  <a href="#opensourcechapter" title="Chapter 19. Open Source">
   Chapter 19</a>
  we'll discuss the open-source
development model more generally, and examine the conventions you
should follow when you are releasing code for others to use.
</p>



<!-- FILE: ch16s04.html -->
<h3 id="ch16s04"><a href="#ch16s04">§</a>The Best Things in Life Are Open</h3>
<p>
  On the Internet, literally terabytes of Unix sources for systems
and applications software, service libraries, GUI toolkits and
hardware drivers are available for the taking. You can have most built
and running in minutes with standard tools.  The mantra is
  <code>./configure; make; make install</code>; usually you have to be root to do the install part.
</p>
<p>
  People from outside the Unix world (especially non-technical
people) are prone to think open-source
  (or ‘free’) software is
necessarily inferior to the commercial kind, that it's shoddily made
and unreliable and will cause more headaches than it saves. They miss
an important point: in general, open-source software is written by
people who care about it, need it, use it themselves, and are putting
their individual reputations among their peers on the line by
publishing it.  They also tend to have less of their time consumed by
meetings, retroactive design changes, and bureaucratic overhead. They
are therefore both more strongly motivated and better positioned to do
excellent work than wage slaves toiling Dilbert-like to meet
impossible deadlines in the cubicles of proprietary software
houses.
</p>
<p>
  Furthermore, the open-source user community (those peers) is not
shy about nailing bugs, and its standards are high. Authors who put
out substandard work experience a lot of social pressure to fix
their code or withdraw it, and can get a lot of skilled help fixing
it if they choose. As a result, mature open-source packages are
generally of high quality and often functionally superior to any
proprietary equivalent. They may lack polish and have documentation
that assumes much, but the vital parts will usually work quite
well.
</p>
<p>
  Besides the peer-review effect, another reason to expect better
quality is this: in the open-source world developers are never forced
by a deadline to close their eyes, hold their noses, and ship.  A
major consequent difference between open-source practice and elsewhere
is that a release level of 1.0 actually means the software is ready to
use.  In fact, a version number of 0.90 or above is a fairly reliable
signal that the code is production-ready, but the developers are not
quite ready to bet their reputations on it.
</p>
<p>
  If you are a programmer from outside the Unix world, you may
find this claim difficult to believe. If so, consider this: on modern
Unixes, the C
  compiler itself is almost invariably open source. The Free Software
Foundation's GNU Compiler Collection
  (GCC) is so powerful, so well
documented, and so reliable that there is effectively no proprietary
Unix compiler market left, and it has become normal for Unix vendors
to port GCC to their platforms rather than do in-house compiler
development.
</p>
<p>
  The way to evaluate an open-source
  package is to read its documentation and
skim some of its code. If what you see appears to be competently
written and documented with care, be encouraged. If there also is
evidence that the package has been around for a while and has
incorporated substantial user feedback, you may bet that it is quite
reliable (but test anyway).
</p>
<p>
  A good gauge of maturity and the volume of user feedback is the
number of people besides the original author mentioned in the
  <code>README</code> and project news or history files in the
source distribution. Credits to lots of people for sending in fixes
and patches are signs both of a significant user base keeping the
authors on their toes, and of a conscientious maintainer who is
responsive to feedback and will take corrections.  It is also 
an indication that, if early code tends to be a minefield of bugs, 
there has since been a thundering herd run through it without
too many recent explosions.
</p>
<p>
  It's also a good omen when the software has its own Web page,
on-line FAQ (Frequently Asked Questions) list, and an associated
mailing list or Usenet
  newsgroup. These are all signs that a live and substantial community
of interest has grown up around the software. On Web pages, recent
updates and an extensive mirror list are reliable signs of a project
with a vigorous user community. Packages that are duds just don't get
this kind of continuing investment, because they can't reward
it.
</p>
<p>
  Ports to multiple platforms are also a valuable indication of a
diversified user base.  Project pages tend to advertise new ports
precisely because they signal credibility.
</p>
<p>
  Here are some examples of what Web pages associated with
high-quality open-source software look like:
</p>
 <div>
  <ul>
   <li>
    <p>
     <a href="http://www.gimp.org/">
      GIMP</a>
    </p>
   </li>
   <li>
    <p>
     <a href="http://www.gnome.org">
      GNOME</a>
    </p>
   </li>
   <li>
    <p>
     <a href="http://www.kde.org">
      KDE</a>
    </p>
   </li>
   <li>
    <p>
     <a href="http://www.python.org">
      Python</a>
    </p>
   </li>
   <li>
    <p>
     <a href="http://www.kernel.org">
      The Linux kernel</a>
    </p>
   </li>
   <li>
    <p>
     <a href="http://www.postgresql.org">
      PostgreSQL</a>
    </p>
   </li>
   <li>
    <p>
     <a href="http://xfree86.org">
      XFree86</a>
    </p>
   </li>
   <li>
    <p>
     <a href="http://www.info-zip.org/pub/infozip/">
      InfoZip</a>
    </p>
   </li>
  </ul>
 </div>
<p>
  Looking at Linux distributions is another good way to find quality.
Distribution-makers for Linux and other open-source Unixes carry
a lot of specialist expertise about which projects are best-of-breed
— that's a large part of the value they add when they integrate
a release.  If you are already using an open-source Unix, something
else to check is whether the package you are evaluating is already
carried by your distribution.
</p>



<!-- FILE: ch16s05.html -->
<h3 id="ch16s05"><a href="#ch16s05">§</a>Where to Look?</h3>
<p>
  Because so much open source is available in the Unix
world, skill at finding code to reuse can have an enormous payoff
— much greater than is the case for other operating systems.
Such code comes in many forms: individual code snippets and
examples, code libraries, utilities to be reused in scripts.  Under
Unix most code reuse is not a matter of actual cut-and-paste into
your program — in fact, if you find yourself doing that, there
is almost certainly a more graceful mode of reuse that you are
missing. Accordingly, one of the most useful skills to cultivate under
Unix is a good grasp of all the different ways to glue together code,
so you can use the Rule of Composition.
</p>
<p>
  To find re-usable code, start by looking under your nose. Unixes
have always featured a rich toolkit of re-usable utilities and 
libraries; modern ones, such as any current Linux system, include
thousands of programs, scripts, and libraries that may be re-usable.  
A simple
  <code>man -k</code> search with a few keywords often yields useful results.
</p>
<p>
  To begin to grasp something of the amazing wealth of resources
out there, surf to SourceForge, ibiblio, and Freshmeat.net.  Other
sites as important as these three may exist by the time you read this
book, but all three of these have shown continuing value and
popularity over a period of years, and seem likely to endure.
</p>
<p>
  <a href="http://www.sourceforge.net">
   SourceForge</a>
  is a
demonstration site for software specifically designed to support
collaborative development, complete with associated project-management
services. It is not merely an archive but a free development-hosting
service, and in mid-2003 is undoubtedly the largest single hub of
open-source activity in the world.
</p>
<p>
  The Linux archives at
  <a href="http://www.ibiblio.org">
   ibiblio</a>
  were the largest in the
world before SourceForge.  The ibiblio archives are passive, simply a
place to publish packages.  They do, however, have a better interface to
the World Wide Web than most passive sites (the program that creates
its Web look and feel was one of our case studies in the discussion of
Perl
  in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>). It's also the home site of the Linux
Documentation Project, which maintains many documents that are
excellent resources for Unix users and developers.
</p>
<p>
  <a href="http://www.freshmeat.net">
   Freshmeat</a>
  is a
system dedicated to providing release announcements of new software,
and new releases of old software.  It lets users and third parties
attach reviews to releases.
</p>
<p>
  These three general-purpose sites contain code in many
languages, but most of their content is C
  or C++. There are also sites specialized
around some of the interpreted languages as discussed in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>.
</p>
<p>
  The CPAN archive is the central repository for useful free code
in Perl. It is easily reached from the
  <a href="http://www.perl.com/perl">
   Perl home
page</a>.
</p>
<p>
  The Python Software Activity makes an archive of
Python
  software and documentation available at the
  <a href="http://www.python.org">
   Python Home Page</a>.
</p>
<p>
  Many Java
  applets and pointers to other sites featuring free Java software are
made available at the
  <a href="http://java.sun.com/applets/">
   Java
Applets page</a>.
</p>
<p>
  One of the most valuable ways you can invest your time as a Unix
developer is to spend time wandering around these sites learning
what is available for you to use. The coding time you save may be
your own!
</p>
<p>
  Browsing the package metadata is a good idea, but don't stop
there. Sample the code, too.  You'll get a better grasp on what the code
is doing, and be able to use it more effectively.
</p>
<p>
  More generally, reading code is an investment in the future.
You'll learn from it — new techniques, new ways to partition
problems, different styles and approaches.  Both using the code and
learning from it are valuable rewards.  Even if you don't use the
techniques in the code you study, the improved definition of the
problem you get from looking at other peoples' solutions may well help
you invent a better one of your own.
</p>
<p>
  Read before you write; develop the habit of reading code.  There
are seldom any completely new problems, so it is almost always
possible to discover code that is close enough to what you need to be
a good starting point.  Even when your problem is genuinely novel, it
is likely to be genetically related to a problem someone else has
solved before, so the solution you need to develop is likely to be
related to some pre-existing one as well.
</p>



<!-- FILE: ch16s06.html -->
<h3 id="ch16s06"><a href="#ch16s06">§</a>Issues in Using Open-Source Software</h3>
<p>
  There are three major issues in using or re-using
open-source
  software; quality, documentation, and licensing terms. We've seen
above that if you exercise a little judgment in picking through your
alternatives, you will generally find one or more of quite respectable
quality.
</p>
<p>
  Documentation is often a more serious issue. Many high-quality
open-source packages are less useful than they technically ought to be
because they are poorly documentated. Unix tradition encourages a
rather hieratic style of documentation, one which (while it may
technically capture all of a package's features) assumes that the
reader is intimately familiar with the application domain and reading
very carefully. There are good reasons for this, which we'll discuss
in
  <a href="#documentationchapter" title="Chapter 18. Documentation">
   Chapter 18</a>, but the
style can present a bit of a barrier.  Fortunately, extracting value
from it is a learnable skill.
</p>
<p>
  It is worth doing a Web search for phrases including the 
software package, or topic keywords, and the string “HOWTO” or
“FAQ”. These queries will often turn up documentation
more useful to novices than the man page.
</p>
<p>
  The most serious issue in reusing open-source software
(especially in any kind of commercial product) is understanding what
obligations, if any, the package's license puts upon you. In the next
two sections we'll discuss this issue in detail.
</p>



<!-- FILE: ch16s07.html -->
<h3 id="ch16s07"><a href="#ch16s07">§</a>Licensing Issues</h3>
<p>
  Anything that is not public domain has a copyright, possibly
more than one. Under U.S. federal law, the authors of a work hold
copyright even if there is no copyright notice.
</p>
<p>
  Who counts as an author under copyright law can be complicated,
especially for software that has been worked on by many hands.  This
is why licenses are important.  They can authorize uses of code in
ways that would be otherwise impermissible under copyright law and,
drafted appropriately, can protect users from arbitrary actions by the
copyright holders.
</p>
<p>
  In the proprietary software world, the license terms are designed to
protect the copyright. They're a way of granting a few rights to
users while reserving as much legal territory as possible for the
owner (the copyright holder). The copyright holder is very
important, and the license logic so restrictive that the exact
technicalities of the license terms are usually unimportant.
</p>
<p>
  As will be seen below, the copyright holder typically uses the
copyright to protect the license, which makes the code freely
available under terms he intends to perpetuate
indefinitely. Otherwise, only a few rights are reserved and most
choices pass to the user. In particular, the copyright holder cannot
change the terms on a copy you already have. Therefore, in open-source
software the copyright holder is almost irrelevant — but the
license terms are very important.
</p>
<p>
  Normally the copyright holder of a project is the current
project leader or sponsoring organization. Transfer of the project to
a new leader is often signaled by changing the copyright holder.
However, this is not a hard and fast rule; many open-source projects
have multiple copyright holders, and there is no instance on record of
this leading to legal problems. Some projects choose to assign
copyright to the Free Software Foundation, on the theory that it has
an interest in defending open source and lawyers available to do
it.
</p>
<h4 id="id2991059"><a href="#id2991059">§</a>What Qualifies as Open Source</h4>
<p>
  For licensing purposes, we can distinguish several different
kinds of rights that a license may convey. There are rights to copy and
redistribute, rights to use, rights to modify for personal use, and
rights to redistribute modified copies. A license may restrict or
attach conditions to any of these rights.
</p>
<p>
  The
  <a href="http://www.opensource.org/osd.html">
   Open Source
Definition</a>
  is the result of a great deal of thought about what
makes software “open source” or (in older terminology)
“free”.  It is widely accepted in the open-source
community as an articulation of the social contract among open-source
developers. Its constraints on licensing impose the following
requirements:
</p>
 <div>
  <ul>
   <li>
    <p>
     An unlimited right to copy be granted.
    </p>
   </li>
   <li>
    <p>
     An unlimited right to redistribute in unmodified form be granted.
    </p>
   </li>
   <li>
    <p>
     An unlimited right to modify for personal use be granted.
    </p>
   </li>
  </ul>
 </div>
<p>
  The guidelines prohibit restrictions on redistribution of
modified binaries; this meets the needs of software distributors, who
need to be able to ship working code without encumbrance. It allows
authors to require that modified sources be redistributed as pristine
sources plus patches, thus establishing the author's intentions and an
“audit trail” of any changes by others.
</p>
<p>
  The OSD is the legal definition of the “OSI Certified Open
Source” certification mark, and as good a definition of
“free software” as anyone has ever come up with. All of
the standard licenses (MIT,
BSD, Artistic, GPL/LGPL,
and MPL) meet it (though some, like GPL, have other restrictions which
you should understand before choosing it).
</p>
<p>
  Note that licenses that allow only noncommercial use do not
qualify as open-source licenses, even if they are based on GPL or some
other standard license. Such licenses discriminate against particular
occupations, persons, and groups, a practice which the OSD's Clause 5
explicitly forbids.
</p>
<p>
  Clause 5 was written after years of painful experience.
No-commercial-use licenses turn out to have the problem that there is
no bright-line legal test for what sort of redistribution qualifies as
‘commercial’.  Selling the software as a product
qualifies, certainly.  But what if it were distributed at a nominal
price of zero in conjunction with other software or data, and a price
is charged for the whole collection?  Would it make a difference
whether the software were essential to the function of the whole
collection?
</p>
<p>
  Nobody knows.  The very fact that no-commercial-use licenses
create uncertainty about a redistributor's legal exposure is a serious
strike against them. One of the objectives of the OSD is to ensure
that people in the distribution chain of OSD-conforming software do
not need to consult with intellectual-property lawyers
to know what their rights are.  OSD forbids complicated restrictions 
against persons, groups, and occupations partly so that people
dealing with collections of software will not face a combinatorial
explosion of slightly differing (and perhaps conflicting) restrictions
on what they can do with it.
</p>
<p>
  This concern is not hypothetical, either.  One important part of
the open-source distribution chain is CD-ROM distributors who
aggregate it in useful collections ranging from simple anthology
CDs up to bootable operating systems.  Restrictions that would make life
prohibitively complicated for CD-ROM distributors, or others trying to
spread open-source software commercially, have to be forbidden.
</p>
<p>
  On the other hand, the OSD has nothing to say about the laws of
your jurisdiction.  Some countries have laws against exporting certain
restricted technologies to named ‘rogue states’. The OSD
cannot negate those, it only says that licensors may not add
restrictions of their own.
</p>
<h4 id="id2993547"><a href="#id2993547">§</a>Standard Open-Source Licenses</h4>
<p>
  Here are the standard open-source license terms you are likely
to encounter. The abbreviations listed here are in general use.
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     <a href="http://www.opensource.org/licenses/mit-license.html">
      MIT</a>
    </span>
   </dt>
   <dd>
    <p>
     MIT X Consortium license (like BSD's but with no advertising
requirement)
    </p>
   </dd>
   <dt>
    <span class="term">
     <a href="http://www.opensource.org/licenses/bsd-license.html">
      BSD</a>
    </span>
   </dt>
   <dd>
    <p>
     University of California at Berkeley Regents copyright (used on
BSD
     code)
    </p>
   </dd>
   <dt>
    <span class="term">
     <a href="http://www.opensource.org/licenses/artistic-license.html">
      Artistic License</a>
    </span>
   </dt>
   <dd>
    <p>
     Same terms as Perl Artistic License
    </p>
   </dd>
   <dt>
    <span class="term">
     <a href="http://www.gnu.org/copyleft.html">
      GPL</a>
    </span>
   </dt>
   <dd>
    <p>
     GNU General Public License
    </p>
   </dd>
   <dt>
    <span class="term">
     <a href="http://www.gnu.org/copyleft.html">
      LGPL</a>
    </span>
   </dt>
   <dd>
    <p>
     Library (or ‘Lesser’) GPL
    </p>
   </dd>
   <dt>
    <span class="term">
     <a href="http://www.opensource.org/licenses/MPL-1.1.html">
      MPL</a>
    </span>
   </dt>
   <dd>
    <p>
     Mozilla Public License
    </p>
   </dd>
  </dl>
 </div>
<p>
  We'll discuss these licenses in more detail, from a developer's
point of view, in
  <a href="#opensourcechapter" title="Chapter 19. Open Source">
   Chapter 19</a>.  For the purposes of this chapter, the
only important distinction among them is whether they are infectious
or not.  A license is
  <em>infectious</em> if it requires
that any derivative work of the licensed software also be placed under
its terms.
</p>
<p>
  Under these licenses, the only kind of open-source use you
should really worry about is actual incorporation of the
free-software code into a proprietary product (as opposed, say, to
merely using open-source development tools to make your product).
If you're prepared to include proper license acknowledgements and
pointers to the source code you're using in your product
documentation, even direct incorporation should be safe provided
the license is not infectious.
</p>
<p>
  The GPL is both the most widely used and the most controversial
infectious license.  And it is clause 2(b), requiring
that any derivative work of a GPLed program itself be GPLed, that
causes the controversy. (Clause 3(b) requiring licensors to make
source available on physical media on demand used to cause some,
but the Internet explosion has made publishing source code archives
as required by 3(a) so cheap that nobody worries about the source-publication
requirement any more.)
</p>
<p>
  Nobody is quite certain what the “contains or is derived
from” in clause 2(b) means, nor what kinds of use are protected
by the “mere aggregation” language a few paragraphs later.
Contentious issues include library linking and inclusion of
GPL-licensed header files. Part of the problem is that the U.S. copyright 
statutes do not define what derivation is; it has been left to the
courts to hammer out definitions in case law, and computer software is
an area in which this process (as of mid-2003) has barely begun.
</p>
<p>
  At one end, the “mere aggregation” certainly makes
it safe to ship GPLed software on the same media with your proprietary
code, provided they do not link to or call each other.  They may even
be tools operating on the same file formats or on-disk structures;
that situation, under copyright law, would not make one a derivative
of the other.
</p>
<p>
  At the other end, splicing GPLed code into your proprietary
code, or linking GPLed object code to yours, certainly does make your
code a derivative work and requires it to be GPLed.
</p>
<p>
  It is generally believed that one program may execute a second
program as a subprocess without either program becoming thereby a
derivative work of the other.
</p>
<p>
  The case that causes dispute is dynamic linking of shared
libraries.  The Free Software Foundation's
  position is that if a
program calls another program as a shared library, then that program
is a derivative work of the library.  Some programmers think this
claim is overreaching.  There are technical, legal, and political
arguments on both sides that we won't rehash here.  Since the Free
Software Foundation
  wrote and owns the license, it would
be prudent to behave as if the FSF's position is correct until a court
rules otherwise.
</p>
<p>
  Some people think the 2(b) language is deliberately designed to
infect every part of any commercial program that uses even a snippet
of GPLed code; such people refer to it as the GPV, or “General
Public Virus”. Others think the “mere aggregation”
language covers everything short of mixing GPL and non-GPL code in the
same compilation or linkage unit.
</p>
<p>
  This uncertainty has caused enough agitation in the open-source
community that the FSF had to develop the special, slightly more
relaxed “Library GPL” (which they have since renamed the
“Lesser GPL”) to reassure people they could continue to
use runtime libraries that came with the FSF's GNU compiler
collection.
</p>
<p>
  You'll have to choose your own interpretation of clause 2(b);
most lawyers will not understand the technical issues involved, and there is no
case law. As a matter of empirical fact, the
FSF
  has never (from its founding in 1984 to mid-2003, at least) sued
anyone under the GPL but it has enforced the GPL by threatening
lawsuit, in all known cases successfully.  And, as another
empirical fact, Netscape includes the source and object of a GPLed
program with the commercial distribution of its Netscape Navigator
browser.
</p>
<p>
  The MPL and LGPL are infectious in a more limited way than GPL.
They explicitly allow linking with proprietary code without turning
that code into a derivative work, provided all traffic between the
GPLed and non-GPLed code goes through a library API or other
well-defined interface.
</p>
<h4 id="id2993874"><a href="#id2993874">§</a>When You Need a Lawyer</h4>
<p>
  This section is directed to commercial developers considering
incorporating software that falls under one of these standard licenses
into closed-source products.
</p>
<p>
  Having gone through all this legal verbiage, the expected thing
for us to do at this point is to utter a somber disclaimer to the
effect that we are not lawyers, and that if you have any
doubts about the legality of something you want to do with open-source
software, you should immediately consult a lawyer.
</p>
<p>
  With all due respect to the legal profession, this would be
fearful nonsense. The language of these licenses is as clear as
legalese gets — they were written to be clear — and should
not be at all hard to understand if you read it carefully. The lawyers
and courts are actually more confused than you are. The law of
software rights is murky, and case law on open-source licenses is
(as of mid-2003) nonexistent; no one has ever been sued under
them.
</p>
<p>
  This means a lawyer is unlikely to have a significantly better
insight than a careful lay reader. But lawyers are professionally
paranoid about anything they don't understand. So if you ask one, he
is rather likely to tell you that you shouldn't go anywhere near
open-source software, despite the fact that he probably doesn't
understand the technical aspects or the author's intentions anywhere
near as well as you do.
</p>
<p>
  Finally, the people who put their work under open-source
licenses
  are
generally not mega-corporations attended by schools of lawyers looking
for blood in the water; they're individuals or volunteer groups who
mainly want to give their software away.  The few exceptions (that is,
large companies both issuing under open-source licenses and with
money to hire lawyers) have a stake in open source and don't want to
antagonize the developer community that produces it by stirring up
legal trouble.  Therefore, your odds of getting hauled into court on
an innocent technical violation are probably lower than your chances
of being struck by lightning in the next week.
</p>
<p>
  This isn't to say you should treat these licenses as jokes. That
would be disrespectful of the creativity and sweat that went into the
software, and you wouldn't enjoy being the first litigation target of
an enraged author no matter how the lawsuit came out. But in the
absence of definitive case law, a visible good-faith effort to meet
the author's intentions is 99% of what you can do; the additional 1%
of protection you might (or might not) get by consulting a lawyer is
unlikely to make a difference.
</p>



<!-- FILE: community.html -->
<h2 id="community"><a href="#community">§</a>Community</h2>


<!-- FILE: portabilitychapter.html -->
<h3 id="portabilitychapter"><a href="#portabilitychapter">§</a>Chapter 17. Portability</h3>
 <blockquote class="epigraph">
  <p>
   The realization that the operating systems of the target machines
were as great an obstacle to portability as their hardware architecture
led us to a seemingly radical suggestion: to evade that part of the
problem altogether by moving the operating system itself.
  </p>
  <span>
   – &lt;authorgroup&gt;Steve JohnsonDennis Ritchie&lt;/authorgroup&gt;
Portability of C Programs and the UNIX System (1978)
  </span>
 </blockquote>
<p>
  Unix was the first production operating system to be ported
between differing processor families (Version 6 Unix, 1976-77). Today,
Unix is routinely ported to every new machine powerful enough to sport
a memory-management unit.  Unix applications are routinely moved
between Unixes running on wildly differing hardware; in fact, it is
unheard of for a port to fail.
</p>
<p>
  Portability has always been one of Unix's principal advantages.
Unix programmers tend to write on the assumption that hardware is
evanescent and only the Unix API is stable, making as few assumptions
as possible about machine specifics such as word length, endianness or
memory architecture.  In fact, code that is hardware-dependent in any
way that goes beyond the abstract machine model of
C
  is considered
bad form in Unix circles, and only really tolerated in very
special cases like operating system kernels.
</p>
<p>
  Unix programmers have learned that it is easy to be wrong when
anticipating that a software project will have a short
lifetime.<sup><a href="#ftn.id2998082" id="id2998082">[141]</a></sup>
  Thus, they
tend to avoid making software dependent on specific and perishable
technologies, and to lean heavily on open standards.  These habits of
writing for portability are so ingrained in the Unix tradition that
they are applied even to small single-use projects that are thought of as
throwaway code. They have had secondary effects all through the design
of the Unix development toolkit, and on programming languages like
Perl and Python and Tcl that were developed under Unix.
</p>
<p>
  The direct benefit of portability is that it is normal for Unix
software to outlive its original hardware platform, so tools and
applications don't have to be reinvented every few years.  Today,
applications originally written for Version 7 Unix (1979) are
routinely used not merely on Unixes genetically descended from V7, but
on variants like Linux
  in which the operating system API was
written from a Unix specification and shares no code with the Bell
Labs source tree.
</p>
<p>
  The indirect benefits are less obvious but may be more important.
The discipline of portability tends to exert a simplifying influence on
architectures, interfaces, and implementations.  This both increases
the odds of project success and reduces life-cycle maintenance
costs.
</p>
<p>
  In this chapter, we'll survey the scope and history of Unix
standards.  We'll discuss which ones are still relevant today and
describe the areas of greater and lesser variance in the Unix API.
We'll examine the tools and practices that Unix developers use to keep
code portable, and develop some guides to good practice.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2998082" id="ftn.id2998082">[141]</a></sup>
  PDP-7 Unix and Linux were both examples of
unexpected persistence.  Unix originated as a research toy hacked
together by some researchers between projects, half to play with
file-system ideas and half to host a game.  The second was summed up by
its creator as “My terminal emulator grew legs” <sup><a href="#Torvalds" title="[Torvalds]">[Torvalds]</a></sup>.
</p>
</div>


<!-- FILE: c_evolution.html -->
<h3 id="c_evolution"><a href="#c_evolution">§</a>Evolution of C</h3>
<p>
  The central fact of the Unix programming experience has always
been the stability of the C language and the handful of service
interfaces that always travel with it (notably, the standard I/O
library and friends).  The fact that a language originated in 1973 has
required as little change as this one has in thirty years of heavy use
is truly remarkable, and without parallels anywhere else in computer
science or engineering.
</p>
<p>
  In
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>, we
argued that C has been successful because it acts as a layer of thin
glue over computer hardware approximating the “standard
architecture” of <sup><a href="#BlaauwBrooks" title="[BlaauwBrooks]">[BlaauwBrooks]</a></sup>.  There is, of course, more to the story than
that. To understand the rest of the story, we'll need to take a brief
look at the history of C.
</p>
<h4 id="id2998213"><a href="#id2998213">§</a>Early History of C</h4>
<p>
  C began life in 1971 as a systems-programming language for the
PDP-11
  port of
Unix, based on Ken Thompson's
  earlier B interpreter which had in turn been
modeled on BCPL, the Basic Common Programming Language designed at
Cambridge University in 1966-67.<sup><a href="#ftn.id2998245" id="id2998245">[142]</a></sup>
</p>
<p>
  Dennis Ritchie's
  original C compiler (often called the
“DMR” compiler after his initials) served the rapidly
growing community around Unix versions 5, 6, and 7.  Version 6 C
spawned Whitesmiths C, a reimplementation that became the first
commercial C compiler and the nucleus of IDRIS, the first Unix
workalike. But most modern C implementations are patterned on Steven
C. Johnson's “portable C compiler” (PCC) which debuted in
Version 7 and replaced the DMR compiler entirely in both System
V
  and the BSD
4.x
  releases.
</p>
<p>
  In 1976, Version 6 C introduced the
  <code>typedef</code>,
  <code>union</code>, and
  <code>
   unsigned
int
  </code>
  declarations.  The approved syntax for variable
initializations and some compound operators also changed.
</p>
<p>
  The original description of C was Brian Kernighan and Dennis
M. Ritchie's
  original
  <em>The C Programming Language</em> aka
“the White Book” <sup><a href="#Kernighan-Ritchie" title="[Kernighan-Ritchie]">[Kernighan-Ritchie]</a></sup>.  It
was published in 1978, the same year the Whitemiths C compiler
became available.
</p>
<p>
  The White Book described enhanced Version 6 C, with one
significant exception involving the handling of public storage.
Ritchie's original intention had been to model C's rules on FORTRAN
COMMON declarations, on the theory that any machine that could handle
FORTRAN would be ready for C.  In the common-block model, a public
variable may be declared multiple times; identical declarations are
merged by the linker.  But two early C ports (to Honeywell and IBM 360
mainframes) happened to be to machines with very limited common
storage or a primitive linker or both.  Thus, the Version 6 C compiler
was moved to the stricter definition-reference model (requiring at
most one definition of any given public variable and the
  <code>extern</code>
  keyword tagging references to it) described
in <sup><a href="#Kernighan-Ritchie" title="[Kernighan-Ritchie]">[Kernighan-Ritchie]</a></sup>.
</p>
<p>
  This decision was reversed in the C compiler that shipped with
Version 7 after it developed that a great deal of existing source
depended on the looser rules.  Pressure for backward-compatibility
would foil yet another attempt to switch (in 1983's System V
Release 1)
before the ANSI Draft Standard finally settled on definition-reference
rules in 1988.  Common-block public storage is still admitted as an
acceptable variation by the standard.
</p>
<p>
  V7 C introduced
  <code>enum</code> and
treated
  <code>struct</code> and
  <code>union</code> values as first-class objects that
could be assigned, passed as arguments, and returned from functions
(rather than being passed around by address).
</p>
 <blockquote>
  <p>
   Another major change in V7 was that Unix data structure declarations
were now documented on header files, and included.  Previous Unixes
had actually printed the data structures (e.g., for directories) in
the manual, from which people would copy it into their code.  Needless
to say, this was a major portability problem.
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>
<p>
  The System III
  C version of the PCC compiler (which also
shipped with BSD 4.1c) changed the handling of struct
declarations so that members with the same names in different structs
would not clash.  It also introduced
  <code>void</code> and
  <code>unsigned char</code> declarations.  The scope of
  <code>extern</code> declarations local to a function was
restricted to the function, and no longer included all code following
it.
</p>
<p>
  The ANSI C Draft Proposed Standard added
  <code>const</code> (for read-only storage) and
  <code>volatile</code> (for locations such as memory-mapped
I/O registers that might be modified asynchronously from the thread of
program control). The
  <code>unsigned</code> type
modifier was generalized to apply to any type, and a symmetrical
  <code>signed</code> was added.  Initialization
syntax for
  <code>auto</code> array and structure
initializers and
  <code>union</code> types was
added. Most importantly, function prototypes were added.
</p>
<p>
  The most important changes in early C were the switch to
definition-reference and the introduction of function prototypes in
the Draft Proposed ANSI C Standard. The language has been essentially
stable since copies of the X3J11 committee's working papers on the
Draft Proposed Standard signaled the committee's intentions to
compiler implementers in 1985-1986.
</p>
<p>
  A more detailed history of early C, written by its designer, can
be found at <sup><a href="#Ritchie93" title="[Ritchie93]">[Ritchie93]</a></sup>.
</p>
<h4 id="id2994334"><a href="#id2994334">§</a>C Standards</h4>
<p>
  C standards development has been a conservative process with
great care taken to preserve the spirit of the original C language,
and an emphasis on ratifying experiments in existing compilers rather
than inventing new features. The C9X charter<sup><a href="#ftn.id2994347" id="id2994347">[143]</a></sup>
  document is an excellent expression
of this mission.
</p>
<p>
  Work on the first official C standard began in 1983 under the
auspices of the X3J11 ANSI committee. The major functional additions
to the language were settled by the end of 1986, at which point it
became common for programmers to distinguish between “K&amp;R
C” and “ANSI C”.
</p>
 <blockquote>
  <p>
   Many people don't realize how
   <em>unusual</em>
   the C
standardization effort, especially the original ANSI C work, was in
its insistence on standardizing only tested features.  Most language
standard committees spend much of their time inventing new features,
often with little consideration of how they might be implemented.
Indeed, the few ANSI C features that
   <em>were</em>
   invented from scratch — e.g., the notorious
“trigraphs”—were the most disliked and least
successful features of C89.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
 <blockquote>
  <p>
   Void pointers were invented as part of the standards effort, and have
been a winner.  But Henry's point is still well taken.
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>
<p>
  While the core of ANSI C was settled early, arguments over the
contents of the standard libraries dragged on for years. The formal
standard was not issued until the end of 1989, well after most
compilers had implemented the 1985 recommendations.  The standard was
originally known as ANSI X3.159, but was redesignated ISO/IEC
9899:1990 when the International Standards Organization (ISO) took
over sponsorship in 1990.  The language variant it describes is
generally known as C89 or C90.
</p>
<p>
  The first book on C and Unix portability practice,
  <em>Portable C and Unix Systems Programming</em> <sup><a href="#Lapin" title="[Lapin]">[Lapin]</a></sup>, was published in 1987 (I wrote it under a corporate
pseudonym forced on me by my employers at the time).  The Second
Edition of <sup><a href="#Kernighan-Ritchie" title="[Kernighan-Ritchie]">[Kernighan-Ritchie]</a></sup> came out in 1988.
</p>
<p>
  A very minor revision of C89, known as Amendment 1, AM1, or C93,
was floated in 1993.  It added more support for wide characters and
Unicode. This became ISO/IEC 9899-1:1994.
</p>
<p>
  Revision of the C89 standard began in 1993.  In 1999, ISO/IEC
9899 (generally known as C99) was adopted by ISO.  It incorporated
Amendment 1, and added a great many minor features.  Perhaps the most
significant one for most programmers is the C++-like ability to
declare variables at any point in a block, rather than just at the
beginning.  Macros with a variable number of arguments were also
added.
</p>
<p>
  The C9X working group has a
  <a href="http://anubis.dkuug.dk/JTC1/SC22/WG14/www/projects">
   Web page</a>, but no third standards effort is planned as
of mid-2003.  They are developing an addendum on C for 
embedded systems.
</p>
<p>
  Standardization of C has been greatly aided by the fact that
working and largely compatible implementations were running on a wide
variety of systems before standards work was begun.  This made it
harder to argue about what features should be in the standard.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2998245" id="ftn.id2998245">[142]</a></sup>
  The ‘C’ in
C therefore stands for Common — or, perhaps, for
‘Christopher’.  BCPL originally stood for “Bootstrap
CPL”—a much simplified version of CPL, the very
interesting but overly ambitious and never implemented Common
Programming Language of Oxford and Cambridge, also known
affectionately as “Christopher's Programming Language”
after its prime advocate, computer-science pioneer Christopher
Strachey.
</p>

<p><sup><a href="#id2994347" id="ftn.id2994347">[143]</a></sup>
  <a href="http://anubis.dkuug.dk/JTC1/SC22/WG14/www/charter">
   Available on
the Web</a>.
</p>
</div>


<!-- FILE: ch17s02.html -->
<h3 id="ch17s02"><a href="#ch17s02">§</a>Unix Standards</h3>
<p>
  The 1973 rewrite of Unix in C
  made it unprecedentedly easy to port
and modify.  As a result, the ancestral Unix diverged into a family of
operating systems early on.  Unix standards originally developed to
reconcile the APIs of the different branches of the family
tree.
</p>
<p>
  The Unix standards that evolved after 1985 were quite successful
at this — so much so that they serve as valuable documentation
of the API of modern Unix implementations.  In fact, real-world Unixes
follow published standards so closely that developers can (and
frequently do) lean more on documents like the POSIX specification
than on the official manual pages for the Unix variant they happen to
be using.
</p>
<p>
  In fact, on the newer open-source Unixes (such as
Linux), it is common for operating-system
features to have been engineered using published standards as the
specification.  We'll return to this point when we examine the RFC
standards process later in this chapter.
</p>
<h4 id="id2994594"><a href="#id2994594">§</a>Standards and the Unix Wars</h4>
<p>
  The original motivation for the development of Unix standards
was the split between the
AT&amp;T
  and
Berkeley
  lines of
development that we examined in
  <a href="#historychapter" title="Chapter 2. History">
   Chapter 2</a>.
</p>
<p>
  The 4.x BSD Unixes were descended from the 1979 Version 7.
After the release of 4.1BSD in 1980 the BSD
  line quickly developed a reputation as the
cutting edge of Unix.  Important additions included the
  <em>vi</em> visual editor, job control facilities for managing multiple foreground
and background tasks from a single console, and improvements in
signals (see
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>). By far the most important addition
was to be TCP/IP
  networking, but though Berkeley got the contract to do it in 1980,
TCP/IP was not to ship in an external release for three years.
</p>
<p>
  But another version, 1981's System III, became the basis of AT&amp;T's later
development. System III reworked the Version 7 terminals interface
into a cleaner and more elegant form that was completely incompatible
with the Berkeley enhancements.  It retained the older (non-resetting)
semantics of signals (again, see
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>
  for discussion of this point).  The
January 1983 release of System V Release 1
  incorporated some
BSD
  utilities (such
as
vi(1)).
</p>
<p>
  The first attempt to bridge the gap came in February 1983 from
UniForum, an influential Unix user group.  Their Uniforum 1983 Draft
Standard (UDS 83) described a “core Unix System” consisting of a
subset of the System III
  kernel and libraries plus a file-locking
primitive. AT&amp;T
  declared support for UDS 83, but the standard was an inadequate subset
of evolving practice based on 4.1BSD.  The problem was exacerbated by the July
1983 release of 4.2BSD, which added many new features (including
TCP/IP
  networking) and
introduced some subtle incompatibilities with the ancestral Version
7.
</p>
<p>
  The 1984 divestiture of the Bell operating companies and the
beginnings of the Unix wars
  (see
  <a href="#historychapter" title="Chapter 2. History">
   Chapter 2</a>) significantly complicated matters.  Sun
Microsystems
  was leading the workstation industry in a BSD direction; AT&amp;T was
trying to get into the computer business and use control of Unix as a
strategic weapon even as it continued to license the operating system
to competitors like Sun.  All the vendors were making business
decisions to differentiate their versions of Unix for competitive
advantage.
</p>
<p>
  During the Unix wars, technical standardization became something
that cooperating technical people pushed for and most product managers
accepted grudgingly or actively resisted.  The one large and important
exception was
AT&amp;T,
which declared its intention to cooperate with user groups in setting
standards when it announced System V Release
2 (SVr2)
  in January
1984.  The second revision of the UniForum Draft Standard, in 1984,
both tracked and influenced the API of SVr2.  Later Unix standards
also tended to track System V except in areas where
BSD
  facilities were
clearly functionally superior (thus, for example, modern Unix
standards describe the System V
  terminal controls rather than the BSD
interface to the same facilities).
</p>
<p>
  In 1985,
AT&amp;T
  released
the
  <em>System V Interface Definition</em> (SVID).  SVID
provided a more formal description of the SVr2 API, incorporating UDS
84.  Later revisions SVID2 and SVID3 tracked the interfaces of System V
releases 3 and 4.  SVID became the basis for the POSIX standards, which
ultimately tipped most of the Berkeley/AT&amp;T disputes over system
and C
  library calls in
AT&amp;T's favor.
</p>
<p>
  But this would not become obvious for a few years yet;
meanwhile, the Unix wars
  raged on.  For example, 1985 saw the
release of two competing API standards for file system sharing over
networks: Sun's
  Network File System (NFS) and
AT&amp;T's
  Remote
File System (RFS).  Sun's NFS prevailed because Sun was willing to
share not merely specifications but open-source code with
others.
</p>
<p>
  The lesson of this success should have been all the more pointed
because on purely logical grounds RFS was the superior model. It
supported better file-locking semantics and better mapping among user
identities on different systems, and generally made an effort to get
the finer details of Unix file system semantics precisely right,
unlike NFS. The lesson was ignored, however, even when it was repeated
in 1987 by the open-source X windowing system's
  victory over Sun's proprietary
Networked Window System (NeWS).
</p>
<p>
  After 1985 the main thrust of Unix standardization passed to the
Institute of Electrical and Electronic Engineers (IEEE).  The IEEE's
1003 committee developed a series of standards generally known as
POSIX.<sup><a href="#ftn.id2995003" id="id2995003">[144]</a></sup>
  These went beyond describing
merely systems calls and C
  library facilities; they specified
detailed semantics of a shell and a minimum command set, and also
detailed bindings for various non-C programming languages.  The first
release in 1990 was followed by a second edition in 1996. The
International Standards Organization adopted them as ISO/IEC
9945.
</p>
<p>
  Key POSIX standards include the following:
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     1003.1 (released 1990)
    </span>
   </dt>
   <dd>
    <p>
     Library procedures.  Described the C system call API, much like
Version 7 except for signals and the terminal-control interface.
    </p>
   </dd>
   <dt>
    <span class="term">
     1003.2 (released 1992)
    </span>
   </dt>
   <dd>
    <p>
     Standard shell and utilities. Shell semantics strongly resemble those 
of the System V Bourne shell.
    </p>
   </dd>
   <dt>
    <span class="term">
     1003.4 (released 1993)
    </span>
   </dt>
   <dd>
    <p>
     Real-time Unix.  Binary semaphores, process memory locking,
memory-mapped files, shared memory, priority scheduling, real-time
signals, clocks and timers, IPC message passing, synchronized I/O,
asynchronous I/O, real-time files.
    </p>
    <p>
     In the 1996 Second Edition, 1003.4 was split into 1003.1b
(real-time) and 1003.1c (threads).
    </p>
   </dd>
  </dl>
 </div>
<p>
  Despite being underspecified in a couple of key areas such as
signal-handling semantics and omitting BSD
  sockets, the original POSIX standards
became the basis of all later Unix standardization work.  They are
still cited as an authority, albeit indirectly through references like
  <em>POSIX Programmer's Guide</em> <sup><a href="#Lewine" title="[Lewine]">[Lewine]</a></sup>.  The de facto Unix API standard is still
“POSIX plus sockets”, with later standards mainly adding
features and specifying conformance in unusual edge cases more
closely.
</p>
<p>
  The next player on the scene was X/Open (later renamed the Open
Group), a consortium of Unix vendors formed in 1984.  Their X/Open
Portability Guides (XPGs) initially developed in parallel with the
POSIX drafts, then after 1990 the XPGs incorporated and extended
POSIX.  Unlike POSIX, which attempted to capture a safe subset of all
Unixes, the XPGs were oriented more toward common practice at the
leading edge; even XPG1 in 1985, spanning SVr2 and 4.2BSD,
  included
sockets.
</p>
<p>
  XPG2 in 1987 added a terminal-handling API that was essentially
System V
curses(3).
XPG3 in 1990 merged in the X11 API.  XPG4 in 1992 mandated full
compliance with the 1989 ANSI C standard.  XPG2, 3, and 4 were heavily concerned
with support of internationalization and described an elaborate API
for handling codesets and message catalogs.
</p>
<p>
  In reading about Unix standards you might come across references
to “Spec 1170” (from 1993), “Unix 95” (from
1995) and “Unix 98” (from 1998).  These were
certification marks based on the X/Open standards; they are now of
historical interest only.  But the work done on XPG4 turned into 
Spec 1170, which turned into the first version of the Single Unix
Specification (SUS).
</p>
<p>
  In 1993 seventy-five systems and software vendors including
every major Unix company put a final end to the Unix
wars
  when they
declared backing for X/Open to develop a common definition of Unix.
As part of the arrangement, X/Open acquired the rights to the Unix
trademark.  The merged standard became Single Unix Standard version 1.
It was followed in 1997 by a version 2.  In 1999 X/Open absorbed the
POSIX activity.
</p>
<p>
  In 2001, X/Open (now The Open Group) issued the
  <a href="http://www.unix.org/version3/">
   Single Unix Standard version 3</a>.  All the threads of Unix API standardization were finally
gathered into one bundle.  This reflected facts on the ground; the
different varieties of Unix had re-converged on a common API.  And, at
least among old-timers who remembered the turbulence of the 1980s,
there was much rejoicing.
</p>
<h4 id="id2999310"><a href="#id2999310">§</a>The Ghost at the Victory Banquet</h4>
<p>
  There was, unfortunately, an awkward detail — the
old-school Unix vendors who had backed the effort were under severe
pressure from the new school of open-source Unixes, and were in some
cases in the process of abandoning (in favor of
Linux)
the proprietary Unixes for which they had gone to so much effort to
secure conformance.
</p>
<p>
  The conformance testing needed to verify Single Unix
Specification conformance is an expensive proposition.  It would need
to be done on a per-distribution basis, but is well out of the reach
of most distributors of open-source operating systems.  In any case,
Linux changes so fast that any given release of a distribution would
probably be obsolete by the time it could get
certified.<sup><a href="#ftn.id2999345" id="id2999345">[145]</a></sup>
</p>
<p>
  Standards like the Single Unix Specification have not entirely lost their
relevance.  They're still valuable guides for Unix implementers.  But
how The Open Group and other institutions of the old-school Unix
standardization process will adapt to the rapid tempo of open-source
releases (and to the low- or zero-budget operation of open-source
development groups!) remains to be seen.
</p>
<h4 id="id2999366"><a href="#id2999366">§</a>Unix Standards in the Open-Source World</h4>
<p>
  In the mid-1990s, the open-source community began
standardization efforts of its own.  These efforts built on the
source-code-level compatibility secured by
POSIX
  and its
descendants.  Linux, in particular, had been written from
scratch in a way that depended on the availability of Unix API
standards like POSIX.<sup><a href="#ftn.id2999397" id="id2999397">[146]</a></sup>
</p>
<p>
  In 1998 Oracle ported its market-leading database product to
Linux, in a move that was rightly seen as a major breakthrough in
Linux's mainstream acceptance.  The engineer in charge of the port
provided a definitive demonstration that API standards had done their
job when he was asked by a reporter what technical challenges Oracle
had had to surmount.  The engineer's reply was “We typed
‘make’.”
</p>
<p>
  The problem for the new-school Unixes, therefore, was not API
compatibility at the source-code level.  Everybody took for granted
the ability to move source code between different
Linux,
BSD, and
proprietary-Unix distributions without more than a trivial amount of
porting labor.  The new problem was not source compatibility but
binary compatibility.  For the ground under Unix had shifted in a
subtle way as a consequence of the triumph of commodity PC
hardware.
</p>
<p>
  In the old days, each Unix had run on what was effectively its
own hardware platform.  There was enough variety in processor
instruction sets and machine architectures that applications had to be
ported at source level to move at all.  On the other hand, there were
a relatively few major Unix releases, each with relatively long
service lifetimes.  Application vendors like Oracle could afford the
cost of building and shipping separate binary distributions for each
of three or four hardware/software combinations, because they could
amortize the low cost of source-code porting over large customer
populations and a long enough product life cycle.
</p>
<p>
  But then the minicomputer and workstation vendors were swamped by
inexpensive 386-based supermicros, and open-source Unixes changed the 
rules.  Vendors found they no longer had a stable platform to ship
their binaries to.
</p>
<p>
  The superficial problem, at first, was the large number of Unix
distributors — but as the Linux
  distribution market
consolidated, it became clear that the real issue was the rate of
change over time.  APIs were stable, but the expected locations of
system administrative files, utility programs, and things like the
prefix of the paths to user mailbox names and system log files kept
changing.
</p>
<p>
  The first standards effort to develop within the new-school
Linux
  and BSD
  community
itself (beginning in 1993) was the Filesystem Hierarchy Standard (FHS).
This was incorporated into the Linux Standards Base (LSB), which also
standardized an expected set of service libraries and helper
applications.  Both standards became activities of the
  <a href="http://www.freestandards.org/">
   Free Standards Group</a>,
which by 2001 developed a role similar to X/Open's position amidst the
old-school Unix vendors.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2995003" id="ftn.id2995003">[144]</a></sup>
  The
original 1986 trial-use standard was called IEEE-IX.  The name
‘POSIX’ was suggested by Richard Stallman. The
introduction to POSIX.1 says: “It is expected to be pronounced
pahz-icks as in positive, not poh-six, or other variations. The
pronounciation has been published in an attempt to promulgate a
standardized way of referring to a standard operating system
interface”.
</p>

<p><sup><a href="#id2999345" id="ftn.id2999345">[145]</a></sup>
  One Linux distributor, Lasermoon in Great
Britain, did achieve POSIX.1 FIPS 151-2 certification — and went
out of business, because potential customers didn't
care.
</p>

<p><sup><a href="#id2999397" id="ftn.id2999397">[146]</a></sup>
  See
  <em>Just for Fun</em><sup><a href="#Torvalds" title="[Torvalds]">[Torvalds]</a></sup> for
discussion.
</p>
</div>


<!-- FILE: ietf_process.html -->
<h3 id="ietf_process"><a href="#ietf_process">§</a>IETF and the RFC Standards Process</h3>
<p>
  When the Unix community merged with the culture of Internet
engineers, it also inherited a mindset formed by the RFC standards
process of the Internet Engineering Task Force (IETF).  In IETF tradition,
standards have to arise from experience with a working prototype
implementation — but once they
  <em>become</em>
  standards, code that does not conform to them is considered broken and
mercilessly scrapped.
</p>
<p>
  This is not, sadly, the way standards are normally developed.  The
history of computing is full of instances in which technical standards
were derived by a process that combined the worst features of
philosophical axe-grinding with murky back-room politics —
producing specifications that failed to resemble anything ever
implemented. Worse, many were either so demanding that they could
not be practically implemented or so underspecified that they caused
more confusion than they resolved.  Then they were promulgated
to vendors who ignored them wherever they were inconvenient.
</p>
<p>
  One of the more notorious examples of standards nonsense was the
Open Systems Interconnect networking protocols that briefly contended
with TCP/IP
  in the
1980s — its 7-layer model looked elegant from a distance but
proved overcomplicated and unimplementable in
practice.<sup><a href="#ftn.id2999607" id="id2999607">[147]</a></sup>
  The
ANSI X3.64 standard for video-display terminal capabilities is another
famous horror story; bedeviled by subtle incompatibilities between
legally conformant implementations.  Even after character-cell
terminals have been largely displaced by bitmapped displays these
continue to cause problems (in particular, this is why the function
and special keys in your
xterm(1)
will occasionally break).  The RS232 standard for serial
communications was so underspecified that it sometimes seemed that no
two serial cables were alike.  Standards horror stories of similar
kind could fill a book the size of this one.
</p>
<p>
  The IETF's philosophy has been famously summarized as “We
reject kings, presidents, and voting.  We believe in rough consensus
and running code”.<sup><a href="#ftn.id2999646" id="id2999646">[148]</a></sup>
  That demand for a working implementation
first has saved it from the worst category of blunders.  In fact its
criterion is stronger:
</p>
 <blockquote>
  <p>
   [A] candidate specification must be implemented
and tested for correct operation and interoperability by multiple
independent parties and utilized in increasingly demanding
environments, before it can be adopted as an Internet
Standard.
  </p>
 </blockquote>
<p>
  All IETF standards pass through a stage as RFCs (Requests for
Comment).  The submission process for RFCs is deliberately informal.
RFCs may propose standards, survey results, suggest philosophical
bases for subsequent RFCs, or even make jokes.  The appearance of the
annual April 1st RFC is the closest equivalent of a high holy day
observance among Internet
hackers, and has
produced such gems as
  <em>A Standard for the Transmission of IP Datagrams on Avian Carriers (RFC 1149)</em><sup><a href="#ftn.id2999703" id="id2999703">[149]</a></sup>
  the
  <em>The Hyper Text Coffee Pot Control Protocol (RFC 2324)</em>,<sup><a href="#ftn.id2999728" id="id2999728">[150]</a></sup>
  and
  <em>The Security Flag in the IPv4 Header (RFC 3514)</em>.<sup><a href="#ftn.id2999745" id="id2999745">[151]</a></sup>
</p>
<p>
  But joke RFCs are about the
  <em>only</em>
  sort of
submission that instantly becomes an RFC.  Serious proposals actually
start as “Internet-Drafts” floated for public comment via
IETF directories on several well-known hosts.  Individual Internet-Drafts
have no formal status and can be changed or dropped by their
originators at any time.  If they are neither withdrawn nor promoted to
RFC status, they are removed after six months.
</p>
<p>
  Internet-Drafts are not specifications, and software
implementers and vendors are specifically barred from claiming
compliance with them as if they were specifications. Internet-Drafts
are focal points for discussion, usually in a working group connected
through an electronic mailing list.  When the working group leadership
deems fit, the Internet-Draft is submitted to the RFC editor for
assignment of an RFC number.
</p>
<p>
  Once an Internet-Draft has been published with an RFC number,
it is a specification to which implementers may claim conformance. It
is expected that the authors of the RFC and the community at large 
will begin correcting the specification with field experience.
</p>
<p>
  Some RFCs go no further.  A specification that fails to attract
use and survive field testing can be quietly forgotten, and eventually
marked “Not recommended” or “Superseded” by
the RFC editor.  Failed proposals are accepted as one of the overheads
of the process, and no stigma is attached to being associated
with one.
</p>
<p>
  The steering committee of the IETF (IESG, or Internet
Engineering Steering Group) is responsible for putting successful RFCs
on the standards track.  They do this by designating the RFC a
‘Proposed Standard’. For the RFC to qualify, the
specification must be stable, peer-reviewed, and have attracted
significant interest from the Internet community.  Implementation
experience is not absolutely required before an RFC is given Proposed
Standard designation, but it is considered highly desirable, and the IESG
may require it if the RFC touches the Internet core protocols or
might be otherwise destabilizing.
</p>
<p>
  Proposed Standards are still subject to revision, and may even
be withdrawn if the IESG and IETF identify a better solution. They
are not recommended for use in “disruption-sensitive
environments”—don't put them in your
air-traffic-control systems or on intensive-care equipment.
</p>
<p>
  When there are at least two working, complete, independently
originated, and interoperable implementations of a Proposed Standard,
the IESG may elevate it to Draft Standard status.  RFC 2026 says: 
“Elevation to Draft Standard is a major advance in status, indicating
a strong belief that the specification is mature and will be
useful”.
</p>
<p>
  Once an RFC has reached Draft Standard status, it will be
changed only to address bugs in the logic of the specification. Draft
Standards are expected to be ready for deployment in
disruption-sensitive environments.
</p>
<p>
  When a Draft Standard has passed the test of widespread
implementation and reached general acceptance, it may be blessed as an
Internet Standard.  Internet Standards keep their RFC numbers, but also
get a number in the STD series.  At time of writing there are over
3000 RFCs but only 60 STDs.
</p>
<p>
  RFCs not on standards track may be labeled Experimental,
Informational (the joke RFCs get this label), or Historic.  The
Historic label is applied to obsolete standards. RFC 2026 notes:
“(Purists have suggested that the word should be
‘Historical’; however, at this point, the use of
‘Historic’ is historical.)”
</p>
<p>
  The IETF standards process is designed to encourage
standardization driven by practice rather than theory, and to 
ensure that standard protocols have undergone rigorous peer
review and testing.  The success of this model is evident in its 
results — the worldwide Internet.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id2999607" id="ftn.id2999607">[147]</a></sup>
  A Web search is likely to turn up a popular
page comparing the OSI 7-layer model with the Taco Bell 7-layer
burrito — unfavorably to the former.
</p>

<p><sup><a href="#id2999646" id="ftn.id2999646">[148]</a></sup>
  This line was first uttered
by senior IETF cadre Dave Clark at the tumultuous 1992 meeting during
which the IETF rejected the Open Systems Interconnect
protocol.
</p>

<p><sup><a href="#id2999703" id="ftn.id2999703">[149]</a></sup>
  <a href="http://www.ietf.org/rfc/rfc1149.txt">
   RFC
1149 is available on the Web</a>. Not only that, it has been
  <a href="http://www.blug.linux.no/rfc1149/writeup.html">
   implemented</a>.
</p>

<p><sup><a href="#id2999728" id="ftn.id2999728">[150]</a></sup>
  <a href="http://www.ietf.org/rfc/rfc2324.txt">
   RFC 2324 is available on the
Web</a>.
</p>

<p><sup><a href="#id2999745" id="ftn.id2999745">[151]</a></sup>
  <a href="http://www.ietf.org/rfc/rfc3514.txt">
   RFC 3514 is available on the
Web</a>.
</p>
</div>


<!-- FILE: ch17s04.html -->
<h3 id="ch17s04"><a href="#ch17s04">§</a>Specifications as DNA, Code as RNA</h3>
<p>
  Even in the paleolithic period of the PDP-7, Unix programmers
had always been more prone than their counterparts elsewhere to treat
old code as disposable.  This was doubtless a product of the Unix
tradition's emphasis on modularity, which makes it easier to discard
and replace small pieces of systems without losing everything.  Unix
programmers have learned by experience that trying to salvage bad code
or a bad design is often more work than rebooting the project. Where
in other programming cultures the instinct would be to patch the
monster monolith because you have so much work invested in it, the
Unix instinct is usually to scrap and rebuild.
</p>
<p>
  The IETF
  tradition
reinforced this by teaching us to think of code as secondary to
standards. Standards are what enable programs to cooperate; they knit
our technologies into wholes that are more than the sum of the parts.
The IETF showed us that careful standardization, aimed at capturing
the best of existing practice, is a powerful form of humility that
achieves more than grandiose attempts to remake the world around a
never-implemented ideal.
</p>
<p>
  After 1980, the impact of that lesson was increasingly widely
felt in the Unix community.  Thus, while the ANSI/ISO C standard from
1989 is not completely without flaws, it is exceptionally clean and
practical for a standard of its size and importance.  The Single Unix
Specification contains fossils from three decades of experimentation
and false starts in a more complicated domain, and is therefore
messier than ANSI C.  But the component standards it was composed from
are quite good; strong evidence for this is the fact that Linus
Torvalds successfully built a Unix from scratch by reading them. The
IETF's
  quiet but
powerful example created one of the critical pieces of context that
made Linus Torvalds's feat possible.
</p>
<p>
  Respect for published standards and the
IETF
  process has become
deeply ingrained in the Unix culture; deliberately violating Internet
STDs is simply Not Done.  This can sometimes create chasms of mutual
incomprehension between people with a Unix background and others prone
to assume that the most popular or widely deployed implementation of a
protocol is by definition correct — even if it breaks the
standard so severely that it will not interoperate with properly
conforming software.
</p>
<p>
  The Unix programmer's respect for published standards is more
interesting because he is likely to be rather hostile to a-priori
specifications of other kinds.  By the time the ‘waterfall
model’
  (specify exhaustively first, then implement, then debug, with no
reverse motion at any stage) fell out of favor in the
software-engineering literature, it had been an object of derision
among Unix programmers for years.  Experience, and a strong tradition
of collaborative development, had already taught them that prototyping
and repeated cycles of test and evolution are a better
way.
</p>
<p>
  The Unix tradition clearly recognizes that there can be great
value in good specifications, but it demands that they be treated as
provisional and subject to revision through field experience in the
way that Internet-Drafts and Proposed Standards are.  In best Unix
practice, the documentation of the program is used as a specification
subject to revision analogously to an Internet Proposed
Standard.
</p>
 <blockquote>
  <p>
   Unlike other environments, in Unix development the documentation is often
written before the program, or at least in conjunction with it.  For X11, the
core X standards were finished before the first release of X and have remained
essentially unchanged since that date. Compatibility among different X systems
is improved further by rigorous specification-driven testing.
  </p>
  <p>
   The existence of a well-written specification made the
development of the X test suite much easier.  Each statement in the X
specification was translated into code to test the implementation, a
few minor inconsistencies were uncovered in the specification during
this process, but the result is a test suite that covers a significant
fraction of the code paths within the sample X library and server, and
all without referring to the source code of that implementation.
  </p>
  <span>
   – Keith Packard
  </span>
 </blockquote>
<p>
  Semiautomation of the test-suite generation proved to be a
major advantage.  While field experience and advances in the state
of the graphics art led many to criticize X on design grounds, and
various portions of it (such as the security and user-resource models) came
to seem clumsy and over-engineered, the X implementation achieved a
remarkable level of stability and cross-vendor interoperation.
</p>
<p>
  In
  <a href="#generationchapter" title="Chapter 9. Generation">
   Chapter 9</a>
  we discussed the value of pushing coding up to the highest possible
level to minimize the effects of constant defect density.  Implicit in
Keith Packard's account is the idea that the X documentation
constituted no mere wish-list but a form of high-level code.  Another
key X developer confirms this:
</p>
 <blockquote>
  <p>
   In X, the specification has always ruled.  Sometimes specs have bugs that
need to be fixed too, but code is usually buggier than specs (for any
spec worth its ink, anyway).
  </p>
  <span>
   – Jim Gettys
  </span>
 </blockquote>
<p>
  Jim goes on to observe that X's process is actually quite
similar to the IETF's.
Nor is its utility limited to constructing good test suites; it means
that arguments about the system's behavior can be conducted at a
functional level with respect to the specification, avoiding too much
entanglement in implementation issues.
</p>
 <blockquote>
  <p>
   Having a well-considered specification driving development allows for
little argument about bug vs. feature; a system which incorrectly implements the
specification is broken and should be fixed.
  </p>
  <p>
   I suspect this is so ingrained into most of us that we lose
sight of its power.
  </p>
  <p>
   A friend of mine who worked for a small software firm east of
Bellevue wondered how Linux applications developers could get OS
changes synchronized with application releases.  In that company,
major system-level APIs change frequently to accommodate application
whims and so essential OS functionality must often be released along
with each application.
  </p>
  <p>
   I described the power held by the specifications and how the
implementation was subservient to them, and then went on to assert
that an application which got an unexpected result from a documented
interface was either broken or had discovered a bug.  He found this
concept startling.
  </p>
  <p>
   Discerning such bugs is a simple matter of verifying the
implementation of the interface against the specification.  Of course,
having source for the implementation makes that a bit easier.
  </p>
  <span>
   – Keith Packard
  </span>
 </blockquote>
<p>
  This standards-come-first attitude has benefits for end users as
well.  While that no-longer-small company east of Bellevue has trouble
keeping its office suite compatible with its own previous releases,
GUI applications written for X11 in 1988 still run without change on
today's X implementations.  In the Unix world, this sort of longevity
is normal — and the standards-as-DNA attitude is the reason
why.
</p>
<p>
  Thus, experience shows that the standards-respecting,
scrap-and-rebuild culture of Unix tends to yield better
interoperability over extended time than perpetual patching of a code
base without a standard to provide guidance and continuity.  This
may, indeed, be one of the most important Unix lessons.
</p>
<p>
  Keith's last comment brings us directly to an issue that the
success of open-source Unixes has brought to the forefront — the
relationship between open standards and open source.   We'll address
this at the end of the chapter — but before doing that, it's
time to address the practical question of how Unix programmers 
can actually
  <em>use</em>
  the tremendous body of
accumulated standards and lore to achieve software portability.
</p>



<!-- FILE: ch17s05.html -->
<h3 id="ch17s05"><a href="#ch17s05">§</a>Programming for Portability</h3>
<p>
  Software portability is usually thought of in quasi-spatial
terms: can this code be moved sideways to existing hardware and
software platforms other than the one it was built for?  But Unix
experience over decades tells us that durability down through time is
just as important, if not more so.  If we could predict the future of
software in detail it would probably be the present —
nevertheless, in programming for portability we should try to think
about making choices that will base the software on the features of
its environment that are likeliest to persist, and avoid technologies
that seem likely to face end-of-life in the foreseeable future.
</p>
<p>
  Under Unix, two decades of attention to the issues of
specifying portable APIs has largely solved that problem.  Facilities
described in the Single Unix Specification are likely to be present
on all modern Unix platforms today and rather unlikely to go 
unsupported in the future.
</p>
<p>
  But not all platform dependencies have to do with the system
or library APIs.  Your implementation language can matter; file-system
layout and configuration differences between the source and target
system can be a problem as well.  But Unix practice has evolved ways 
to cope.
</p>
<h4 id="id3000303"><a href="#id3000303">§</a>Portability and Choice of Language</h4>
<p>
  The first issue in programming for portability is your choice of
implementation language.  All the major languages we surveyed in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>
  are highly portable
in the sense that compatible implementations are available across all
modern Unixes; for most, implementations under Windows and MacOS are
available as well.  Portability problems tend to arise not in the core
languages but in support libraries and degree of integration with the
local environment (especially IPC and concurrent-process management,
including the infrastructure for GUIs).
</p>
<h5 id="c_portability"><a href="#c_portability">§</a>C Portability</h5>
<p>
  The core C language is extremely portable.  The standard Unix
implementation is the GNU C compiler, which is ubiquitous not only in
open-source Unixes but modern proprietary Unixes as well.  GNU C has
been ported to Windows and classic MacOS, but is not widely used in
either environment because it lacks portable bindings to the native
GUI.
</p>
<p>
  The standard I/O library, mathematics routines, and
internationalization support are portable across all C
implementations.  File I/O, signals, and process control are portable
across Unixes provided one takes care to use only the modern APIs
described in the Single Unix Specification; older C code often has
thickets of preprocessor conditionals for portability, but those
handle legacy pre-POSIX interfaces from older proprietary Unixes that 
are obsolete or close to it in 2003.
</p>
<p>
  C portability starts to be a more serious problem near IPC,
threads, and GUI interfaces.  We discussed IPC and threads portability
issues in
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>. The real practical problem is GUI
toolkits.  A number of open-source GUI toolkits are universally
portable across modern Unixes and to Windows and classic MacOS as well
— Tk, wxWindows, GTK, and Qt are four well-known ones with source
code and documentation readily discoverable by Web search.  But none
of them is shipped with all platforms, and (for reasons more legal
than technical) none of these offers the native-GUI look and feel on
all platforms.  We gave some guidelines for coping in
  <a href="#toolschapter" title="Chapter 15. Tools">
   Chapter 15</a>.
</p>
<p>
  Volumes have been written on the subject of how to write 
portable C code.  This book is not going to be one of them.   Instead,
we recommend a careful reading of
  <em>Recommended C Style and Coding Standards</em><sup><a href="#Cannon" title="[Cannon]">[Cannon]</a></sup>
and the chapter on portability in
  <em>The Practice of Programming</em> <sup><a href="#Kernighan-Pike99" title="[Kernighan-Pike99]">[Kernighan-Pike99]</a></sup>.
</p>
<h5 id="cc_portability"><a href="#cc_portability">§</a>C++ Portability</h5>
<p>
  C++ has all the same operating-system-level portability issues as C,
and some of its own.
An additional one is that the open-source GNU compiler for C++ has
lagged substantially behind the proprietary implementations for most
of its existence; thus, there is not yet as of mid-2003 a
universally deployed equivalent of GNU C on which to base a de-facto
standard.  Furthermore, no C++ compiler yet implements the full C++99
ISO standard for the language, though GNU C++ comes closest.
</p>
<h5 id="shell_portability"><a href="#shell_portability">§</a>Shell Portability</h5>
<p>
  Shell-script portability is, unfortunately, poor.  The problem
is not shell itself;
bash(1)
(the open-source Bourne Again shell) has become sufficiently
ubiquitous that pure shellscripts can run almost anywhere.  The
problem is that most shellscripts make heavy use of other commands and
filters that are much less portable, and by no means guaranteed to be
in the toolkit in any given target machine.
</p>
<p>
  This problem can be overcome by dint of heroic effort, as in the
autoconf(1)
tools.  But it is sufficiently severe that most of the heavier sort of
programming that used to be done in shell has moved to
second-generation scripting languages
  like Perl, Python, and Tcl.
</p>
<h5 id="perl_portability"><a href="#perl_portability">§</a>Perl Portability</h5>
<p>
  Perl has good portability. Stock Perl even offers a portable set
of bindings to the Tk toolkit that supports portable GUIs across
Unix, MacOS and Windows. One issue dogs it, however.  Perl scripts often
require add-on libraries from CPAN (the Comprehensive Perl Archive
Network) which are not guaranteed to be present with every Perl
implementation.
</p>
<h5 id="python_portability"><a href="#python_portability">§</a>Python Portability</h5>
<p>
  Python has excellent portability.  Like Perl, stock Python even
offers a portable set of bindings to the Tk toolkit that supports
portable GUIs across Unix, MacOS, and Windows.
</p>
<p>
  Stock Python has a much richer standard library than does
Perl
  and no
equivalent of CPAN for programmers to rely on; instead, important
extension modules are routinely incorporated into the stock Python
distribution during minor releases. This trades a spatial problem for
a temporal one, making Python much less subject to the missing-module
effect at the cost of making Python minor version numbers somewhat
more important than Perl release levels are.  In practice, the
tradeoff seems to favor Python.
</p>
<h5 id="tcl_portability"><a href="#tcl_portability">§</a>Tcl Portability</h5>
<p>
  Tcl portability is good, overall, but varies sharply by project
complexity.  The Tk toolkit for cross-platform GUI programming is
native to Tcl.  As with Python, evolution of the core language has
been relatively smooth, with few version-skew problems.
Unfortunately, Tcl relies even more heavily than Perl on extension
facilities that are not guaranteed to ship with every implementation
— and there is no equivalent of CPAN to centrally distribute
them.
</p>
<p>
  For smaller projects not reliant on extensions, therefore, Tcl
portability is excellent.  But larger projects tend to depend heavily
on both extensions and (as with shell programming) calling external
commands that may or may not be present on the target machine; their
portability tends to be poor.
</p>
<p>
  Tcl may have suffered, ironically, from
the ease of adding extensions to it.  By the time a particular extension
started to look interesting as part of the standard distribution, there
typically were several different versions of it in existence.  At the
1995 Tcl/Tk Workshop, John Ousterhout explained why there was no OO
support in the standard Tcl distribution:
</p>
 <blockquote>
  <p>
   Think of five mullahs sitting around in a circle, all saying
“Kill him, he's a heathen”.  If I put a specific OO
scheme into the core, then one of them will say “Bless you, my
son, you may kiss my ring”, and the other four will say
“Kill him, he's a heathen”.
  </p>
 </blockquote>
<p>
  The lot of a language designer is not necessarily a happy one.
</p>
<h5 id="java_portability"><a href="#java_portability">§</a>Java Portability</h5>
<p>
  Java portability is excellent — it was, after all,
designed with “write once, run everywhere” as a primary
goal.  Portability fails, however, to be perfect.  The difficulties are
mostly version-skew problems between JDK 1.1 and the older AWT GUI
toolkit (on the one hand) and JDK 1.2 with the newer Swing GUI toolkit.
There are several important reasons for these:
</p>
 <div>
  <ul>
   <li>
    <p>
     Sun's AWT design was so deficient that it had to be replaced 
with Swing.
    </p>
   </li>
   <li>
    <p>
     Microsoft's
     refusal to support Java development on Windows and attempt to replace
it with C#.
    </p>
   </li>
   <li>
    <p>
     Microsoft's decision to hold Internet Explorer's applet support 
at the JDK 1.1 level.
    </p>
   </li>
   <li>
    <p>
     Sun
     licensing terms that make open-source implementations of JDK 1.2
impossible, retarding its deployment (especially in the Linux
world).
    </p>
   </li>
  </ul>
 </div>
<p>
  For programs that involve GUIs, Java developers seeking
portability will, for the foreseeable future, face a choice: Stay in
JDK 1.1/AWT with a poorly designed toolkit for maximum portability
(including to Microsoft Windows), or get the better toolkit and
capabilities of JDK 1.2 at the cost of sacrificing some
portability.
</p>
<p>
  Finally, as we noted previously, the Java thread support has
portability problems.  The Java API, unlike less ambitious
operating-system bindings for other languages, bravely tried to bridge
the gaps between the diverging process models offered by different
operating systems.  It does not quite manage the trick.
</p>
<h5 id="emacs_lisp_portability"><a href="#emacs_lisp_portability">§</a>Emacs Lisp Portability</h5>
<p>
  Emacs Lisp portability is excellent. Emacs installations tend to
be upgraded frequently, so seriously out-of-date environments are
rare.  The same extension Lisp
  is supported everywhere and effectively
all extensions are shipped with Emacs itself.
</p>
<p>
  Then, too, the primitive set of Emacs is quite stable.  It
achieved completeness for the things an editor has to do (manipulating
buffers, bashing text) years ago.  Only the introduction of X has
disturbed this picture at all, and very few Emacs modes need to be
aware of X.  Portability problems are usually manifestations of quirks
in the C-level bindings of operating-system facilities; control of
subordinate processes in modes like mail agents is about the only
issue where such problems manifest with any frequency.
</p>
<h4 id="id3000882"><a href="#id3000882">§</a>Avoiding System Dependencies</h4>
<p>
  Once your language and support libraries are chosen, the next
portability issue is usually the location of key system files and
directories: mail spools, logfile directories and the like.
The archetype of this sort of problem is whether the mail spool
directory is
  <code>/var/spool/mail</code> or
  <code>/var/mail</code>.
</p>
<p>
  Often, you can avoid this sort of dependency by stepping back
and reframing the problem.  Why are you opening a file in the mail
spool directory, anyway?  If you're writing to it, wouldn't it be
better to simply invoke the local mail transport agent to do it for
you so the file-locking gets done right?  If you're reading from it, 
might it be better to query it through a POP3 or IMAP server?
</p>
<p>
  The same sort of question applies elsewhere.  If you find
yourself opening logfiles manually, shouldn't you be using
syslog(3)
instead?  Function-call interfaces through the C library are better
standardized than system file locations.  Use that fact!
</p>
<p>
  If you must have system file locations in your code, your best
alternative depends on whether you will be distributing in source code
or binary form.  If you are distributing in source, the
  <em>autoconf</em> tools we discuss in the next
section will help you.  If you're distributing in binary, then it's
good practice to have your program poke around at runtime and see if
it can automatically adapt itself to local conditions — say, by
actually checking for the existence of
  <code>/var/mail</code> and
  <code>/var/spool/mail</code>.
</p>
<h4 id="id3000984"><a href="#id3000984">§</a>Tools for Portability</h4>
<p>
  You can often use the open-source GNU
autoconf(1)
we surveyed in
  <a href="#toolschapter" title="Chapter 15. Tools">
   Chapter 15</a>
  to
handle portability issues, do system-configuration probes, and tailor
your makefiles.  People building from sources today expect to be able
to type
  <code>configure; make; make install</code>
  and get a clean build.  There is a good
  <a href="http://seul.org/docs/autotut/">
   tutorial on these tools</a>. Even if you're distributing in binary, the
autoconf(1)
tools can help automate away the problem of conditionalizing your code
for different platforms.
</p>
<p>
  Other tools that address this problem; two of the better known
are the
Imake(1)
tool associated with the X windowing system and the
  <em>Configure</em> tool built by Larry Wall (later
the inventor of Perl) and adapted for many different
projects.  All are at least as complicated as the autoconf suite, and
no longer as often used.  They don't cover as wide a range of target
systems.
</p>



<!-- FILE: ch17s06.html -->
<h3 id="ch17s06"><a href="#ch17s06">§</a>Internationalization</h3>
<p>
  An in-depth discussion of code internationalization —
designing software so the interface readily incorporates multiple
languages and the vagaries of different character sets — would be
out of scope for this book.  However, a few lessons for good practice 
do stand out from Unix experience.
</p>
<p>
  First,
  <em>
   separate the message base from the
code
</em>.  Good Unix practice is to separate the message
strings a program uses from its code. so that message dictionaries
in other languages can be plugged in without modifying the
code.
</p>
<p>
  The best-known tool for this job is GNU
  <em>gettext</em>, which requires that you wrap 
native-language strings that need to be internationalized in
a special macro.  The macro uses each string as a key into per-language
dictionaries which can be supplied as separate files.  If no such
dictionaries are available (or if they are but the string lookup does
not return a match), the macro simply returns its argument, implicitly
falling back on the native language in the code.
</p>
<p>
  While
  <em>gettext</em> itself is messy and
fragile as of mid-2003, its general philosophy is sound.  For many
projects, it is possible to craft a lighter-weight version of this
idea with good results.
</p>
<p>
  Second, there is a clear trend in modern Unixes to scrap all the
historical cruft associated with multiple character sets and make
applications natively speak UTF-8, the 8-bit shift encoding of the
Unicode character set (as opposed to, say, making them natively speak
16-bit wide characters).  The low 128 characters of UTF-8 are ASCII,
and the low 256 are Latin-1, which means this choice is
backward-compatible with the two most widely used character sets.  The
fact that XML and Java have made this choice helps, but the momentum
is present even where XML and Java are not.
</p>
<p>
  Third, beware of character ranges in regular expressions.  The
element
  <code>[a-z]</code>
  will not necessarily catch all
lower-case letters if the script or program it's in is applied to
(say) German, where the sharp-s or ß character is considered
lower-case but does not fall in that range; similar problems arise
with French accented letters. Its safer to use
  <code>[[:lower:]]</code>. and other symbolic ranges described in
the POSIX standard.
</p>



<!-- FILE: ch17s07.html -->
<h3 id="ch17s07"><a href="#ch17s07">§</a>Portability, Open Standards, and Open Source</h3>
<p>
  Portability requires standards.  Open-source reference
implementations are the most effective method known for both
promulgating a standard and for pressuring proprietary vendors into
conforming.  If you are a developer, open-source implementations of a
published standard can both tremendously reduce your coding workload
and allow your product to benefit (in ways both expected and
unexpected) from the labor of others.
</p>
<p>
  Let's suppose, for example, you are designing image-capture
software for a digital camera.  Why write your own format for saving
image bits or buy proprietary code when (as we noted in
  <a href="#textualitychapter" title="Chapter 5. Textuality">
   Chapter 5</a>) there is a well-tested, full-featured
library for writing PNGs in open source?
</p>
<p>
  The (re)invention of open source has had a significant impact on
the standards process as well.  Though it is not formally a
requirement, the IETF
  has since around 1997 grown increasingly resistant to
standard-tracking RFCs that do not have at least one open-source
reference implementation. In the future, it seems likely that
conformance to any given standard will increasingly be measured by
conformance to (or outright use of!) open-source implementations that
have been blessed by the standard's authors.
</p>
 <blockquote>
  <p>
   The flip side of this is that often the best way to
   <em>make</em>
   something a standard is to distribute a
high-quality open-source implementation of it.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  In the end, the most effective step you can take to ensure the
portability of your code is to not rely on proprietary technology.
You never know when the closed-source library or tool or code
generator or network protocol you are depending on will be
end-of-lifed, or when the interface will be changed in some
backwards-incompatible way that breaks your project.  With open-source
code, you have a path forward even if the leading-edge version changes
in a way that breaks your project; because you have access to source
code, you can forward-port it to new platforms if you need to.
</p>
<p>
  Until the late 1990s this advice would have been 
impractical.  The few alternatives to relying on proprietary operating
systems and development tools were noble experiments, academic
proofs-of-concept, or toys.  But the Internet changed everything; in
mid-2003 Linux
  and the other open-source Unixes exist
and have proven their mettle as platforms for delivering
production-quality software.  Developers have a better option now than
being dependent on short-term business decisions designed to protect
someone else's monopoly.  Practice defensive design — build on
open source and don't get stranded!
</p>



<!-- FILE: documentationchapter.html -->
<h3 id="documentationchapter"><a href="#documentationchapter">§</a>Chapter 18. Documentation</h3>
 <blockquote class="epigraph">
  <p>
   I've never met a human being who would want to read 17,000 pages of
documentation, and if there was, I'd kill him to get him out of the
gene pool.
  </p>
  <span>
   – Joseph Costello
  </span>
 </blockquote>
<p>
  Unix's first application, in 1971, was as a platform for
document preparation — Bell Labs used it to prepare patent
documents for filing.  Computer-driven phototypesetting was still a
novel idea then, and for years after it debuted in 1973 Joe Ossana's
troff(1)
formatter defined the state of the art.
</p>
<p>
  Ever since, sophisticated document formatters, typesetting
software, and page-layout programs of various sorts have been an
important theme in the Unix tradition.  While
troff(1)
has proven surprisingly durable, Unix has also hosted a lot of
groundbreaking work in this application area.  Today, Unix developers
and Unix tools are at the cutting edge of far-reaching changes in
documentation practice triggered by the advent of the World Wide
Web.
</p>
<p>
  At the user-presentation level, Unix-community practice has been
moving rapidly toward ‘everything is HTML, all references are
URLs’ since the mid-1990s.  Increasingly, modern Unix help
browsers are simply Web browsers that know how to parse certain
specialized kinds of URLs (for example, ‘man:ls(1)’
interprets the ls(1) man page into HTML).  This relieves the problems
created by having lots of different formats for documentation masters,
but does not entirely solve them.  Documentation composers still have
to grapple with issues about which master format best meets their
particular needs.
</p>
<p>
  In this chapter, we'll survey the rather unfortunate surfeit 
of different documentation formats and tools left behind by decades of
experimentation, and we'll develop guidelines for good practice
and good style.
</p>



<!-- FILE: ch18s01.html -->
<h3 id="ch18s01"><a href="#ch18s01">§</a>Documentation Concepts</h3>
<p>
  Our first distinction is between “What You See Is What You
Get” (WYSIWYG) documentation programs and
  <em>markup-centered tools</em>. Most desktop-publishing
programs and word processors are in the former category; they have
GUIs in which what one types is inserted directly into an on-screen
presentation of the document intended to resemble the final printed
version as closely as possible.  In a markup-centered system, by
contrast, the master document is normally flat text containing
explicit, visible control tags and not at all resembling the intended
output.  The marked-up source can be modified with an ordinary text
editor, but has to be fed to a formatter program to produce rendered
output for printing or display.
</p>
<p>
  The visual-interface, WYSIWYG style was too expensive for early
computer hardware, and remained rare until the advent of the Macintosh
personal computer in 1984. It is completely dominant on non-Unix
operating systems today, Native Unix document tools, on the other
hand, are almost all markup-centered. The Unix
troff(1)
of 1971 was a markup formatter, and is probably the oldest such
program still in use.
</p>
<p>
  Markup-centered tools still have a role because actual implementations of WYSIWYG tend to be broken in various ways —
  some superficial, some deep.  WYSIWYG document processors have the general problem with GUIs that we discussed in <a
  href="#interfacechapter" title="Chapter 11. Interfaces"> Chapter 11</a>; the fact that you <em>can</em> visually
  manipulate anything tends to mean you <em>must</em> visually manipulate everything.  That would remain a problem even
  if the WYSIWIG correspondence between screen and printer output were perfect — but it almost never is.
</p>
<p>
  In truth, WYSIWYG document processors aren't exactly
WYSIWIG. Most have interfaces that obscure the differences between
screen presentation and printer output without actually eliminating
them. Thus they violate the Rule of Least Surprise: the visual aspect
of the interface encourages you to use the program like a
typewriter even though it is not, and your input will occasionally
produce an unexpected and undesired result.
</p>
<p>
  In further truth, WYSIWIG systems actually rely on markup codes
but expend great effort on keeping them invisible in normal use.  Thus they
break the Rule of Transparency: you can't see all of the markup, so it
is difficult to fix documents that break because of misplaced markup
codes.
</p>
<p>
  Despite its problems, WYSIWYG document processors can be very
nice if what you want is to slide a picture three ems to the right on
the cover of a four-page brochure.  But they tend to be constricting
any time you need to make a global change to the layout of a 300-page
manuscript. WYSIWYG users faced with that kind of challenge must give
it up or suffer the death of a thousand mouse clicks; in situations
like that, there is really no substitute for being able to edit
explicit markup, and Unix's markup-centered document tools offer
better solutions.
</p>
<p>
  Today, in a world influenced by the example of the Web and XML,
it has become common to make a distinction between
  <em>presentation</em> and
  <em>structural</em> markup in documents — the
former being instructions about how a document should look, the latter
being instructions about how it's organized and what it means.
This distinction wasn't clearly understood or followed through in
early Unix tools, but it's important for understanding the design
pressures that led to today's descendants of them.
</p>
<p>
  Presentation-level markup carries all the formatting information
(e.g., about desired whitespace layout and font changes) in the
document itself.  In a structural-markup system, the document has to
be combined with a
  <em>stylesheet</em> that tells  the
formatter how to translate the structure markup in the document to a
physical layout.  Both kinds of markup ultimately control the physical
appearance of a printed or browsed document, but structural markup
does it through one more level of indirection that turns out to be
necessary if you want to produce good results for both printing 
and the Web.
</p>
<p>
  Most markup-centered documentation systems support a macro
facility.  Macros are user-defined commands that are expanded by text
substitution into sequences of built-in markup requests.  Usually,
these macros add structural features (like the ability to declare
section headings) to the markup language.
</p>
 <blockquote>
  <p>
   The troff macro sets (
   <em>mm</em>,
   <em>me</em>, and my
   <em>ms</em> package) were actually designed to push
people away from format-oriented editing and toward content-oriented
editing.  The idea was to label the semantic parts and then have
different style packages that would know whether in this style the
title should be boldfaced or not, centered or not, and so on.  Thus
there was at one point a set of macros that tried to imitate ACM
style, and another that imitated Physical Review style, but used the
basic
   <code>-ms</code> markup.  All of the macros lost out to
people who were focused on producing one document, and controlling its
appearance, just as Web pages get bogged down in the dispute over
whether the reader or author should control the appearance.  I
frequently found secretaries who were using the .AU
(author name) command just to produce italics, noticing that it did
that, and then getting into trouble with its other effects.
  </p>
  <span>
   – Mike Lesk
  </span>
 </blockquote>
<p>
  Finally, we note that there are significant differences between
the sorts of things composers want to do with small documents
(business and personal letters, brochures, newsletters) and the things
they want to do with large ones (books, long articles, technical
papers, and manuals).  Large documents tend to have more structure, to
be pieced together from parts that may have to be changed separately,
and to need automatically-generated features like tables of contents;
these are both traits that favor markup-centered tools.
</p>



<!-- FILE: ch18s02.html -->
<h3 id="ch18s02"><a href="#ch18s02">§</a>The Unix Style</h3>
<p>
  The Unix style of documentation (and documentation tools) has
several technical and cultural traits that set it apart from the way
documentation is done elsewhere.  Understanding these signature traits
first will create context for you to understand why the programs
and the practice look the way they do, and why the documentation reads
the way it does.
</p>
<h4 id="id3001392"><a href="#id3001392">§</a>The Large-Document Bias</h4>
<p>
  Unix documentation tools have always been designed primarily for
the challenges involved in composing large and complex documents.
Originally it was patent applications and paperwork; later it was
scientific and technical papers, technical documentation of all sorts.
Consequently, most Unix developers learned to love markup-centered
documentation tools.  Unlike the PC users of the time, the Unix
culture was unimpressed with WYSIWYG word processors when they became
generally available in the late 1980s and early 1990s — and even
among today's younger Unix hackers it is still unusual to find anyone
who really prefers them.
</p>
<p>
  Dislike of opaque binary document formats — and especially
of opaque
  <em>proprietary</em>
  binary formats — also
played a part in the rejection of WYSIWYG tools.  On the other hand,
Unix programmers seized on PostScript (the now-standard language for
controlling imaging printers) with enthusiasm as soon as the language
documentation became available; it fits neatly in the Unix tradition
of domain-specific languages.  Modern open-source Unix systems have
excellent PostScript and Portable Document Format
(PDF)
  tools.
</p>
<p>
  Another consequence of this history is that Unix documentation
tools have tended to have relatively weak support for including
images, but strong support for diagrams, tables, graphing, and
mathematical typesetting — the sorts of things often needed in
technical papers.
</p>
<p>
  The Unix attachment to markup-centered systems has often been
caricatured as a prejudice or a troglodyte trait, but it is not really
anything of the kind.  Just as the putatively ‘primitive’
CLI style of Unix is in many ways better adapted to the needs of power
users than GUIs, the markup-centered design of tools like
troff(1)
is a better fit for the needs of power documenters than are WYSIWYG
programs.
</p>
<p>
  The large-document bias in Unix tradition did not just keep Unix
developers attached to markup-based formatters like
  <em>troff</em>, it also made them interested in
structural markup.  The history of Unix document tools is one of
lurching, muddled, and erratic movement in a general direction away
from presentation markup and toward structural markup.  In mid-2003
this journey is not yet over, but the end is distantly in
sight.
</p>
<p>
  The development of the World Wide Web meant that the ability to
render documents in multiple media (or, at least, for both print and
HTML display) became the central challenge for documentation tools
after about 1993.  At the same time, even ordinary users were, under
the influence of HTML, becoming more comfortable with markup-centered
systems.  This led directly to an explosion of interest in structural
markup and the invention of XML after 1996.  Suddenly the old-time
Unix attachment to markup-centered systems started looking prescient
rather than reactionary.
</p>
<p>
  Today, in mid-2003, most of the leading-edge development of
XML-based documentation tools using structural markup is taking place
under Unix.  But, at the same time, the Unix culture has yet to let go
of its older tradition of presentation-level markup systems. The
creaking, clanking, armor-plated dinosaur that is
  <em>troff</em> has only partly been displaced by
HTML and XML.
</p>
<h4 id="id3001522"><a href="#id3001522">§</a>Cultural Style</h4>
<p>
  Most software documentation is written by technical writers for
the least-common-denominator ignorant — the knowledgeable
writing for the knowledgeless.  The documentation that ships with Unix
systems has traditionally been written by programmers for their peers.
Even when it is not peer-to-peer documentation, it tends to be
influenced in style and format by the enormous mass of
programmer-to-programmer documentation that ships with Unix
systems.
</p>
<p>
  The difference this makes can be summed up in one observation:
Unix manual pages traditionally have a section called BUGS.  In other
cultures, technical writers try to make the product look good by
omitting and skating over known bugs.  In the Unix culture, peers
describe the known shortcomings of their software to each other in
unsparing detail, and users consider a short but informative BUGS
section to be an encouraging sign of quality work.  Commercial Unix
distributions that have broken this convention, either by suppressing
the BUGS section or euphemizing it to a softer tag like LIMITATIONS or
ISSUES or APPLICATION USAGE, have invariably fallen into
decline.
</p>
<p>
  Where most other software documentation tends to to oscillate
between incomprehensibility and oversimplifying condescension, classic
Unix documentation is written to be telegraphic but complete.  It does
not hold you by the hand, but it usually points in the right
direction.  The style assumes an active reader, one who is able
to deduce obvious unsaid consequences of what is said, and who has
the self-confidence to trust those deductions.
</p>
<p>
  Unix programmers tend to be good at writing references,
and most Unix documentation has the flavor of a reference or
  <span class="foreignphrase">
   <em>aide memoire</em> </span>
  for someone who thinks
like the document-writer but is not yet an expert at his or her
software.  The results often look much more cryptic and sparse than
they actually are.  Read every word carefully, because whatever you
want to know will probably be there, or deducible from what's there.
Read every word carefully, because you will seldom be told anything
twice.
</p>



<!-- FILE: ch18s03.html -->
<h3 id="ch18s03"><a href="#ch18s03">§</a>The Zoo of Unix Documentation Formats</h3>
<p>
  All the major Unix documentation formats except the very newest
one are presentation-level markups assisted by macro packages.  We
examine them here from oldest to newest.
</p>
<h4 id="id3001604"><a href="#id3001604">§</a>troff and the Documenter's Workbench Tools</h4>
<p>
  We discussed the Documenter's Workbench architecture and tools
in
  <a href="#minilanguageschapter" title="Chapter 8. Minilanguages">
   Chapter 8</a>
  as an
example of how to integrate a system of multiple minilanguages.  Now
we return to these tools in their functional role as a typesetting
system.
</p>
<p>
  The <em>troff</em> formatter interprets a presentation-level markup language.  Recent implementations like the GNU
  project's groff(1) emit PostScript by default, though it is possible to get other forms of output by selecting a
  suitable driver.  See Example 18.1 for several of the <em>troff</em> codes you might encounter in document sources.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 18.1. groff(1) markup example.
   </b>
  </p>
  <pre class="programlisting">
This is running text.
.\" Comments begin with a backslash and double quote.
.ft B
This text will be in bold font.
.ft R
This text will be back in the default (Roman) font.
These lines, going back to "This is running text", will 
be formatted as a filled paragraph.
.bp
The bp request forces a new page and a paragraph break.
This line will be part of the second filled paragraph.
.sp 3
The .sp request emits the number of blank lines given as argument
.nf
The nf request switches off paragraph filling.
Until the fi request switches it back on
whitespace and layout will be preserved.

One word in this line will be in \fBbold\fR font.
.fi

Paragraph filling is back on.
</pre>
 </div>
<p>
  troff(1) has many other requests, but you are unlikely to see most of them directly.  Very few documents are written
  in bare <em>troff</em>.  It supports a macro facility, and half a dozen macro packages are in more or less general
  use.  Of these, the overwhelmingly most common is the man(7) macro package used to write Unix manual pages.  See
  Example 18.2 for a sample.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 18.2.
    <em>man</em> markup example.
   </b>
  </p>
  <pre class="programlisting">
.SH SAMPLE SECTION
The SH macro starts a section, boldfacing the section title.  
.P
The P request starts a new paragraph.  The I request sets its 
argument in
.I italics.
.IP *
This starts an indented paragraph with an asterisk label.
More text for the first bulleted paragraph.
.TP
This first line will become a paragraph label
This will be the first line in the paragraph, further indented
relative to the label.

The blank line just above this is treated almost exactly like a
paragraph break (actually, like the troff-level request .sp 1).
.SS A subsection
This is subsection text.  
</pre>
 </div>
<p>
  Two of the other half-dozen historical
  <em>troff</em> macro libraries, 
ms(7)
and
mm(7)
are still in use.  BSD Unix has its own elaborate
extended macro set,
mdoc(7).
All these are designed for writing technical manuals and long-form
documentation.  They are similar in style but more elaborate than man
macros, and oriented toward producing typeset output.
</p>
<p>
  A minor variant of
troff(1)
called
nroff(1)
produces output for devices that can only support constant-width
fonts, like line printers and character-cell terminals.  When you view
a Unix manual page within a terminal window, it is nroff that has
rendered it for you.
</p>
<p>
  The Documenter's Workbench tools do the technical-documentation
jobs they were designed for quite well, which is why they have
remained in continuous use for more than thirty years while computers
increased a thousandfold in capacity. They produce typeset text of
reasonable quality on imaging printers, and can throw a tolerable
approximation of a formatted manual page on your screen.
</p>
<p>
  They fall down badly in a couple of areas, however.  Their stock
selection of available fonts is limited.  They don't handle images
well. It's hard to get precise control of the positioning of text or
images or diagrams within a page.  Support for multilingual documents
is nonexistent.  There are numerous other problems, some chronic but
minor and some absolute showstoppers for specific uses.  But the most
serious problem is that because so much of the markup is presentation
level, it's difficult to make good Web pages out of unmodified
  <em>troff</em> sources.
</p>
<p>
  Nevertheless, at time of writing man pages remain the single 
most important form of Unix documentation.
</p>
<h4 id="id3001898"><a href="#id3001898">§</a>TeX</h4>
<p>
  <em>TeX</em> (pronounced
  <span class="phonetic">
   /teH/
  </span>
  with a rough h as though you are
gargling) is a very capable typesetting program that, like the
Emacs editor, originated outside the Unix
culture but is now naturalized in it.  It was created by noted
computer scientist Donald Knuth
  when he became impatient with the quality of
typography, and especially mathematical typesetting, that was
available to him in the late 1970s.
</p>
<p>
  <em>TeX</em>, like
troff(1),
is a markup-centered system.
  <em>TeX</em> 's request
language is rather more powerful than
  <em>troff</em> 's; among other things, it is better
at handling images, page-positioning content precisely, and
internationalization.
  <em>TeX</em> is particularly
good at mathematical typesetting, and unsurpassed at basic typesetting
tasks like kerning, line filling, and hyphenating.
  <em>TeX</em> has become the standard submission
format for most mathematical journals.  It is actually now maintained
as open source by a working group of the the American Mathematical
Society.  It is also commonly used for scientific papers.
</p>
<p>
  As with
troff(1),
human beings usually do not write large volumes of raw
  <em>TeX</em> macros by hand; they use macro packages
and various auxiliary programs instead.  One particular macro package,
  <em>LaTeX</em>, is almost universal, and most people who say they're composing
in
  <em>TeX</em> almost always actually mean they're
writing
  <em>LaTeX</em>.  Like
  <em>troff</em> 's macro
packages, a lot of its requests are semi-structural.
</p>
<p>
  One important use of
  <em>TeX</em> that is
normally hidden from the user is that other document-processing tools
often generate
  <em>LaTeX</em> to be turned into PostScript, rather than
attempting the much more difficult job of generating PostScript
themselves.  The
xmlto(1)
front end that we discussed as a shell-programming case study in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>
  uses this tactic; so does the XML-DocBook
toolchain we'll examine later in this chapter.
</p>
<p>
  <em>TeX</em> has a wider application range
than
troff(1)
and is in most ways a better design.  It has the same fundamental
problems as
  <em>troff</em> in an increasingly
Web-centric world; its markup has strong ties to the presentation
level, and automatically generating good Web pages from
  <em>TeX</em> sources is difficult and
fault-prone.
</p>
<p>
  <em>TeX</em> is never used for Unix system
documentation and only rarely used for application documentation;
for those purposes,
  <em>troff</em> is sufficient.
But some software packages that originated in academia outside the
Unix community have imported the use of
  <em>TeX</em> as a documentation master format; the Python
language
  is
one example.  As we noted above, it is also heavily used for
mathematical and scientific papers, and will probably dominate that
niche for some years yet.
</p>
<h4 id="id3002206"><a href="#id3002206">§</a>Texinfo</h4>
<p>
  Texinfo is a documentation markup invented by the Free Software
Foundation and used mainly for GNU
  project documentation — including
the documentation for such essential tools as
Emacs and the GNU Compiler
Collection.
</p>
<p>
  Texinfo was the first markup system specifically designed to
support both typeset output on paper and hypertext output for
browsing.  The hypertext format was not, however, HTML; it was a more
primitive variety called ‘info’, originally designed to be
browsed from within Emacs. On the print
side, Texinfo turns into
  <em>TeX</em> macros and can
go from there to PostScript.
</p>
<p>
  The Texinfo tools can now generate HTML.  But they don't do a
very good or complete job, and because a lot of Texinfo's markup
is at presentation level it is doubtful that they ever will.  As of
mid-2003, the Free Software Foundation is working on heuristic Texinfo 
to DocBook translation.  Texinfo will probably remain a live format
for some time.
</p>
<h4 id="id3002268"><a href="#id3002268">§</a>POD</h4>
<p>
  Plain Old Documentation is the markup system used by the
maintainers of Perl.  It generates manual pages, and has
all the familiar problems of presentation-level markups, including
trouble generating good HTML.
</p>
<h4 id="id3002291"><a href="#id3002291">§</a>HTML</h4>
<p>
  Since the World Wide Web entered the mainstream in the early
1990s, a small but increasing percentage of Unix projects have been
writing their documentation directly in HTML.  The problem with this
approach is that it is difficult to generate high-quality typeset
output from HTML.  There are particular problems with indexing as
well; the information needed to generate indexes is not present in
HTML.
</p>
<h4 id="id3002310"><a href="#id3002310">§</a>DocBook</h4>
<p>
  DocBook is an SGML and XML document type definition designed for
large, complex technical documents.  It is alone among the markup
formats used in the Unix community in being purely structural.  The
xmlto(1)
tool discussed in
  <a href="#languageschapter" title="Chapter 14. Languages">
   Chapter 14</a>
  supports rendering to HTML, XHTML,
PostScript, PDF, Windows
Help markup, and several less important formats.
</p>
<p>
  Several major open-source projects (including the Linux
Documentation Project, FreeBSD,
Apache, Samba, GNOME,
and KDE) already use DocBook as a master format.  This book was
written in XML-DocBook.
</p>
<p>
  DocBook is a large topic. We'll return to it after summing up
the problems with the current state of Unix documentation.
</p>



<!-- FILE: ch18s04.html -->
<h3 id="ch18s04"><a href="#ch18s04">§</a>The Present Chaos and a Possible Way Out</h3>
<p>
  Unix documentation is, at present, a mess.
</p>
<p>
  Between
  <em>man</em>,
  <em>ms</em>,
  <em>mm</em>,
  <em>TeX</em>, Texinfo, POD, HTML, and DocBook, the
documentation master files on modern Unix systems are scattered across
eight different markup formats.  There is no uniform way to view all
the rendered versions.  They aren't Web-accessible, and they aren't
cross-indexed.
</p>
<p>
  Many people in the Unix community are aware that this is a
problem.  At time of writing most of the effort toward solving it has
come from open-source developers, who are more actively interested in
competing for acceptance by nontechnical end users than developers
for proprietary Unixes have been.  Since 2000, practice has been
moving toward use of XML-DocBook as a documentation interchange
format.
</p>
<p>
  The goal, which is within sight but will take a lot of effort to
achieve, is to equip every Unix system with software that will act as
a systemwide document registry. When system administrators install
packages, one step will be to enter the package's XML-DocBook 
documentation into the registry.  It will then be rendered into a
common HTML document tree and cross-linked to the documentation
already present.
</p>
<p>
  Early versions of the document-registry software are already
working.  The problem of forward-converting documentation from the
other formats into XML-DocBook is a large and messy one, but the
conversion tools are falling into place.  Other political and
technical problems remain to be attacked, but are probably
solvable. While there is not as of mid-2003 a communitywide
consensus that the older formats have to be phased out, that seems the
likeliest working out of events.
</p>
<p>
  Accordingly, we'll next take a very detailed look at DocBook and
its toolchain. This description should be read as an introduction to
XML under Unix, a pragmatic guide to practice and as a major case
study. It's a good example of how, in the context of the Unix
community, cooperation between different project groups develops
around shared standards.
</p>



<!-- FILE: ch18s05.html -->
<h3 id="ch18s05"><a href="#ch18s05">§</a>DocBook</h3>
<p>
  A great many major open-source projects are converging on
DocBook as a standard format for their documentation.  The advocates
of XML-based markup seem to have won the theoretical argument against
presentation-level and for structural-level markup, and an effective
XML-DocBook toolchain is available in open source.
</p>
<p>
  Nevertheless, a lot of confusion still surrounds DocBook and the
programs that support it.  Its devotees speak an argot that is dense
and forbidding even by computer-science standards, slinging around
acronyms that have no obvious relationship to the things you need to
do to write markup and make HTML or PostScript from it.  XML standards
and technical papers are notoriously obscure. In the rest of this
section, we'll try to dispel the fog of jargon.
</p>
<h4 id="id3006015"><a href="#id3006015">§</a>Document Type Definitions</h4>
<p>
  (Note: to keep the explanation simple, most of this section
tells some lies, mainly by omitting a lot of history.  Truthfulness
will be fully restored in a following section.)
</p>
<p>
  DocBook is a structural-level markup language.  Specifically, it
is a dialect of XML.  A DocBook document is a piece of XML that uses
XML tags for structural markup.
</p>
<p>
  For a document formatter to apply a stylesheet to your document
and make it look good, it needs to know things about the overall
structure of your document.  For example, in order to physically
format chapter headers properly, it needs to know that a book
manuscript normally consists of front matter, a sequence of chapters,
and back matter.  In order for it to know this sort of thing, you
need to give it a
  <em>Document Type Definition</em>
  or DTD. The
DTD tells your formatter what sorts of elements can be in the document
structure, and in what order they can appear.
</p>
<p>
  What we mean by calling DocBook a ‘dialect’ of XML
is actually that DocBook is a DTD — a rather large DTD, with
somewhere around 400 tags in it.<sup><a href="#ftn.id3006067" id="id3006067">[152]</a></sup>
</p>
<p>
  Lurking behind DocBook is a kind of program called a
  <em>validating parser</em>. When you format a DocBook document, the
first step is to pass it through a validating parser (the front end of
the DocBook formatter).  This program checks your document against the
DocBook DTD to make sure you aren't breaking any of the DTD's
structural rules (otherwise the back end of the formatter, the part
that applies your stylesheet, might become quite confused).
</p>
<p>
  The validating parser will either throw an error, giving you messages
about places where the document structure is broken, or translate the
document into a stream of XML elements and text that the parser back
end combines with the information in your stylesheet to produce
formatted output.
</p>
<p>
   Figure 18.1 diagrams the whole process.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 18.1. Processing structural documents.
   </b>
  </p>
  <div class="center">
   <img alt="Processing structural documents." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAckAAAC1CAAAAAARw1ujAAAAAnRSTlMA/1uRIrUAAAACYktHRAD/h4/MvwAAAAlwSFlzAAAAZAAAAGQAD5bF3QAAC+hJREFUeNrtnbGu6soVhleRKlIkW1G6SFuiSkVDcysq2i3dBukUSLdzZSVKc11QnyvkNpVpUqSCJ0DyC1C4d+WW0q8wmTVjsAFvPIYFg2evX8cGBjPze317xmMvHwBhU0VEp2KgDqgEVltPU9tV2XdAJSZp2wGVmKRtB1RikrYdUIlJ2nZAJSZp2wGVmKRtB1RikrYdUIlJ2nZAJSZp2wGVmKRtB1RikrYdUIlJ2nZAJSZp2wGVmKRtB1RikrYdUIlJ2nZAJSZp2wGVmGTz1cX9G9nFxttX7cw9ek+S5Qp88OcycjPQSuuiflWZO1j5AJNmLdlFcFIwrcqG3pOk9pX5KxHp51FaF/WtytSBjy9XzZ54GZyWYGWtVdnQO5MUyUSU1fOyLupblakDP8DXCmZbcLKyJViNjZnkDV8lND02i/pUZeoggRm+kGOsKP2RSEeqrTmALw+fgQ+RgAjXVZFa48YPOqDSW5MU1yTF80iK7QiiUqQ4oAeBKCNsK8GDtCyBstjKFR47dZFeq40fc0Cltyb52j4pFUhoCk4BRZJhi0Gi34n8RDuAqkivmWTnzjcPinBd1KcqQwcpnoJEUMEJgki1iA/qYL2Sh9GKpCrSaybZufPoK/X1OQeUV0V9qjJ0kOIZSDYT6QybK3CSjKOrnwo5rsozTTmuapK6SK/1xg85oNJ7kswieRAaBdnxeXpe1KcqYwflRE5fAglmAjghlYhSWBWyl/rY7+YwSfD1VnrRRXqtN37EAZXek+TrqvryY1Gvaoh35h4xybbSIl31r45JWq2q/WMr6N8lmaTdquw7oBKTtO2ASkzStgMqMUnbDqjEJG07oBKTtO2ASkzStgMqMUnbDqjEJG07oBKTtO2ASkzStgMqMUnbDqjEJG07oBKTtO2ASkzStgMqMUnbDqjEJG07oBKTtO2ASpZJBibfZfyLyUbBnSStO6CSXZJmuuOeGuccdItJDsNBt5jkMBx0i0kOw0G3hkDS7kziPRx0awgkWSZikq6ISboiJumKmKQrYpKuaAgk7Z/N2XfQLSY5DAfdYpLDcNAtJjkMB91iksNw0K0hkLR/1dO+g24NgSTLREzSFb2KZIyr9Duu4hdFmPukK2KSrmgIJO2fA9h30C0mOQwH3XoVyUfOyOzH8REHrzoX5T45DAfdYpLDcNCtIZC0f63MvoNuDYEky0RDmPEMWzzjYfUTk3RFTNIVDYGk/XMA+w66NYQZj/048jUeGg2b5KvEJIfhoFtMchgOujUEkvavKth30K23n/Fkv6CKez9OoAcd8IynUuEBgGeTpH0HRnp7kmKEvzv5zR2Y6P1JTmUcp9/cgYnen+TvMo4/v7kDE739jEdknu2D1GMOeMZz0t+tH6TsOzDQAEhOrB+k7Dsw0ABI/m79IGXfgYEGQDID2+dy9h0YCAqTrxM21I39bT/uF/820V+Mtrov2M93cGPGQxp7sPpF4OnmQKXNnd+ebdMBaeyZJJOkMMYk6WLPJJlkP2Ptb30HkreCMkSStuL41g6YJJNsqYpJMkkKY0ySLvbvOuPZnZ7l8bBJPnHGUyaNqr4iOQOIMjHzV6V8pi5DlT5k5QpIjdVxnALkMhgwzjVIOBy8CiQ0w+U9j2S+BFRoo0/KwKL63Y1ZJtCo6ss+mfqjUqRYNfgBFqxm+LlbV9wfGl1DwG4YHztgA9/p6Y42jpcOdEv5+iau3dc+HhtdMbDl9ubmWbWcf6iTpOyDUaEQQqQ65Sh9KsnDx0KuPhtBzfNzkpvlQRfuT71o/0gc20nWr7HyfX5Ba1n5qDchJFm/xIAX5cXWK730Jim2MFd1QYmdMpmJ55KMYX/Yh4dwDGMVVDWqLj/Ak4+q0ANduIbYgwUWel49FhKRzGXFuw8Y72RT68WvsJzCNFTNnDzgcvgE8Pa4SUhHspRhzkYwyUQC2+AHyFFwFvk45EYTmAgfQC1iDuAXYjUC35CkGPmapIigFJPiIZIGMx5PYtwfFrprgPoXysF2Lx9V4SY8nN7bgSK/HtP2SbyJ7nCQx+qFfMADN+j2d00PuMT6iArNLvvYjAcrnAkxKUUww96jQl0AJkeFCPAVHupwSdQRNUr02yYko8Sfa5JyoE0D8eQ+eQi9/BNnOHFN0jv2FCxsksSgykjmU/LRdakbhGZT5x5wWcRnAz/R6LrSXRPqUFdLmSQ1yUDNWP3jh7pJbiORwkpvHvizokGy/CKn+hjJ3JvGh73sEDVJ2KinuvCCpBxlYZqTkzw0x4TGUntQJNFLTk2yRndOspA9tUESp6GlOokwIpnhbCfwEWAmu3HQqFoEZetHHr0ysPiQHfMjz+tIfo432D104Waan4U3zB+L45ckF/vD5vOSZO0Bl9jbHPbrJ5AMCpHOL0lGo1J21HRWqiXxU1Fs55NU9d5OkqmcuYoygkma4GmOfJFGsM0iddoz6TZ2D0k53znsPC/0xvsNLP8Dy30uJxbhx7IqHMNSlsv34v0SNjgvmX6u6UjuQtBk8il2dtnlww3ARj7ma9jVHg64hCAP6+uzs89HSGJg1RN5+i5hbWXMU4BUPpZbyDLfj/xJMZFDJC4R+JEo5bwnGq3qqt71Gk+3dpt8s1l798fxYQcX4qzWnfLWeFkm7ojjMx2YkSQN2I2qrJA8HWYfiWP8AfC5uzOOJA7uJVk3PnSS6V//8et/S1txtO6g0fjgSeKs6W+4O9ZI2nTQaPxtSf74+sba5ls/oNKf/kwYxx+dN/facfDjRuP/fFeSff4owRtNf/7PZp+05aDR+Cv65D335puTxN3AFuyNruYObm7QTIObkzw1/nSSK1+e/fdvxdRY8fP4d9IaR5Xx/eib8O1FstXBVHYU8D4vso/r03Wclkz0WRrc1EGj8bZPZJEPoy+uovUmiVdnLzJhlCQbn2j/gweM2jNJtjvAy4S78OPKzNnTi0z0HSRvByxTWYt5ffdAdr1Ja1XtJPEq61V554BLdo0HmiGqsrm7/Pz1E0hqUl6LmcbT/bmFbpI9r/HM1X0D6emCqOpRZ6Fv7WNfkExgpkp12rPUSTLMfkay50+2x1xnH5IGcTwLz9Krcrs6m7vAZG9Ldpec5GaBfU6nu0MPxniVfDPdhMf3MRN9THVXaXDaPunrBziGHXPLCQS+nzRLTEmK7Qiisk57Cp1pKUUkKW7TKtf5RJIqhFXSWWVzId+v27K7xCTDcLzA46RqOZQW1hvZ3inpUmWiq1T3MQ1OS7LObumw61upSrEanZWYkhQiQFLnaU84/cEESetnKPskSied1YvQi1uzu/Sj6/Lj2HI1zIK6wej0fnw4jv7ehRsikmquU/rnJK/YmpFMceCM4DLtif/0xjrX+WySVdJZv1h6i7bsLj1JdcOHahn0W7Dzzm74y4+p8CoNTkxypo6T2/kVSf8ekngGks3qtGcmUqjuHUhFllS5zl4ke894Tkln9WIvh7O27C49yfiU7l7I9naxLFx7u/r9fHEkWaXBuxz0nPGs1Fxnnh3Djrll7Kjb+VmJGclyIg+qeEaj056Y2UxHmPWMygCTnELnOnuRNIjjUceMr87t/qHO4D5hHLdldylJYrveGM8ndcvpQrcX7wEzaPg+fhfh+FCluqs0OHGfFMlEBjcTx7Cr3DKMAG+/aZSYkbyS4QUf/n8hFCTbwg5XJddVDTfT7D7JWt3ftcMkB0Fy2/0/RoZ8H89QSPJ9PK6QJA3YjaqYJJOkMMYk6WLPJJlkP2M84+kZsN6x5z5p0QGTZJItVTFJJklhjEnSxR7SgOxrf4P+M57f/kWl3+4k+XQHt4JCGfsBfA86y0hM0hUxSVfEJF3R+/+u1tD1qj3nPumKmKQrYpKuiEm6Ip7xuLLn3CddEZN0RUzSFTFJV8QzHlf23J0+edcPNTgkd0je+UMNzsg1kr1+qGEAv6Pdb+9dUd8falDfZmLbNOXev0SvOO73/aGG6tsZHNhztfcvaudV+9Lnhxqc2nmndqbvDzU4tfNO7UzfH2pwaucd2pn+P9Rg8J++BySXZjzvKZ7xsPqJSboiJumKmKQrehXJGFfpd1zFL4rw/wH5qBCmJZkRswAAADx0RVh0Y29tbWVudAAgSW1hZ2UgZ2VuZXJhdGVkIGJ5IEdOVSBHaG9zdHNjcmlwdCAoZGV2aWNlPXBubXJhdykK+osW8wAAAABJRU5ErkJggg=="/>
  </div>
 </div>
<p>
  The part of the diagram inside the dotted box is your formatting
software, or
  <em>toolchain</em>. Besides the obvious and
visible input to the formatter (the document source) you'll need to
keep the two hidden inputs of the formatter (DTD and stylesheet) in
mind to understand what follows.
</p>
<h4 id="id3006182"><a href="#id3006182">§</a>Other DTDs</h4>
<p>
  A brief digression into other DTDs may help clarify what parts of
the previous section are specific to DocBook and what parts are general to
all structural-markup languages.
</p>
<p>
  <a href="http://www.tei-c.org/">
   TEI</a>
  (Text Encoding
Initiative) is a large, elaborate DTD used primarily in academia for
computer transcription of literary texts.  TEI's Unix-based toolchains
use many of the same tools that are involved with DocBook, but with
different stylesheets and (of course) a different DTD.
</p>
<p>
  XHTML, the latest version of HTML, is also an XML application
described by a DTD, which explains the family resemblance between
XHTML and DocBook tags. The XHTML toolchain consists of Web browsers
that can format HTML as flat ASCII, together with any of a number of
ad-hoc HTML-to-print utilities.
</p>
<p>
  Many other XML DTDs are maintained to help people exchange
structured information in fields as diverse as bioinformatics and
banking.  You can look at a
  <a href="http://www.xml.com/pub/rg/DTD_Repositories">
   list of
repositories</a>
  to get some idea of the variety available.
</p>
<h4 id="db_toolchain"><a href="#db_toolchain">§</a>The DocBook Toolchain</h4>
<p>
  Normally, what you'll do to make XHTML from your DocBook sources
is use the
xmlto(1)
front end.  Your commands will look like this:
</p>
 <pre class="screen">
bash$ xmlto xhtml foo.xml
bash$ ls *.html
ar01s02.html ar01s03.html ar01s04.html index.html
</pre>
<p>
  In this example, you converted an XML-DocBook  document named
  <code>foo.xml</code> with three top-level sections into an
index page and two parts.  Making one big page is just as easy:
</p>
 <pre class="screen">
bash$ xmlto xhtml-nochunks foo.xml
bash$ ls *.html
foo.html
</pre>
<p>
  Finally, here is how you make PostScript for printing:
</p>
 <pre class="screen">
bash$ xmlto ps foo.xml       # To make PostScript
bash$ ls *.ps
foo.ps
</pre>
<p>
  To turn your documents into HTML or PostScript, you need an engine that can apply the combination of DocBook DTD and a
  suitable stylesheet to your document. Figure 18.2 illustrates how the open-source tools for doing this fit together.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 18.2. Present-day XML-DocBook toolchain.
   </b>
  </p>
  <div class="center">
   <img alt="Present-day XML-DocBook toolchain." src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlAAAAD7CAAAAACAzfWdAAAAAnRSTlMA/1uRIrUAAAACYktHRAD/h4/MvwAAAAlwSFlzAAAAZAAAAGQAD5bF3QAADGhJREFUeNrtnb1u69gVRneRIggQw0SQajyNqtwUKaLiurppiCBlEEDAVAMXA2KAgQNMMyxufQHVUxhglWKmUueahV+Ar8BX4Csw/BH1S0qH5Kehba0F2JIo6pB7c/HwiNqULM/zKJQR5XDdWPEX6poTNgVvEoQCKQgFUhAKpCAUSEEokIJQIAWhQApCgRSEAikIBVIQCqQgFEhBKJCCUCAFoUAKQoEUhAIpI4WKDx4j1LVzIFS2NM+8xepwNt+q6cnB5JUdTECoa+eohyonJN7ycL6smJ6Es7aX74JQ106rUHk0b50x89qm7oJQ1067UFV/NLN5cYgLPZuv6ulxsNpMXt9YHvvxzusR6tppF6r8P8/ywM/DwqFVOfS2MJwHSTO5ubEszHZfjVDXTncPZdWNtzt9OWsmb25mwV5zCHXtdI+hrHpg8e50ayZvbhJv72JhhLp2WoWKveJAF6R5vMgDL86TaD09mjWTmxvLV97uuQSEunYOhEpCs+IwVjqS+eZneRaYF9bTvXl5HqqevL5ZWZSat3PWCqGuHT56ASkIBVIQCqQgFEhBKJCCUCAFoUAKQoEUhAIpCAVSEAqkIBRIQSiQglAgBaFACkKBFIQCKQgFUhAKpCAUSEEokFIKFTj9WOe9y0zB6BWCt405z0nnAw4gFEhBKJCCUCAFoUAKQoEUhAIpCAVSEAqkIBRIQSiQglAgBaFACkKBFIQCKQgFUhAKpCAUSEEokIJQIAWhQApCgRSEAikIBVIQCqQgFEhBKJCCUCAFoUAKQoEUhAIpCAVSEAqkIBRIQSiQglAgBaFACkKBFIQCKY5CfXd//9X9j1OvLLx+HIX6ZAWfpl5ZeP04CvWlFOrL1CsLrx9HodJbs9t06pWF14/roPzObDb1usIbwFWoOUMocMFVqJ8YQoELrkIlt79nCAXncT6xeXc79arCW8BZqPnXU68qvAVahEqi8PuWH/T82/G077+JkvGrkDr9oKgbgsNye/htEH5L+HbY2sIPV87rla5CfxGOTGscj0+DpinCHx/+rlDpXmvr+VZtSz5qd8yu8VoymvZJJuF3hL8j1MrfFSUpnvGKiW3HxKNpid/m3W+RBl1T++H3gvC3DzZuZIuD+hQ7mOHgqYPFh4tsijTImjoKvx+E39xtfDkWtHgmy46FSupp8fJw+uC99DVkdMT+Sfh74a99CY8FtTwqn7TQvFXue36+KA6VgWdh9SLPjrqucKDkryCjQ1ed8I/aqLWIF8dzWP2kZXk4KzorL4yrR+mq7qFa1mExLJ7pM9oWfn8Iv6QSKpu3jAAaoYqny9toVs4TelHeKVRrMxdLg66pgetN+G3NVEKFbcf/rVDlu7089CuFll7QKVS+GtR1Tp7RcMR7NMI/CL/0pVWOHaFWhUOrOLViddPqnEEplN+mdTgkoqkzGssuvyD8+ojW6kZsy19smeYLs+I9YezF8cyKgbnNo/KpNJ/b8vhF7U1dIg26pgats7Cpdxa+DdyvukIaoPvEGSV8afiFUL6uxUGNTZxRwpeGb3kaKJsM+n8cNG1GCV8bvuWr5fiGtiz7v2WYNqOErw3f8lBQ07Ml6T+KmDajhK8N37QH0SHH5GkzSvja8C2XnHff0r+5aTNK+NrwLXXupN06x/5lqC5piDynzwf6Z9Q9fDcuEn4WyZrqFb7rcnfDt/hf7U/5ZsXx1feWzYZM3K5niL7puxIOaUgtnbv43D+j2/CzpZnN2hLsHWWmonVZlwg/i7ap98Y11R3+mOXuhm+d3/sUe7Ns70yd4wUyvXd5hzQ4yjxoVLobYCGV2yu6zwdfInzX1I8Lf/hyd9vrFqqsWNk7S7Ft/WS37prRzSFsioxuj58He8zOgspSwupflh291vba+A3Dz04d+ceFf3a5m82edK/EKaHyldWVneHc5nXr9b2VRZ51nhBzzGj8p7/8+3+ZWxr86gCTzOzccc81o9uFHwi19Jogq1LC6l/R8fvlB5dFMhZmXrrJdPWoKT28WPjLmXmbNYhO7lnjwj+33MgCr6xeqossOzgpVD7zqqUGm513e6/7IOSa0XIY8ucyMNddtBiWB2fe5TpndLPwPaE8m6+aIKtSwk09YbHgrFSrYFOksX60Lj28VPhhVA4hmzXINUK1hn92uZYVljVFll0vOyVUGHnVu8osippSu8297sju3S4T/GY9tLXf/eG/51OwW+p3KlPf9F34H/+5v5BNuFUp4aaesHhXEKV5EO3O2jyqSw8vFb6X767BGaFGhX92ueu/OikDhFqFZaFK0WTRNdRtbe+diKzPLmq3s09ffnHsoU4udd1on120Wnh69K6jCbIqJWzqCfOgrJkOypk3dYnNo3Xp4YXCtzjfWQNhD3UU/tnlNrWWVVI6OCFUUr4qKIYM4SzL6va29xRCVQE5pCFeX3sTpGern90z2iw8PxJqHWRVSripJ8zjWVSeDYvzursvev/m0br08DLhx9liHtcdc7UGKqHawt+nZblF0KtFU2TZQbdQcfEerzh62jxOPC/05mnRWz0396J0aV0r75jR9Eszkj2XBm+ZLK0qBLRzxWCuGd0ufLu6SVhfyLMOtyol3NYT1p9RhOaF61nj9aOm9PAy4XvLrBj6h7PyI9xyGfW6XCL8Q1qWa0WcaV4npYvTg/JBXOREzOWaInxnXM7dhJY8yeKp6N/epBklfHcchEqebEDBxUn610NMm1HCd2VldnbuMKF8hfCl4VO+QvjS8G1AwcUpBpSDTDwqJXxp+JZH3efRByxs1buEZuKMRqLrZgm/Dt86x2VLz2zeew0H1ChPm1HtqJzwu6/LK0+yx72vieDCtCsP3zqvJas+sGlfw+5D4ZDLvCbO6IBL6Qi/O/yyEqVd0sj8cv3q6qB11U9dknSiHmrIN6FNnNFEuI8SfnX2M2w/sK1mFmZNCVRd9bMuSeqsh1oOOSJP/fUjoexaR8Jfn07v+lrkoKwfq0ug6qqfdUlSV7VBOsj2qTOaj/pWaMLfD7/+gL0lE3G5mNCa6qC66mdtUpdQw776c/KMqnp9ws83NUDH3V5cnjJI/KYEqq76WZckdQg1qMd/BRkV9fqEX7L2YnG0c2VzzyzImmKouuqnLknqqIdKBp7Gnz6jLeH3h/ArmjrqcV98XjL4u99fQUYJXxb+5sg18rvPR/w6xSvIKOHLwt+5lG+MpiN+muJ1ZJTwReHvjq2XQ3ezld//M1FJGqRNEb4i/L03a2no+0G/n39LosD3x9VAvJaMEr4i/KN3/9Wv6j20XB3YcgXjwz+G/cbaQRqCXr9aeYpg9MbpDL+Fawrfeeu7f7+G+vIQeEs4b32EAhcQCqQgFEhBKJCCUCAFoUAKQoEUhAIpCAVSEAqkIBRIQSiQglAgBaFACkKBFIQCKQgFUhAKpCAUSEEokIJQIAWhQApCgRSEAikIBVIQCqQgFEhBKJCCUCAFoUAKQoEUhAIpCAVSEAqkIBRIQSiQglAgBaFAilqo7+7vv7r/ceqoYBr6bH1HoT5ZwaepA4Np6LP1HYX6Ujb5ZerAYBr6bH1HodJbs1vhD7LDW6LP1ncdlN+ZzaaOC6aix9Z3FWrOEOqK6bH1XYX6iSHUFdNj67sKldz+niHU1dJj6zuf2Ly7nToqmA73re8s1PzrqYOC6XDf+qVQP//gwN//6jLXz1NHDn0Rb/1SqB8SGT9MnR7oi3jrI9S1g1AgBaFACkKBFIQCKQgFUhAKpCAUSEEokIJQIAWhQApCgRSEAikIBVIQCqQgFEhBKJDyGwu1bJ36K0K9G5yFevlc/Pt88+FljFBP1uqTnWoS3hSuQr18Lrb6sz1/6OxNnHooa+2SEOr94H7Is1NdST+hnh6Lf88vB1MR6j1wRqjnfRfGC/VwYw/JjVlx9Hv8aB+rhwj1jjgt1Gf7z81NMXh6vLMbSz6a2dNIoV7Kbu7poZbzed3rIdT74UwPVQjweJc8fK43vqCHqv4aoZo/hHo/nBOq+rtJEtUhD6HeOQ5C3STVgW68UE8vjVAfXxDqnXJKqFKAl2TpJ/6Hp+RlvFA3j8VI/HlZ6PnBirv2tDR7Wdqv5VSEeiecEurmMbE7+/icvPhmD3ePvz7aKaP46AWcDnl9tj5CXTsIBVJOb/1ikPOAUNADyldACkKBFIQCKQgFUhAKpCAUSEEokIJQIAWhQApCgRSEAikIBVIQCqQgFEhBKJCCUCAFoUDKBYT6NpDx7dTpgb6It/7/AVtrtWDHh2g2AAAAPHRFWHRjb21tZW50ACBJbWFnZSBnZW5lcmF0ZWQgYnkgR05VIEdob3N0c2NyaXB0IChkZXZpY2U9cG5tcmF3KQr6ixbzAAAAAElFTkSuQmCC"/>
  </div>
 </div>
<p>
  Parsing your document and applying the stylesheet transformation
will be handled by one of three programs.  The most likely one is
  <em>xsltproc</em>,
the parser that ships with Red Hat Linux.  The other possibilities are two
Java
  programs,
  <em>Saxon</em> and
  <em>Xalan</em>.
</p>
<p>
  It is relatively easy to generate high-quality XHTML from either
DocBook; the fact that XHTML is simply another XML DTD helps a lot.
Translation to HTML is done by applying a rather simple stylesheet,
and that's the end of the story.  RTF is also simple to generate in
this way, and from XHTML or RTF it's easy to generate a flat ASCII
text approximation in a pinch.
</p>
<p>
  The awkward case is print.  Generating high-quality printed
output — which means, in practice, Adobe's
PDF
  (Portable Document Format) — is difficult.  Doing it right requires
algorithmically duplicating the delicate judgments of a human
typesetter moving from content to presentation level.
</p>
<p>
  So, first, a stylesheet translates DocBook's structural markup
into another dialect of XML — FO
  (Formatting Objects).  FO
markup is very much presentation-level; you can think of it as a sort
of XML functional equivalent of
  <em>troff</em>.  It
has to be translated to PostScript for packaging in a PDF.
</p>
<p>
  In the toolchain shipped with Red Hat
Linux, this job
is handled by a
  <em>TeX</em> macro package called
  <em>PassiveTeX</em>. It
translates the formatting objects generated by
  <code>xsltproc</code> into Donald Knuth's <em>TeX</em> language. <em>TeX</em> 's output, known as
DVI (DeVice Independent) format, is then massaged into PDF.
</p>
<p>
  If you think this bucket chain of XML to
  <em>TeX</em> macros to DVI to
PDF sounds like an awkward kludge, you're right.  It clanks, it
wheezes, and it has ugly warts.  Fonts are a significant problem,
since XML and
  <em>TeX</em> and PDF have very
different models of how fonts work; also, handling
internationalization and localization is a nightmare. About the only
thing this code path has going for it is that it works.
</p>
<p>
  The elegant way will be
FOP, a direct
FO-to-PostScript translator being developed by the
Apache
  project.  With
FOP, the internationalization problem is, if not solved, at least well
confined; XML tools handle Unicode all the way through to FOP.  The
mapping from Unicode glyphs to Postscript font is also strictly FOP's
problem.  The only trouble with this approach is that it doesn't work
— yet.  As of mid-2003, FOP is in an unfinished alpha state
— usable, but with rough edges and missing features.
</p>
<p>
   Figure 18.3 illustrates what the FOP toolchain looks like.
</p>
 <div class="figure">
  <p class="title">
   <b>
    Figure 18.3. Future XML-DocBook toolchain with FOP.
   </b>
  </p>
  <div class="center">
   <img alt="Future XML-DocBook toolchain with FOP." src="data:image/png;base64,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"/>
  </div>
 </div>
<p>
  FOP has competition.  Another project called
  <em>xsl-fo-proc</em> aims to do the same
things as FOP, but in C++
  (and therefore both faster than
Java
  and not
relying on the Java environment).  As of mid-2003,
  <em>xsl-fo-proc</em> is in an unfinished alpha
state, not as far along as FOP.
</p>
<h4 id="id3006742"><a href="#id3006742">§</a>Migration Tools</h4>
<p>
  The second biggest problem with DocBook is the effort needed to
convert old-style presentation markup to DocBook markup.  Human beings
can usually parse the presentation of a document into logical
structure automatically, because (for example) they can tell from 
context when an italic font means ‘emphasis’ and when it means
something else such as ‘this is a foreign phrase’.
</p>
<p>
  Somehow, in converting documents to DocBook, those
sorts of distinctions need to be made explicit.  Sometimes
they're present in the old markup; often they are not, and the
missing  structural information has to be either deduced by 
clever heuristics or added by a human.
</p>
<p>
  Here is a summary of the state of conversion tools from
various other formats.  None of these do a completely perfect job;
inspection and perhaps a bit of hand-editing by a human being
will be needed after conversion.
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     GNU Texinfo
    </span>
   </dt>
   <dd>
    <p>
     The Free Software Foundation
     intends to support DocBook as an
interchange format.  Texinfo has enough structure to make reasonably
good automatic conversion possible (human editing is still needed
afterwards, but not much of it), and the 4.x versions of
     <em>makeinfo</em> feature a
     <code>--docbook</code> switch that generates DocBook.  More at the
     <a href="http://www.gnu.org/directory/texinfo.html">
      <em>makeinfo</em> project page</a>.
    </p>
   </dd>
   <dt>
    <span class="term">
     POD
    </span>
   </dt>
   <dd>
    <p>
     A
     <a href="http://www.cpan.org/modules/by-module/Pod/">
      POD::DocBook</a>
     module translates Plain Old Documentation markup to DocBook.  It
claims to translate every POD tag except the L&lt;&gt; italic tag.
The man page also says “Nested =over/=back lists are not supported
within DocBook”, but notes that the module has been heavily
tested.
    </p>
   </dd>
   <dt>
    <span class="term">
     <em>LaTeX</em> </span>
   </dt>
   <dd>
    <p>
     A project called
     <a href="http://www.lrz-muenchen.de/services/software/sonstiges/tex4ht/mn.html">
      TeX4ht</a>
     can, according to the author of Passive
     <em>TeX</em>, 
generate DocBook from
     <em>LaTeX</em>.
    </p>
   </dd>
   <dt>
    <span class="term">
     man pages and other
     <em>troff</em> -based markups
    </span>
   </dt>
   <dd>
    <p>
     These are generally considered the biggest and nastiest conversion
problems.  And indeed, the basic
troff(1) markup is at too low a presentation
level for automatic conversion tools to do much of any good.  However,
the gloom in the picture lightens significantly if we consider
translation from sources of documents written in macro packages like
man(7).  These have enough structural
features for automatic translation to get some traction.
    </p>
    <p>
     I wrote a tool to do troff-to-DocBook
myself, because I couldn't find anything else that did a tolerable
job of it.  It's called
     <a href="http://www.catb.org/~esr/doclifter/">
      doclifter</a>.  It
will translate to either SGML or XML DocBook from
man(7),
mdoc(7),
ms(7), or
me(7) macros.  See the documentation
for details.
    </p>
   </dd>
  </dl>
 </div>
<h4 id="id3007022"><a href="#id3007022">§</a>Editing Tools</h4>
<p>
  One thing we do not have in mid-2003 is a good
open-source structure editor for SGML/XML documents.
</p>
<p>
  <a href="http://www.lyx.org/">
   LyX</a>
  is a GUI word processor
that uses
  <em>LaTeX</em> for printing and supports structural editing of
  <em>LaTeX</em> markup.  There is a
  <em>LaTeX</em> package that generates DocBook, and a
  <a href="http://bgu.chez.tiscali.fr/doc/db4lyx/">
   how-to document</a>
  describing how to write SGML and XML in the LyX GUI.
</p>
<p>
  <a href="http://www.math.u-psud.fr/~anh/TeXmacs/TeXmacs.html">
   GNU
   <em>TeX</em> Macs</a>
  is a project aimed at producing an editor that is good
for technical and mathematical material, including displayed formulas.
1.0 was released in April 2002.  The developers plan XML support in
the future, but it's not there yet.
</p>
<p>
  Most people still hack DocBook tags by hand using either
  <em>vi</em> or
  <em>emacs</em>.
</p>
<h4 id="id3007143"><a href="#id3007143">§</a>Related Standards and Practices</h4>
<p>
  The tools are coming together, if slowly, to edit and format
DocBook markup. But DocBook itself is a means, not an end.  We'll need
other standards besides DocBook itself to accomplish the
searchable-documentation-database objective. There are two big issues:
document cataloging and metadata.
</p>
<p>
  The
  <a href="http://scrollkeeper.sourceforge.net/">
   ScrollKeeper</a>
  project aims directly to meet this need. It provides a simple set of
script hooks that can be used by package install and uninstall
productions to register and unregister their documentation.
</p>
<p>
  ScrollKeeper uses the
  <a href="http://www.ibiblio.org/osrt/omf/">
   Open Metadata Format</a>.
This is a standard for indexing open-source documentation analogous to
a library card-catalog system.  The idea is to support rich search
facilities that use the card-catalog metadata as well as the source 
text of the documentation itself.
</p>
<h4 id="id3007192"><a href="#id3007192">§</a>SGML</h4>
<p>
  In previous sections, we have deliberately omitted a lot of
DocBook's history.  XML has an older brother,
Standard Generalized Markup Language (SGML).
</p>
<p>
  Until mid-2002, no discussion of DocBook would have been
complete without a long excursion into SGML, the differences between
SGML and XML, and detailed descriptions of the SGML DocBook toolchain.
Life can be simpler now; an XML DocBook toolchain is available in open
source, works as well as the SGML toolchain ever did, and is easier to
use.
</p>
<h4 id="id3007297"><a href="#id3007297">§</a>XML-DocBook References</h4>
<p>
  One of the things that makes learning DocBook difficult is that
the sites related to it tend to overwhelm the newbie with long lists
of W3C standards, massive exercises in SGML theology, and dense
thickets of abstract terminology.  See
  <em>XML in a Nutshell</em><sup><a href="#Harold-Means" title="[Harold-Means]">[Harold-Means]</a></sup> for a good
book-length general introduction.
</p>
<p>
  Norman Walsh's
  <em>DocBook: The Definitive Guide</em>
  is available
  <a href="http://www.oreilly.com/catalog/docbook/">
   in print</a>
  and
  <a href="http://www.docbook.org/tdg/en/html/docbook.html">
   on the
Web</a>.  This is indeed the definitive reference, but as an
introduction or tutorial it's a disaster.  Instead, read this:
</p>
<p>
  <a href="http://xml.web.cern.ch/XML/goossens/dbatcern/">
   Writing
Documents Using DocBook</a>.  This is an
excellent tutorial.
</p>
<p>
  There is an equally excellent
  <a href="http://www.dpawson.co.uk/docbook/">
   DocBook FAQ</a>
  with a lot
of material on styling HTML output.  There is also a DocBook
  <a href="http://docbook.org/wiki/moin.cgi">
   wiki</a>.
</p>
<p>
  Finally, the
  <a href="http://xml.coverpages.org/">
   The XML
Cover Pages</a>
  will take you into the jungle of XML standards
if you really want to go there.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id3006067" id="ftn.id3006067">[152]</a></sup>
  In XML-speak, what we
have been calling a ‘dialect’ is called an
‘application’; we've avoided that usage, since it collides
with another more common sense of the word.
</p>
</div>


<!-- FILE: ch18s06.html -->
<h3 id="ch18s06"><a href="#ch18s06">§</a>Best Practices for Writing Unix Documentation</h3>
<p>
  The advice we gave earlier in the chapter about reading Unix
documentation can be turned around.  When you write documentation for
people within the Unix culture,
  <em>
   don't dumb it
down
</em>.  If you write as if for idiots, you will be
written off as an idiot yourself.  Dumbing documentation down
is very different from making it accessible; the former is
lazy and omits important things, whereas the latter requires
careful thought and ruthless editing.
</p>
<p>
  Don't think for a moment that volume will be mistaken for
quality.  And especially, never
  <em>ever</em>
  omit
functional details because you fear they might be confusing, nor
warnings about problems because you don't want to look bad.  It is
  <em>unanticipated</em>
  problems that will cost you
credibility and users, not the problems you were honest about.
</p>
<p>
  Try to hit a happy medium in information density. Too low
is as bad as too high.  Use screen shots sparingly; they tend
to convey little information beyond the style and feel of the
interface.  They are never a good substitute for clear textual
description.
</p>
<p>
  If your project is of any significant size, you should probably
be shipping three different kinds of documentation: man pages as
reference material, a tutorial manual, and a FAQ (Frequently Asked
Questions) list.  You should have a website as well, to serve as a
central point of distribution (see the guidelines on communication 
in
  <a href="#opensourcechapter" title="Chapter 19. Open Source">
   Chapter 19</a>).
</p>
<p>
  Huge man pages are viewed with some disfavor; navigation within
them can be difficult. If yours are getting large, consider writing a
reference manual, with the man page(s) giving a quick summary,
pointers into the reference manual, and details of how the program(s)
are invoked.
</p>
<p>
  In your source code, include the standard metainformation files
described in the
  <a href="#opensourcechapter" title="Chapter 19. Open Source">
   Chapter 19</a>
  section on open-source release
practices, such as
  <code>README</code>.  Even if your code is
going to be proprietary, these are Unix conventions and future
maintainers coming from a Unix background will come up to speed faster
if the conventions are followed.
</p>
<p>
  Your man pages should be command references in the traditional
Unix style for the traditional Unix audience.  The tutorial manual
should be long-form documentation for nontechnical users.  And the
FAQ should be an evolving resource that grows as your software support
group learns what the frequent questions are and how to answer
them.
</p>
<p>
  There are more specific habits you should adopt if
you want to get a little ahead of mid-2003's practice:
</p>
 <div class="orderedlist">
  <ol type="1">
   <li>
    <p>
     Maintain your document masters in XML-DocBook.  Even your man pages
can be DocBook
     <code class="sgmltag-element">
      RefEntry
     </code>
     documents.  There is a very good
     <a href="http://www.tldp.org/HOWTO/mini/Man-Page.html">
      HOWTO</a>
     on writing manual pages
that explains the sections and organization your users will expect to
see.
    </p>
   </li>
   <li>
    <p>
     Ship the XML masters.  Also, in case your users' systems don't
have
xmlto(1)
ship the
     <em>troff</em> sources that you get by running
     <code>xmlto man</code>
     on your masters. Your software distribution's
installation procedure should install those in the normal way, but
direct people to the XML files if they want to write or edit
documentation.
    </p>
   </li>
   <li>
    <p>
     Make your project's installation package ScrollKeeper-ready.
    </p>
   </li>
   <li>
    <p>
     Generate XHTML from your masters (with <code>xmlto xhtml</code>)
     and make it available from your project's Web page.
    </p>
   </li>
  </ol>
 </div>
<p>
  Whether or not you're using XML-DocBook as a master format,
you'll want to find a way to convert your documentation to HTML.
Whether your software is open-source or proprietary, users are
increasingly likely to find it via the Web.  Putting your
documentation on-line has the direct effect of making it easier for
potential users and customers who know your software exists to read it
and learn about it.  It has the indirect effect that your software
will become more likely to turn up in a Web search.
</p>



<!-- FILE: opensourcechapter.html -->
<h3 id="opensourcechapter"><a href="#opensourcechapter">§</a>Chapter 19. Open Source</h3>
 <blockquote class="epigraph">
  <p>
   Software is like sex — it's better when it's free.
  </p>
  <span>
   – Linus Torvalds
  </span>
 </blockquote>
<p>
  We concluded
  <a href="#historychapter" title="Chapter 2. History">
   Chapter 2</a>
  by observing the largest-scale pattern in
Unix's history; it flourished when its practices most closely
approximated open source, and stagnated when they did not.  We then
asserted in
  <a href="#reusechapter" title="Chapter 16. Reuse">
   Chapter 16</a>
  that
open-source development tools tend to be of high quality.  We'll begin
this chapter by sketching an explanation of how and why open-source
development works.  Most of its behaviors are simply intensifications
of long-established Unix-tradition practices.
</p>
<p>
  We'll then descend from realm of abstraction and describe some
of the most important folk customs that Unix has picked up from the
open-source community — in particular, the community-evolved
guidelines for what a good source-code release looks like.  Many of
these customs could be profitably adopted by developers on other modern
operating systems as well.
</p>
<p>
  We'll describe these customs on the assumption that you are
developing open source; most are still good ideas even if you are
writing proprietary software.  The open-source assumption is also
historically appropriate, because many of these customs found their
way back into proprietary Unix shops via ubiquitous open-source tools
like
patch(1),
  <em>Emacs</em>, and GCC.
</p>



<!-- FILE: ch19s01.html -->
<h3 id="ch19s01"><a href="#ch19s01">§</a>Unix and Open Source</h3>
<p>
  Open-source development exploits the fact that characterizing
and fixing bugs — unlike, say, implementing a particular
algorithm — is a task that lends itself well to being split into
multiple parallel subtasks.  Exploration of the neighborhood of
possibilities near a prototype design also parallelizes well.  With
the right technological and social machinery in place, development
teams that are loosely networked and very large can do astoundingly
good work.
</p>
<p>
  Astoundingly, that is, if you are carrying around the mental
habits developed by people who treat process secrecy and proprietary
control as a given. From
  <em>The Mythical Man-Month</em> <sup><a href="#Brooks" title="[Brooks]">[Brooks]</a></sup> until the rise of
Linux,
the orthodoxy in software engineering was all about small, closely
managed teams within heavyweight organizations like corporations and
government. The practice was of
  <em>large</em>
  teams
closely managed.
</p>
<p>
  The early Unix community, before the
AT&amp;T
  divestiture, was a paradigmatic
example of open source in action.  While the pre-divestiture Unix code
was technically and legally proprietary, it was treated as a commons
within its user/developer community.  Volunteer efforts were
self-directed by the people most strongly motivated to solve problems.
From these choices many good things flowed.  Indeed, the technique of
open-source development evolved as an unconscious folk practice in the
Unix community for more than a quarter century, many years before it was
analyzed and labeled in the late 1990s (See
  <em>The Cathedral and the Bazaar</em><sup><a href="#Raymond01" title="[Raymond01]">[Raymond01]</a></sup> and
  <em>Understanding Open Source Software Development</em><sup><a href="#Feller-Fitzgerald" title="[Feller-Fitzgerald]">[Feller-Fitzgerald]</a></sup>.
</p>
<p>
  In retrospect, it is rather startling how oblivious we all were
to the implications of our own behavior. Several people came very
close to understanding the phenomenon; Richard Gabriel in his
“Worse Is Better”
  paper from 1990 <sup><a href="#Gabriel" title="[Gabriel]">[Gabriel]</a></sup>
is the best known, but one can find prefigurations in Brooks <sup><a href="#Brooks" title="[Brooks]">[Brooks]</a></sup> (1975) and as far back as Vyssotsky and
Corbató's meditations on the Multics design (1965). I failed to
get it over more than twenty years of observing software development,
before being awakened by Linux in the mid-1990s.  This experience
should make any thoughtful and humble person wonder what other
important unifying concepts are still implicit in our behavior and
lurking right under our collective noses, hidden not by their
complexity but by their very simplicity.
</p>
<p>
  The rules of open-source development are simple:
</p>
 <div class="orderedlist">
  <ol type="1">
   <li>
    <p>
     <em>Let the source be open.</em>
     Have no secrets.  Make the code and the process that produces it
public. Encourage third-party peer review.  Make sure that others 
can modify and redistribute the code freely.  Grow the co-developer
community as big as you can.
    </p>
   </li>
   <li>
    <p>
     <em>Release early, release often.</em>
     A rapid
release tempo means quick and effective feedback.  When each
incremental release is small, changing course in response to
real-world feedback is easier.
    </p>
    <p>
     Just make sure your first release builds, runs, and demonstrates
promise.  Usually, an initial version of an open-source program
demonstrates promise by doing at least some portion of its final job,
sufficient to show that the initiator can actually continue the
project.  For example, an initial version of a word processor might
support typing in text and displaying it on the screen.
    </p>
    <p>
     A first release that cannot be compiled or run can kill a
project (as, famously, almost happened to the Mozilla browser).
Releases that cannot compile suggest that the project developers will
be unable to complete the project, Also, non-working programs are
difficult for other developers to contribute to, because they cannot
easily determine if any change they made improved the program or not.
    </p>
   </li>
   <li>
    <p>
     <em>Reward contribution with praise.</em>
     If you can't give your co-developers material rewards, 
give psychological ones.  Even if you can, remember that people will
often work harder for reputation than they would for gold.
    </p>
   </li>
  </ol>
 </div>
 <blockquote>
  <p>
   A corollary of rule 2 is that individual releases should not be
momentous events, with many promises attached and much preparation.
It's important to ruthlessly streamline your release process, so that
you
   <em>can</em>
   do frequent releases painlessly.  A setup
where all other work must stop during release preparation is a
terrible mistake.  (Notably, if you're using CVS or something similar,
releases in preparation should be branches off the main line of
development, so that they don't block main-line progress.)  To sum up,
don't treat releases as big special events; make them part of normal
routine.
  </p>
  <span>
   – Henry Spencer
  </span>
 </blockquote>
<p>
  Remember that the reason for frequent releases is to shorten and
speed the feedback loop connecting your user population to your
developers.  Therefore, resist thinking of the next release as a
polished jewel that cannot ship until everything is perfect.  Don't
make long wish lists.  Make progress incrementally, admit and advertise
current bugs, and have confidence that perfection will come with
time.  Accept that you will go through dozens of point releases on the
way, and don't get upset as the version numbers mount.
</p>
<p>
  Open-source development uses large teams of programmers
distributed over the Internet and communicating primarily through
email and Web documents.  Typically, most contributors to any given
project are volunteers contributing in order to be rewarded by the
increased usefulness of the software to them, and by reputation
incentives.  A central individual or core group steers the project;
other contributors may drop in and drop out sporadically.  To
encourage casual contributors, it is important to avoid erecting
social barriers between them and the core team.  Minimize the core
team's privileged status, and work hard to keep the boundaries
inconspicuous.
</p>
<p>
  Open-source projects follow the Unix-tradition advice of
automating wherever possible.  They use the
patch(1)
tool to pass around incremental changes.  Many projects (and all large
ones) have network-accessible code repositories using version-control
systems like CVS (recall the discussion in
  <a href="#toolschapter" title="Chapter 15. Tools">
   Chapter 15</a>). Use of automated bug- and patch-tracking
systems is also common.
</p>
<p>
  In 1997, almost nobody outside the hacker culture understood
that it was even possible to run a large project this way, let alone
get high-quality results.  In 2003 this is no longer news;
projects like Linux,
Apache, and Mozilla
have achieved both success and high public visibility.
</p>
<p>
  Abandoning the habit of secrecy in favor of process
transparency
  and peer review was
the crucial step by which alchemy became chemistry.  In the same way,
it is beginning to appear that open-source development may signal the
long-awaited maturation of software development as a
discipline.
</p>



<!-- FILE: ch19s02.html -->
<h3 id="ch19s02"><a href="#ch19s02">§</a>Best Practices for Working with Open-Source Developers</h3>
<p>
  Much of what constitutes best practice in the open-source
community is a natural adaptation to distributed development; you'll
read a lot in the rest of this chapter about behaviors that maintain
good communication with other developers.  Where Unix conventions are
arbitrary (such as the standard names of files that convey
metainformation about a source distribution) they often trace back
either to Usenet
  in
the early 1980s, or to the conventions and standards of the GNU
project.
</p>
<h4 id="patching"><a href="#patching">§</a>Good Patching Practice</h4>
<p>
  Most people become involved in open-source software by writing patches
for other people's software before releasing projects of their own.
Suppose you've written a set of source-code changes for someone else's
baseline code. Now put yourself in that person's shoes. How is he
to judge whether to include the patch?
</p>
<p>
  It is very difficult to judge the quality of code, so
developers tend to evaluate patches by the quality of the submission.
They look for clues in the submitter's style and communications
behavior instead — indications that the person has been in their
shoes and understands what it's like to have to evaluate and merge an
incoming patch.
</p>
<p>
  This is actually a rather reliable proxy for code quality.  In
many years of dealing with patches from many hundreds of strangers,
I have only seldom seen a patch that was thoughtfully
presented and respectful of my time but technically bogus.  On the
other hand, experience teaches that patches which look careless or
are packaged in a lazy and inconsiderate way are very likely to
actually
  <em>be</em>
  bogus.
</p>
<p>
  Here are some tips on how to get your patch accepted:
</p>
<h5 id="id3007894"><a href="#id3007894">§</a>Do send patches, don't send whole archives or files.</h5>
<p>
  If your change includes a new file that doesn't exist in the code,
then of course you have to send the whole file.  But if you're modifying
an already-existing file, don't send the whole file.  Send a diff instead;
specifically, send the output of the 
diff(1)
command run to compare the baseline distributed version against your
modified version.
</p>
<p>
  The
diff(1)
command and its dual,
patch(1),
are the most basic tools of open-source development.  Diffs are better
than whole files because the developer you're sending a patch to may
have changed the baseline version since you got your copy.  By sending
him a diff you save him the effort of separating your changes from
his; you show respect for his time.
</p>
<h5 id="id3007953"><a href="#id3007953">§</a>Send patches against the current version of the code.</h5>
<p>
  It is both counterproductive and rude to send a maintainer
patches against the code as it existed several releases ago, and expect
him to do all the work of determining which changes duplicate things he
has since done, versus which things are actually novel in your patch.
</p>
<p>
  As a patch submitter, it is
  <em>your</em>
  responsibility
to track the state of the source and send the maintainer a minimal patch
that expresses what you want done to the main-line codebase. That means
sending a patch against the current version.
</p>
<h5 id="id3007988"><a href="#id3007988">§</a>Don't include patches for generated files.</h5>
<p>
  Before you send your patch, walk through it and delete any patch
bands for files in it that are going to be automatically regenerated
once the maintainer applies the patch and remakes.  The classic
examples of this error are C
  files
generated by
  <em>Bison</em> or
  <em>Flex</em>.
</p>
<p>
  These days the most common mistake of this kind is sending a
diff with a huge band that is nothing but changebars between your
  <code>configure</code> script and the maintainer's.  This file is generated by <code>autoconf</code>.
</p>
<p>
  This is inconsiderate.  It means your recipient is put to the trouble
of separating the real content of the patch from a lot of bulky noise.
It's a minor error, not as important as some of the things we'll get
to further on — but it will count against you.
</p>
<h5 id="id3008059"><a href="#id3008059">§</a>Don't send patch bands that just tweak RCS or SCCS $-symbols.</h5>
<p>
  Some people put special tokens in their source files that are
expanded by the version-control system when the file is checked in:
the $Id$ construct used by RCS and CVS,
for example.
</p>
<p>
  If you're using a local version-control system yourself, your
changes may alter these tokens.  This isn't really harmful, because
when your recipient checks his code back in after applying your patch
the tokens will be re-expanded in accordance with the
  <em>maintainer's</em>
  version-control status.  But those
extra patch bands are noise.  They're distracting.  It's more
considerate not to send them.
</p>
<p>
  This is another minor error.  You'll be forgiven for it if you
get the big things right.  But you want to avoid it anyway.
</p>
<h5 id="id3008100"><a href="#id3008100">§</a>Do use -c or -u format, don't use the default (-e) format.</h5>
<p>
  The default (
  <code>-e</code>) format of
diff(1)
is very brittle.  It doesn't include any context, so the patch tool
can't cope if any lines have been inserted or deleted in the baseline 
code since you took the copy you modified.
</p>
<p>
  Getting an
  <code>-e</code> diff is annoying, and suggests
that the sender is either an extreme newbie, careless, or clueless.
Most such patches get tossed out without a second thought.
</p>
<h5 id="id3008156"><a href="#id3008156">§</a>Do include documentation with your patch.</h5>
<p>
  This is very important.  If your patch makes a user-visible addition
or change to the software's features,
  <em>
   include changes to the
appropriate man pages and other documentation files in your patch
</em>.
Do
  <em>not</em>
  assume that the recipient will be happy to
document your code for you, or to have undocumented features lurking
in the code.
</p>
<p>
  Documenting your changes well demonstrates some good things.  First,
it's considerate to the person you are trying to persuade.  Second, it
shows that you understand the ramifications of your change well enough
to explain it to somebody who can't see the code.  Third, it demonstrates
that you care about the people who will ultimately use the software.
</p>
<p>
  Good documentation is usually the most visible sign of what separates
a solid contribution from a quick and dirty hack.  If you take the time
and care necessary to produce it, you'll find you're already 85% of the
way to having your patch accepted by most developers.
</p>
<h5 id="id3008201"><a href="#id3008201">§</a>Do include an explanation with your patch.</h5>
<p>
  Your patch should include cover notes explaining why you think the
patch is necessary or useful.  This is explanation directed not to the
users of the software but to the maintainer to whom you are sending the
patch.
</p>
<p>
  The note can be short — in fact, some of the most
effective cover notes I've ever seen just said “See the
documentation updates in this patch”.  But it should show the
right attitude.
</p>
<p>
  The right attitude is helpful, respectful of the maintainer's time,
quietly confident but unassuming.  It's good to display understanding of
the code you're patching.  It's good to show that you can identify with the
maintainer's problems. It's also good to be up front about any risks you
perceive in applying the patch.  Here are some examples of the sorts of
explanatory comments that experienced developers send:
</p>
<p>
  “I've seen two problems with this code, X and Y.  I fixed
problem X, but I didn't try addressing problem Y because I don't think
I understand the part of the code that I believe is
involved”.
</p>
<p>
  “Fixed a core dump that can happen when one of the foo
inputs is too long.  While I was at it, I went looking for similar
overflows elsewhere.  I found a possible one in blarg.c, near line
666.  Are you sure the sender can't generate more than 80 characters
per transmission?”
</p>
<p>
  “Have you considered using the Foonly algorithm for this
problem?  There is a good implementation at
&lt;http://www.example.com/~jsmith/foonly.html&gt;”.
</p>
<p>
  “This patch solves the immediate problem, but I realize it
complicates the memory allocation in an unpleasant way.  Works for me,
but you should probably test it under heavy load before
shipping”.
</p>
<p>
  “This may be featuritis, but I'm sending it anyway.
Maybe you'll know a cleaner way to implement the
feature”.
</p>
<h5 id="id3008290"><a href="#id3008290">§</a>Do include useful comments in your code.</h5>
<p>
  A maintainer will want to have strong confidence that he
understands your changes before merging them in.  This isn't an
invariable rule; if you have a track record of good work with the
maintainer, he may just run a casual eye over the changes before
checking them in semiautomatically.  But everything you can do to
help him understand your code and decrease his uncertainty increases
your chances that your patch will be accepted.
</p>
<p>
  Good comments in your code help the maintainer understand it.
Bad comments don't.
</p>
<p>
  Here's an example of a bad comment:
</p>
 <pre class="programlisting">
/* norman newbie fixed this 13 Aug 2001 */
</pre>
<p>
  This conveys no information.  It's nothing but a muddy
territorial bootprint you're planting in the middle of the
maintainer's code.  If he takes your patch (which you've made less
likely) he will almost certainly strip out this comment.  If you want
a credit, include a patch band for the project
  <code>NEWS</code> or
  <code>HISTORY</code> file.  He's
more likely to take that.
</p>
<p>
  Here's an example of a good comment:
</p>
 <pre class="programlisting">
/*
 * This conditional needs to be guarded so that crunch_data() never
 * gets passed a NULL pointer.  &lt;norman_newbie@foosite.com&gt;
 */
</pre>
<p>
  This comment shows that you understand not only the maintainer's
code but the kind of information that he needs to have confidence in
your changes.  This kind of comment
  <em>gives</em>
  him
confidence in your changes.
</p>
<h5 id="id3008383"><a href="#id3008383">§</a>Don't take it personally if your patch is rejected</h5>
<p>
  There are lots of reasons a patch can be rejected that don't
reflect on you.  Remember that most maintainers are under heavy time
pressure, and have to be conservative in what they accept lest the
project code get broken.  Sometime resubmitting with improvements
will help.  Sometimes it won't.  Life is hard.
</p>
<h4 id="naming"><a href="#naming">§</a>Good Project- and Archive-Naming Practice</h4>
<p>
  As the load on maintainers of archives like ibiblio, SourceForge,
and CPAN increases, there is an increasing trend for submissions
to be processed partly or wholly by programs (rather than entirely by
a human).
</p>
<p>
  This makes it more important for project and archive-file names
to fit regular patterns that computer programs can parse and
understand.
</p>
<h5 id="id3008426"><a href="#id3008426">§</a>Use GNU-style names with a stem and major.minor.patch numbering.</h5>
<p>
  It's helpful to everybody if your archive files all have GNU-like
names — all-lower-case alphanumeric stem prefix, followed by a hyphen,
followed by a version number, extension, and other suffixes.
</p>
<p>
  A good general form of name has these parts in order:
</p>
 <div class="orderedlist">
  <ol type="1">
   <li>
    <p>
     project prefix
    </p>
   </li>
   <li>
    <p>
     dash
    </p>
   </li>
   <li>
    <p>
     version number
    </p>
   </li>
   <li>
    <p>
     dot
    </p>
   </li>
   <li>
    <p>
     “src” or “bin” (optional)
    </p>
   </li>
   <li>
    <p>
     dot or dash (dot preferred)
    </p>
   </li>
   <li>
    <p>
     binary type and options (optional)
    </p>
   </li>
   <li>
    <p>
     archiving and compression extensions
    </p>
   </li>
  </ol>
 </div>
<p>
  Name stems in this style can contain hyphen or underscores to
separate syllables; dashes are actually preferred.  It is good
practice to group related projects by giving the stems a common 
hyphen-terminated prefix.
</p>
<p>
  Let's suppose you have a project you call ‘foobar’
at major version 1, minor version or release 2, patchlevel 3.  If it's
got just one archive part (presumably the sources), here's what its
names should look like like:
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     <code>foobar-1.2.3.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     The source archive.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>foobar.lsm</code> </span>
   </dt>
   <dd>
    <p>
     The LSM file (assuming you're submitting to ibiblio).
    </p>
   </dd>
  </dl>
 </div>
<p>
  Please
  <em>don't</em>
  use names like these:
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     <code>foobar123.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     This looks to many programs like an archive
for a project called “foobar123” with no version number.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>foobar1.2.3.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     This looks to many programs like an archive
for a project called “foobar1” at version 2.3.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>foobar-v1.2.3.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     Many programs think this goes with a
project called “foobar-v1”.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>foo_bar-1.2.3.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     The underscore is hard for people to speak,
type, and remember.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>FooBar-1.2.3.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     Unless you
     <em>like</em>
     looking like a
marketing weenie.  This is also hard for people to speak, type, and 
remember.
    </p>
   </dd>
  </dl>
 </div>
<p>
  If you have to differentiate between source and binary archives, or
between different kinds of binary, or express some kind of build
option in the file name, please treat that as a file extension to go
  <em>after</em>
  the version number. That is, please do this:
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     <code>foobar-1.2.3.src.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     Sources.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>foobar-1.2.3.bin.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     Binaries, type not specified.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>foobar-1.2.3.bin.i386.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     i386 binaries.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>foobar-1.2.3.bin.i386.static.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     i386 binaries statically linked.
    </p>
   </dd>
   <dt>
    <span class="term">
     <code>foobar-1.2.3.bin.SPARC.tar.gz</code> </span>
   </dt>
   <dd>
    <p>
     SPARC binaries.
    </p>
   </dd>
  </dl>
 </div>
<p>
  Please
  <em>don't</em>
  use names like
‘foobar-i386-1.2.3.tar.gz’, because programs have a hard
time telling type infixes (like ‘-i386’) from the
stem.
</p>
<p>
  The convention for distinguishing major from minor release is
simple: you increment the patch level for fixes or minor features, the 
minor version number for compatible new features, and the major
version number when you make incompatible changes.
</p>
<h5 id="local"><a href="#local">§</a>But respect local conventions where appropriate.</h5>
<p>
  Some projects and communities have well-defined conventions for
names and version numbers that aren't necessarily compatible with the
above advice.  For instance,
Apache
  modules are
generally named like mod_foo, and have both their own version number
and the version of Apache with which they work.  Likewise,
Perl
  modules
have version numbers that can be treated as floating point numbers
(e.g., you might see 1.303 rather than 1.3.3), and the distributions
are generally named Foo-Bar-1.303.tar.gz for version 1.303 of module
Foo::Bar. (Perl itself, on the other hand, switched to using the
conventions described here in late 1999.)
</p>
<p>
  Look for and respect the conventions of specialized
communities and developers; for general use, follow the above
guidelines.
</p>
<h5 id="prefix"><a href="#prefix">§</a>Try hard to choose a name prefix that is unique and easy to type.</h5>
<p>
  The stem prefix should be common to all of a project's files, and it
should be easy to read, type, and remember.  So please don't use
underscores.  And don't capitalize or BiCapitalize without extremely
good reason — it messes up the natural human-eyeball search order and
looks like some marketing weenie trying to be clever.
</p>
<p>
  It confuses people when two different projects have the same stem name.  So try to check for collisions before your
  first release. Two good places to check are the <a href="http://metalab.unc.edu/pub/Linux"> index file of ibiblio</a>
  and the application index at <a href="http://www.freshmeat.net"> Freshmeat</a>.  Another good place to check is
  <a href="http://www.sourceforge.net"> SourceForge</a>; do a name search there.
</p>
<h4 id="develpractice"><a href="#develpractice">§</a>Good Development Practice</h4>
<p>
  Here are some of the behaviors that can make the difference 
between a successful project with lots of contributors and one that
stalls out after attracting no interest:
</p>
<h5 id="proprietary"><a href="#proprietary">§</a>Don't rely on proprietary code.</h5>
<p>
  Don't rely on proprietary languages, libraries, or other code.
Doing so is risky business at the best of times; in the open-source
community, it is considered downright rude. Open-source developers
don't trust code for which they can't review the source.
</p>
<h5 id="autoconf"><a href="#autoconf">§</a>Use GNU Autotools.</h5>
<p>
  Configuration choices should be made at compile time. A
significant advantage of open-source distributions is that they allow
the package to adapt at compile-time to the environment it finds. This
is critical because it allows the package to run on platforms its
developers have never seen, and it allows the software's community of
users to do their own ports. Only the largest of development teams can
afford to buy all the hardware and hire enough employees to support
even a limited number of platforms.
</p>
<p>
  Therefore: Use the GNU autotools to handle portability issues,
do system-configuration probes, and tailor your makefiles.  People
building from sources today expect to be able to type
  <code>configure; make; make install</code>
  and get a clean build — and rightly so.  There is a
  <a href="http://seul.org/docs/autotut/">
   good tutorial on these tools </a>.
</p>
<p>
  <em>autoconf</em> and
  <em>autoheader</em> are mature.
  <em>automake</em>, as we've previously noted, is
still buggy and brittle as of mid-2003; you may have to maintain
your own
  <code>Makefile.in</code>.  Fortunately
it's the least important of the autotools.
</p>
<p>
  Regardless of your approach to configuration, do not ask the user
for system information at compile-time. The user installing the package
does not know the answers to your questions, and this approach is doomed
from the start. The software must be able to determine for itself any
information that it may need at compile- or install-time.
</p>
<p>
  But
  <em>autoconf</em> should not be regarded
as a license for knob-ridden designs.  If at all possible, program to
standards like POSIX and refrain also from asking the system for
configuration information.  Keep ifdefs to a minimum — or,
better yet, have none at all.
</p>
<h5 id="testcode"><a href="#testcode">§</a>Test your code before release.</h5>
<p>
  A good test suite allows the team to easily run regression tests
before releases. Create a strong, usable test framework so that you
can incrementally add tests to your software without having to train
developers in the specialized intricacies of the test suite.
</p>
<p>
  Distributing the test suite allows the community of users to test
their ports before contributing them back to the group.
</p>
<p>
  Encourage your developers to use a wide variety of platforms as
their desktop and test machines, so that code is continuously being
tested for portability flaws as part of normal development.
</p>
<p>
  It is good practice, and encourages confidence in your code, when
it ships with the test suite you use, and that test suite can be run
with
  <code>make test</code>.
</p>
<h5 id="sanitycode"><a href="#sanitycode">§</a>Sanity-check your code before release.</h5>
<p>
  By “sanity check” we mean: use every tool available
that has a reasonable chance of catching errors a human would be prone
to overlook. The more of these you catch with tools, the fewer your
users and you will have to contend with.
</p>
<p>
  If you're writing C
  /C++
  using GCC, test-compile with -Wall and
clean up all warning messages before each release. Compile your code
with every compiler you can find — different compilers often
find different problems. Specifically, compile your software on a true
64-bit machine. Underlying datatypes can change on 64-bit machines,
and you will often find new problems there. Find a Unix vendor's
system and run the lint utility over your software.
</p>
<p>
  Run tools that look for memory leaks and other runtime errors;
Electric Fence and Valgrind are two good ones available in open source.
</p>
<p>
  For Python
  projects, the
  <a href="http://sourceforge.net/projects/pychecker">
   PyChecker</a>
  program can be a useful check.  It often catches nontrivial errors.
</p>
<p>
  If you're writing Perl, check your code with perl
  <code>-c</code> (and maybe
  <code>-T</code>, if
applicable). Use perl
  <code>-w</code> and 'use strict'
religiously. (See the Perl documentation for further
discussion.)
</p>
<h5 id="sanitydocs"><a href="#sanitydocs">§</a>Spell-check your documentation and READMEs before release.</h5>
<p>
  Spell-check your documentation, README files and error messages
in your software. Sloppy code, code that produces warning messages when
compiled, and spelling errors in README files or error messages, all lead
users to believe the engineering behind it is also haphazard and
sloppy.
</p>
<h5 id="cport"><a href="#cport">§</a>Recommended C/C++ Portability Practices</h5>
<p>
  If you are writing C, feel free to use the full ANSI
features.  Specifically, do use function prototypes, which will help
you spot cross-module inconsistencies.  The old-style K&amp;R
compilers are ancient history.
</p>
<p>
  Do not assume compiler-specific features such as the GCC
  <code>-pipe</code> option or nested functions are available. These
will come around and bite you the second somebody ports to a
non-Linux, non-GCC system.
</p>
<p>
  Code required for portability should be isolated to a single
area and a single set of source files (for example, an
  <code>os</code> subdirectory).  Compiler, library and
operating system interfaces with portability issues should be
abstracted to files in this directory.
</p>
<p>
  A portability layer is a library (or perhaps just a set of
macros in header files) that abstracts away just the parts of an
operating system's API your program is interested in.  Portability
layers make it easier to do new software ports. Often, no member of
the development team knows the porting platform (for example, there
are literally hundreds of different embedded operating systems, and
nobody knows any significant fraction of them). By creating a separate
portability layer, it becomes possible for a specialist who knows a
platform to port your software without having to understand anything
outside the portability layer.
</p>
<p>
  Portability layers also simplify applications. Software rarely
needs the full functionality of more complex system calls such as
mmap(2)
or
stat(2),
and programmers commonly configure such complex interfaces
incorrectly. A portability layer with abstracted interfaces
(say, something named
  <code>__file_exists</code> instead of a call to
stat(2))
allows you to import only the limited, necessary functionality from
the system, simplifying the code in your application.
</p>
<p>
  Always write your portability layer to select based on a
feature, never based on a platform. Trying to create a separate
portability layer for each supported platform results in a multiple
update problem maintenance nightmare. A “platform” is
always selected on at least two axes: the compiler and the
library/operating system release. In some cases there are three axes,
as when Linux vendors select a C
  library independently of the operating
system release. With
  <em>M</em>
  vendors,
  <em>N</em>
  compilers, and
  <em>O</em>
  operating system
releases, the number of platforms quickly scales out of reach of any
but the largest development teams.  On the other hand, by using
language and systems standards such as ANSI and POSIX 1003.1, the set
of features is relatively
constrained.
</p>
<p>
  Portability choices can be made along either lines of code or
compiled files. It doesn't make a difference if you select alternate
lines of code on a platform, or one of a few different files. A rule
of thumb is to move portability code for different platforms into
separate files when the implementations diverge significantly (shared
memory mapping on Unix vs. Windows), and leave portability code in a
single file when the differences are minimal (for example, whether
you're using
  <code>gettimeofday</code>,
  <code>clock_gettime</code>,
  <code>ftime</code> or
  <code>time</code> to
find out the current time-of-day).
</p>
<p>
  For anywhere outside a portability layer, heed this advice:
</p>
 <blockquote>
  <p>
   <code>#ifdef</code> and
   <code>#if</code> are last resorts, usually a sign of failure
of imagination, excessive product differentiation, gratuitous
“optimization” or accumulated trash. In the middle of
code they are anathema.
   <code>/usr/include/stdio.h</code> from GNU is an archetypical horror.
  </p>
  <span>
   – Doug McIlroy
  </span>
 </blockquote>
<p>
  Use of
  <code>#ifdef</code> and
  <code>#if</code> is permissible (if well controlled) within a
portability layer. Outside it, try hard to confine these to
conditionalizing
  <code>#includes</code> based on feature
symbols.
</p>
<p>
  Never intrude on the namespace of any other part of the system,
including filenames, error return values and function names.  Where
the namespace is shared, document the portion of the namespace that you
use.
</p>
<p>
  Choose a coding standard. The debate over the choice of standard
can go on forever — regardless, it is too difficult and
expensive to maintain software built using multiple coding standards,
and so some common style must be chosen. Enforce your coding standard
ruthlessly, as consistency and cleanliness of the code are of the
highest priority; the details of the coding standard itself are a
distant second.
</p>
<h4 id="distpractice"><a href="#distpractice">§</a>Good Distribution-Making Practice</h4>
<p>
  These guidelines describe how your distribution should look when
someone downloads, retrieves and unpacks it.
</p>
<h5 id="tarballs"><a href="#tarballs">§</a>Make sure tarballs always unpack into a single new directory.</h5>
<p>
  The single most annoying mistake fledgling contributors make is to build
tarballs that unpack the files and directories in the distribution into
the current directory, potentially overwriting files already located there.
  <em>Never do this!</em>
</p>
<p>
  Instead, make sure your archive files all have a common directory part
named after the project, so they will unpack into a single top-level 
directory directly
  <em>beneath</em>
  the current one.
Conventionally, the name of the directory should be the same as the
stem of the tarball's name.  So, for example, a tarball named
  <code>foo-0.23.tar.gz</code> is expected to unpack into
a subdirectory named
  <code>foo-0.23</code>.
</p>
<p>
   Example 19.1 shows a makefile trick that, assuming your distribution directory is named “foobar” and SRC contains a
   list of your distribution files, accomplishes this.
</p>
 <div class="example">
  <p class="title">
   <b>
    Example 19.1.
    <em>tar</em> archive maker production.
   </b>
  </p>
  <pre class="programlisting">
foobar-$(VERS).tar.gz:
	@ls $(SRC) | sed s:^:foobar-$(VERS)/: &gt;MANIFEST
	@(cd ..; ln -s foobar foobar-$(VERS))
	(cd ..; tar -czvf foobar/foobar-$(VERS).tar.gz `cat foobar/MANIFEST`)
	@(cd ..; rm foobar-$(VERS))
</pre>
 </div>
<h5 id="readme"><a href="#readme">§</a>Include a README.</h5>
<p>
  Include a file called
  <code>README</code> that is a roadmap
of your source distribution.  By ancient convention (originating with
Dennis Ritchie himself before 1980, and promulgated on
Usenet
  in the early
1980s), this is the first file intrepid explorers will read after
unpacking the source.
</p>
<p>
  <code>README</code> files should be short and easy to
read.  Make yours an introduction, not an epic. Good things to have in
the
  <code>README</code> include the following:
</p>
 <div class="orderedlist">
  <ol type="1">
   <li>
    <p>
     A brief description of the project.
    </p>
   </li>
   <li>
    <p>
     A pointer to the project website (if it has 
one).
    </p>
   </li>
   <li>
    <p>
     Notes on the developer's build environment and
potential portability problems.
    </p>
   </li>
   <li>
    <p>
     A roadmap describing important files and subdirectories.
    </p>
   </li>
   <li>
    <p>
     Either build/installation instructions or a pointer to a file
containing same (usually
     <code>INSTALL</code>).
    </p>
   </li>
   <li>
    <p>
     Either a maintainers/credits list or a pointer to a
file containing same (usually
     <code>CREDITS</code>).
    </p>
   </li>
   <li>
    <p>
     Either recent project news or a pointer to a file
containing same (usually
     <code>NEWS</code>).
    </p>
   </li>
   <li>
    <p>
     Project mailing list addresses.
    </p>
   </li>
  </ol>
 </div>
<p>
  At one time this file was commonly
  <code>READ.ME</code>,
but this interacts badly with browsers, who are all too likely to
assume that the
  <code>.ME</code> suffix means it's not textual and can only be
downloaded rather than browsed.  This usage is deprecated.
</p>
<h5 id="filenames"><a href="#filenames">§</a>Respect and follow standard file-naming practices.</h5>
<p>
  Before even looking at the
  <code>README</code>, your
intrepid explorer will have scanned the filenames in the top-level
directory of your unpacked distribution.  Those names can themselves
convey information.  By adhering to certain standard naming practices,
you can give the explorer valuable clues about where to look
next.
</p>
<p>
  Here are some standard top-level file names and what they mean.  Not
every distribution needs all of these.
</p>
 <div class="variablelist">
  <dl>
   <dt>
    <span class="term">
     README
    </span>
   </dt>
   <dd>
    <p>
     The roadmap file, to be read first.
    </p>
   </dd>
   <dt>
    <span class="term">
     INSTALL
    </span>
   </dt>
   <dd>
    <p>
     Configuration, build, and installation instructions.
    </p>
   </dd>
   <dt>
    <span class="term">
     AUTHORS
    </span>
   </dt>
   <dd>
    <p>
     List of project contributors (GNU convention).
    </p>
   </dd>
   <dt>
    <span class="term">
     NEWS
    </span>
   </dt>
   <dd>
    <p>
     Recent project news.
    </p>
   </dd>
   <dt>
    <span class="term">
     HISTORY
    </span>
   </dt>
   <dd>
    <p>
     Project history.
    </p>
   </dd>
   <dt>
    <span class="term">
     CHANGES
    </span>
   </dt>
   <dd>
    <p>
     Log of significant changes between revisions.
    </p>
   </dd>
   <dt>
    <span class="term">
     COPYING
    </span>
   </dt>
   <dd>
    <p>
     Project license terms (GNU convention).
    </p>
   </dd>
   <dt>
    <span class="term">
     LICENSE
    </span>
   </dt>
   <dd>
    <p>
     Project license terms.
    </p>
   </dd>
   <dt>
    <span class="term">
     FAQ
    </span>
   </dt>
   <dd>
    <p>
     Plain-text Frequently-Asked-Questions document for
the project.
    </p>
   </dd>
  </dl>
 </div>
<p>
  Note the overall convention that filenames with all-caps names
are human-readable metainformation about the package, rather than
build components. This elaboration of the
  <code>README</code> was developed early on at the Free Software
Foundation.
</p>
<p>
  Having a
  <code>FAQ</code> file can save you a lot of
grief.  When a question about the project comes up often, put it in
the FAQ; then direct users to read the FAQ before sending questions or
bug reports.  A well-nurtured FAQ can decrease the support burden on
the project maintainers by an order of magnitude or more.
</p>
<p>
  Having a
  <code>HISTORY</code> or
  <code>NEWS</code> file with timestamps in it for each release
is valuable.  Among other things, it may help establish prior art if
you are ever hit with a patent-infringement lawsuit (this hasn't
happened to anyone yet, but best to be prepared).
</p>
<h5 id="upgradability"><a href="#upgradability">§</a>Design for upgradability.</h5>
<p>
  Your software will change over time as you put out new releases.  Some
of these changes will not be backward-compatible.  Accordingly, you
should give serious thought to designing your installation layouts so
that multiple installed versions of your code can coexist on the same
system.  This is especially important for libraries — you can't 
count on all your client programs to upgrade in lockstep with your
API changes.
</p>
<p>
  The Emacs, Python, and Qt projects have a good convention for
handling this: version-numbered directories (another practice that
seems to have been made routine by the FSF).  Here's how an installed
Qt library hierarchy looks (
  <code>${ver}</code> is the version
number):
</p>
 <pre class="screen">
/usr/lib/qt
/usr/lib/qt-${ver}
/usr/lib/qt-${ver}/bin          # Where you find moc
/usr/lib/qt-${ver}/lib          # Where you find .so
/usr/lib/qt-${ver}/include      # Where you find header files
</pre>
<p>
  With this organization, multiple versions can coexist.  Client programs have to specify the library version they want,
  but that's a small price to pay for not having the interfaces break on them.  This good practice avoids the notorious
  <a href="#dll_hell"> “DLL Hell”</a> failure mode of Windows.
</p>
<h5 id="rpms"><a href="#rpms">§</a>Under Linux, provide RPMs.</h5>
<p>
  The de facto standard format for installable binary packages
under Linux that used by the Red Hat Package manager, RPM.  It's
featured in the most popular Linux
  distribution, and supported by
effectively all other Linux distributions (except Debian and
Slackware; and Debian can install from RPMs). Accordingly, it's a good
idea for your project site to provide installable RPMs as well as
source tarballs.
</p>
<p>
  It's also a good idea for you to include in your source tarball
the RPM spec file, with a production that makes RPMs from it in your
  <code>makefile</code>.  The spec file should have the
extension
  <code>.spec</code>; that's how the
  <em>rpm</em> <code>-t</code> option finds it in a
tarball.
</p>
<p>
  For extra style points, generate your spec file with a
shellscript that automatically plugs in the correct version number by
analyzing the project
  <code>makefile</code> or a
  <code>version.h</code>.
</p>
<p>
  Note: If you supply source RPMs, use BuildRoot to make the
program be built in
  <code>/tmp</code> or
  <code>/var/tmp</code>.  If you don't, during the course of
running the make install part of your build, the install will install
the files in the real final places. This will happen even if there are
file collisions, and even if you didn't want to install the package at
all. When you're done, the files will have been installed and your
system's RPM database will not know about it. Such badly behaved SRPMs
are a minefield and should be eschewed.
</p>
<h5 id="checksums"><a href="#checksums">§</a>Provide checksums.</h5>
<p>
  Provide checksums with your binaries (tarballs, RPMs, etc.).  This
will allow people to verify that they haven't been corrupted or had
Trojan-horse code inserted in them.
</p>
<p>
  While there are several commands you can use for this purpose
(such as <code>sum</code> and <code>cksum</code>) it is
best to use a cryptographically-secure hash function.  The GPG package
provides this capability via the
  <code>--detach-sign</code> option; so does the GNU command <code>md5sum</code>.
</p>
<p>
  For each binary you ship, your project Web page should list
the checksum and the command you used to generate it.
</p>
<h4 id="communication"><a href="#communication">§</a>Good Communication Practice</h4>
<p>
  Your software and documentation won't do the world much good if
nobody but you knows they exist.  Also, developing a visible presence for
the project on the Internet will assist you in recruiting users and
co-developers.  Here are the standard ways to do that.
</p>
<h5 id="announce"><a href="#announce">§</a>Announce to Freshmeat.</h5>
<p>
  Announce to
  <a href="http://www.freshmeat.net">
   Freshmeat</a>.
Besides being widely read itself, this group is a major feeder for 
Web-based technical news channels.
</p>
<p>
  Never assume the audience has been reading your release
announcements since the beginning of time.  Always include at least a
one-line description of what the software does.  Bad example:
“Announcing the latest release of FooEditor, now with themes
and ten times faster”.  Good example: “Announcing the
latest release of FooEditor, the scriptable editor for touch-typists, 
now with themes and ten times faster”.
</p>
<h5 id="newsgroup"><a href="#newsgroup">§</a>Announce to a relevant topic newsgroup.</h5>
<p>
  Find a Usenet topic group directly relevant to your application,
and announce there as well.  Post only where the
  <em>function</em>
  of the code is relevant, and exercise
restraint.
</p>
<p>
  If (for example) you are releasing a program written in Perl
that queries IMAP servers, you should certainly post to
  <code>comp.mail.imap</code>.  But you should probably
not post to
  <code>comp.lang.perl</code> unless the program is also an instructive example of cutting-edge Perl
techniques.
</p>
<p>
  Your announcement should include the URL of a project website.
</p>
<h5 id="website"><a href="#website">§</a>Have a website.</h5>
<p>
  If you intend trying to build any substantial user or developer community
around your project, it should have a website.  Standard things to have
on the website include:
</p>
 <div>
  <ul>
   <li>
    <p>
     The project charter (why it exists, who the audience is, etc.).
    </p>
   </li>
   <li>
    <p>
     Download links for the project sources.
    </p>
   </li>
   <li>
    <p>
     Instructions on how to join the project mailing list(s).
    </p>
   </li>
   <li>
    <p>
     A FAQ (Frequently Asked Questions) list.
    </p>
   </li>
   <li>
    <p>
     HTMLized versions of the project documentation.
    </p>
   </li>
   <li>
    <p>
     Links to related and/or competing projects.
    </p>
   </li>
  </ul>
 </div>
<p>
  Refer to the website examples in
  <a href="#reusechapter" title="Chapter 16. Reuse">
   Chapter 16</a>
  for examples of what a well-educated project
website looks like.
</p>
<p>
  An easy way to have a website is to put your project on one of
the sites that specializes in providing free hosting. In 2003
the two most important of these are SourceForge (which is a
demonstration and test site for proprietary collaboration tools) or
Savannah (which hosts open-source projects as an ideological
statement).
</p>
<h5 id="lists"><a href="#lists">§</a>Host project mailing lists.</h5>
<p>
  It's standard practice to have a private development list
through which project collaborators can communicate and exchange
patches.  You may also want to have an announcements list for people
who want to be kept informed of the project's progress.
</p>
<p>
  If you are running a project named ‘foo’, your
developer list might be
  <code>
   &lt;
   <a href="mailto:foo-dev">
    foo-dev</a>
   &gt;
  </code>
  or
  <code>
   &lt;
   <a href="mailto:foo-friends">
    foo-friends</a>
   &gt;
  </code>; your announcement list might be
  <code>
   &lt;
   <a href="mailto:foo-announce">
    foo-announce</a>
   &gt;
  </code>.
</p>
<p>
  An important decision is just how private the
“private” development list is.  Wider participation in
design discussions is often a good thing, but if the list is
relatively open, sooner or later you
  <em>will</em>
  get
people asking new-user questions on it.  Opinions vary on how best to
solve this problem.  Just having the documentation tell the new users
not to ask elementary questions on the development list is not a
solution; such a request must be enforced somehow.
</p>
<p>
  An announcements list needs to be tightly controlled.  Traffic should be
at most a few messages a month; the whole purpose of such a list is to
accommodate people who want to know when something important happens, but
don't want to hear about day-to-day details.  Most such people will
quickly unsubscribe if the list starts generating significant clutter in
their mailboxes.
</p>
<h5 id="archives"><a href="#archives">§</a>Release to major archives.</h5>
<p>
  See the section
  <em>Where Should I Look?</em> in
  <a href="#reusechapter" title="Chapter 16. Reuse">
   Chapter 16</a>
  for specifics on
the major open-source archive sites.  You should release your package
to these.
</p>
<p>
  Other important locations include:
</p>
 <div>
  <ul>
   <li>
    <p>
     The
     <a href="http://www.python.org">
      Python Software Activity</a>
     site (for software written in Python).
    </p>
   </li>
   <li>
    <p>
     The
     <a href="http://language.perl.com/CPAN">
      CPAN</a>, the
Comprehensive Perl Archive Network (for software written in Perl).
    </p>
   </li>
  </ul>
 </div>



<!-- FILE: ch19s03.html -->
<h3 id="ch19s03"><a href="#ch19s03">§</a>The Logic of Licenses: How to Pick One</h3>
<p>
  The choice of license terms involves decisions about what, if
any restrictions the author wants to put on what people do with the
software.
</p>
<p>
  If you want to make no restrictions at all, you should put your
software in the public domain. An appropriate way to do this would
be to include something like the following text at the head of each
file:
</p>
 <pre class="programlisting">
Placed in public domain by J. Random Hacker, 2003.  Share and enjoy!
</pre>
<p>
  If you do this, you are surrendering your copyright. Anyone can
do anything they like with any part of the text. It doesn't get any
freer than this.
</p>
<p>
  But very little open-source software is actually placed in the
public domain.  Some open-source developers want to use
their ownership of the code to ensure that it stays open (these tend
to adopt the GPL).  Others simply want to control their legal exposure;
one of the things
  <em>all</em>
  open-source licenses have
in common is a disclaimer of warranty.
</p>



<!-- FILE: ch19s04.html -->
<h3 id="ch19s04"><a href="#ch19s04">§</a>Why You Should Use a Standard License</h3>
<p>
  The widely known licenses conforming to the Open Source
Definition have well-established interpretive traditions. Developers
(and, to the extent they care, users) know what they imply, and have a
reasonable take on the risks and tradeoffs they involve. Therefore,
use one of the standard licenses carried on the OSI site if at all
possible.
</p>
<p>
  If you must write your own license, be sure to have it certified
by OSI. This will avoid a lot of argument and overhead. Unless you've
been through it, you have no idea how nasty a licensing flamewar can
get; people become passionate because the licenses are regarded as
almost-sacred covenants touching the core values of the open-source
community.
</p>
<p>
  Furthermore, the presence of an established interpretive
tradition may prove important if your license is ever tested in
court. At time of writing (mid-2003) there is no case law either
supporting or invalidating any open-source license. However, it is
a legal doctrine (at least in the United States, and probably in other
common-law countries such as England and the rest of the British
Commonwealth) that courts are supposed to interpret licenses and
contracts according to the expectations and practices of the
community in which they originated. There is thus good reason to
hope that open-source community practice will be determinative when
the court system finally has to cope.
</p>



<!-- FILE: ch19s05.html -->
<h3 id="ch19s05"><a href="#ch19s05">§</a>Varieties of Open-Source Licensing</h3>
<h4 id="id3014860"><a href="#id3014860">§</a>MIT or X Consortium License</h4>
<p>
  The loosest kind of free-software license is one that grants
unrestricted rights to copy, use, modify, and redistribute modified
copies as long as a copy of the copyright and license terms is
retained in all modified versions.  But when you accept this
license you do give up the right to sue the maintainers.
</p>
<p>
  You can find a template for the standard X Consortium license at
the
  <a href="http://www.opensource.org/licenses/mit-license.html">
   OSI
site</a>.
</p>
<h4 id="id3014890"><a href="#id3014890">§</a>BSD Classic License</h4>
<p>
  The next least restrictive kind of license grants unrestricted
rights to copy, use, modify, and redistribute modified copies as long
as a copy of the copyright and license terms is retained in all
modified versions, and an acknowledgment is made in advertising or
documentation associated with the package.  Grantee has to give up
the right to sue the maintainers.
</p>
<p>
  The original BSD license is the best-known license of this kind.
Among parts of the free-software culture that trace their lineages
back to BSD Unix,
this license is used even on a lot of free software that was written
thousands of miles from
Berkeley.
</p>
<p>
  It is also not uncommon to find minor variants of the BSD
license that change the copyright holder and omit the advertising
requirement (making it effectively equivalent to the MIT license).
Note that in mid-1999 the Office of Technology Transfer of the
University of California rescinded the advertising clause in the BSD
license. So the license on the BSD software has been relaxed in
exactly this way.  Should you choose the BSD approach, we strongly
recommend that you use the new license (without advertising clause)
rather than the old.  That requirement was dropped because it led to
significant legal and procedural complications over what constituted
advertising.
</p>
<p>
  You can find a BSD license template at the
  <a href="http://www.opensource.org/licenses/bsd-license.html">
   OSI
site</a>.
</p>
<h4 id="id3014963"><a href="#id3014963">§</a>Artistic License</h4>
<p>
  The next most restrictive kind of license grants unrestricted
rights to copy, use, and locally modify. It allows redistribution of
modified binaries, but restricts redistribution of modified sources in
ways intended to protect the interests of the authors and the
free-software community.
</p>
<p>
  The Artistic License, devised for Perl
  and widely used in the Perl developer
community, is of this kind. It requires modified files to contain
“prominent notice” that they have been altered. It also
requires people who redistribute changes to make them freely available
and make efforts to propagate them back to the free-software
community.
</p>
<p>
  You can find a copy of the Artistic License at the
  <a href="http://www.opensource.org/licenses/artistic-license.html">
   OSI
site</a>.
</p>
<h4 id="id3015011"><a href="#id3015011">§</a>General Public License</h4>
<p>
  The GNU General Public License (and its derivative, the Library
or “Lesser” GPL) is the single most widely used
free-software license. Like the Artistic License, it allows
redistribution of modified sources provided the modified files bear
“prominent notice”.
</p>
<p>
  The GPL requires that any program containing parts that are under
GPL be wholly GPLed. (The exact circumstances that trigger this
requirement are not perfectly clear to everybody.)
</p>
<p>
  These extra requirements actually make the GPL more restrictive
than any of the other commonly used licenses. (Larry Wall developed
the Artistic License to avoid them while serving many of the same
objectives.)
</p>
<p>
  You can find a pointer to the GPL, and instructions about how to
apply it, at
  <a href="http://www.gnu.org/copyleft.html">
   FSF
copyleft site</a>.
</p>
<h4 id="id3015063"><a href="#id3015063">§</a>Mozilla Public License</h4>
<p>
  The Mozilla Public License supports software that is open
source, but may be linked with closed-source modules or extensions. It
requires that the distributed software ("Covered Code")
remain open, but permits add-ons called through a defined API to
remain closed.
</p>
<p>
  You can find a template for the MPL at the
  <a href="http://www.opensource.org/licenses/MPL-1.1.html">
   OSI
site</a>.
</p>



<!-- FILE: futurechapter.html -->
<h3 id="futurechapter"><a href="#futurechapter">§</a>Chapter 20. Futures</h3>
 <blockquote class="epigraph">
  <p>
   The best way to predict the future is to invent it.
  </p>
  <span>
   – Alan Kay
Uttered during a 1971 meeting at XEROX PARC
  </span>
 </blockquote>
<p>
  History is not over.  Unix will continue to grow and change.
The community and the tradition around Unix will continue to evolve.
Trying to forecast the future is a chancy business, but we can perhaps
anticipate it in two ways: first, by looking at how Unix has coped with
design challenges in the past; second, by identifying problems that are
looking for solutions and opportunities waiting to be
exploited.
</p>



<!-- FILE: ch20s01.html -->
<h3 id="ch20s01"><a href="#ch20s01">§</a>Essence and Accident in Unix Tradition</h3>
<p>
  To understand how Unix's design might change in the future, we can
start by looking at how Unix programming style has changed over time
in the past.  This effort leads us directly to one of the challenges
of understanding the Unix style — distinguishing between
accident and essence. That is, recognizing traits that arise from
transient technical circumstances versus those that are deeply tied to
the central Unix design challenge — how to do modularity and
abstraction right while also keeping systems transparent and
simple.
</p>
<p>
  This distinction can be difficult, because traits that arose as
accidents have sometimes turned out to have essential utility.
Consider as an example the ‘Silence is golden’ rule of
Unix interface design we examined in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>; it began as an adaptation to slow
teletypes, but continued because programs with terse output could be
combined in scripts more easily.  Today, in an environment where
having many programs running visibly through a GUI is normal, it has a
third kind of utility: silent programs don't distract or waste the
user's attention.
</p>
<p>
  On the other hand, some traits that once seemed essential to
Unix turned out to be accidents tied to a particular set of cost
ratios.  For example, old-school Unix favored program designs (and
minilanguages like awk(1)) that did line-at-a-time processing of an
input stream or record-at-a-time processing of binary files, with any
context that needed to be maintained between pieces carried by
elaborate state-machine code.  New-school Unix design, on the other
hand, is generally happy with the assumption that a program can read
its entire input into memory and thereafter randomly access it at will.
Indeed, modern Unixes supply an mmap(2) call that allows the
programmer to map an entire file into virtual memory and completely
hides the serialization of I/O to and from disk space.
</p>
<p>
  This change trades away storage economy to get simpler and more
transparent code.  It's an adaptation to the plunging cost of memory
relative to programmer time.  Many of the differences between
old-school Unix designs in the 1970s and 1980s and those of the new
post-1990 school can be traced to the huge shift in relative costs
that today makes all machine resources several orders of magnitude
cheaper relative to programmer time than they were in 1969.
</p>
<p>
  Looking back, we can identify three specific technology changes
that have driven significant changes in Unix design style:
internetworking, bitmapped graphics displays, and the personal
computer.  In each case, the Unix tradition has adapted to the
challenge by discarding accidents that were no longer adaptive and
finding new applications for its essential ideas.  Biological
evolution works this way too.  Evolutionary biologists have a rule:
“Don't assume that historical origin specifies current utility,
or vice versa”. A brief look at how Unix adapted in each of
these cases may provide some clues to how Unix might adapt itself to
future technology shifts that we cannot yet anticipate.
</p>
<p>
  <a href="#historychapter" title="Chapter 2. History">
   Chapter 2</a>
  described
the first of these changes: the rise of internetworking, from the
angle of cultural history, telling how
TCP/IP
  brought the
original Unix and ARPANET cultures together after 1980. In
  <a href="#multiprogramchapter" title="Chapter 7. Multiprogramming">
   Chapter 7</a>, the material on obsolescent IPC and
networking methods such as System V
  STREAMS hints at the many false starts,
missteps, and dead ends that preoccupied Unix developers through much
of the following decade.  There was a good deal of confusion about
protocols,<sup><a href="#ftn.id3017690" id="id3017690">[153]</a></sup>
  and about the
relationship between intermachine networking and interprocess
communication among processes on the same machine.
</p>
<p>
  Eventually the confusion was cleared up when TCP/IP won and BSD
sockets
  reasserted Unix's essential
everything-is-a-byte-stream
  metaphor.  It became normal to use BSD
sockets for both IPC and networking, older methods for both largely
fell out of use, and Unix software grew increasingly indifferent to
whether communicating components were hosted on the same or different
machines.  The invention of the World Wide Web in 1990-1991 was the
logical result.
</p>
<p>
  When bitmapped graphics and the example of the Macintosh
arrived in 1984 a few years after TCP/IP, they posed a rather more
difficult challenge.  The original GUIs from Xerox
PARC
  and Apple
were beautiful, but wired together far too many levels of the system
for Unix programmers to feel comfortable with their design.  The
prompt response of Unix programmers was to make separation of policy
from mechanism an explicit principle; the X windowing system
established it by 1988.  By splitting X widget sets away from the
display manager that was doing low-level graphics, they created an
architecture that was modular and clean in Unix terms, and one that
could easily evolve better policy over time.
</p>
<p>
  But that was the easy part of the problem.  The hard part was
deciding whether Unix ought to have a unified interface policy at all,
and if so what it ought to be.  Several different attempts to
establish one through proprietary toolkits (like Motif) failed.  Today,
in 2003, GTK and Qt contend with each other for the role.  While the
debate on this question is not over in 2003, the persistence of
different UI styles that we noted in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>
  seems telling. New-school Unix design has
kept the command line, and dealt with the tension between GUI and CLI
approaches by writing lots of CLI-engine/GUI-interface pairs that can
be used in both styles.
</p>
<p>
  The personal computer posed few major design challenges as a
technology in itself.  The 386 and later chips were powerful enough to
give the systems designed around them cost ratios similar to those of
the minicomputers, workstations, and servers on which Unix matured.
The true challenge was a change in the potential market for Unix; the
much lower overall price of the hardware made personal computers
attractive to a vastly broader, less technically sophisticated user
population.
</p>
<p>
  The proprietary-Unix vendors, accustomed to the fatter margins from
selling more powerful systems to sophisticated buyers, were never
interested in this wider market.  The first serious initiatives
toward the end-user desktop came out of the open-source community and
were mounted for essentially ideological reasons.  As of mid-2003,
market surveys indicate that
Linux
  has reached about
4%–5% share there, closely comparable to the Apple Macintosh's.
</p>
<p>
  Whether or not Linux ever does substantially better than this,
the nature of the Unix community's response is already clear. We
examined it in the study of Linux in
  <a href="#contrastchapter" title="Chapter 3. Contrasts">
   Chapter 3</a>.  It includes adopting a few technologies
(such as XML) from elsewhere, and putting a lot of effort into
naturalizing GUIs into the Unix world.  But underneath the themed GUIs
and the installation packaging, the main emphasis is still on
modularity and clean code — on getting the infrastructure for
serious, high-reliability computing and communications right.
</p>
<p>
  The history of the large-scale desktop-focused developments like
Mozilla and OpenOffice.org that were launched in the late 1990s
illustrates this emphasis well.  In both these cases, the most
important theme in community feedback wasn't demand for new features
or pressure to make a ship date — it was distaste for monster
monoliths, and a general sense that these huge programs would have to
be slimmed down, refactored, and carved into modules before they would
be other than embarrassments.
</p>
<p>
  Despite being accompanied by a great deal of innovation, the
responses to all three technologies were conservative with regard to
the fundamental Unix design rules — modularity,
transparency, separation of policy from mechanism, and the other qualities
we've tried to characterize earlier in this book.  The learned
response of Unix programmers, reinforced over thirty years, was to go
back to first principles — to try to get more leverage out of
Unix's basic abstractions of streams, namespaces, and processes in
preference to layering on new ones.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id3017690" id="ftn.id3017690">[153]</a></sup>
  For a few years it looked like ISO's 7-layer
networking standard might compete successfully with TCP/IP.  It was
promoted by a European standards committee politically horrified at
the thought of adopting any technology birthed in the bowels of the
Pentagon.  Alas, their indignation exceeded their technical acuity.
The result proved overcomplicated and unhelpful; see <sup><a href="#Padlipsky" title="[Padlipsky]">[Padlipsky]</a></sup> for details.
</p>
</div>


<!-- FILE: plan9.html -->
<h3 id="plan9"><a href="#plan9">§</a>Plan 9: The Way the Future Was</h3>
<p>
  We know what Unix's future used to look like.  It was designed
by the research group at Bell Labs that built Unix and called
‘Plan 9 from Bell Labs’.<sup><a href="#ftn.id3015199" id="id3015199">[154]</a></sup>
  Plan 9 was an attempt to do Unix over
again, better.
</p>
<p>
  The central design challenge the designers attempted to meet in
Plan 9 was integrating graphics and ubiquitous networking into a
comfortable Unix-like framework. They kept the Unix choice to mediate
access to as many system services as possible through a single big
file-hierarchy name space.  In fact, they improved on it; many
facilities that under Unix are accessed through various ad-hoc
interfaces like BSD sockets,
fcntl(2),
and
ioctl(2)
are in Plan 9 accessed through ordinary read and write operations on
special files analogous to device files.  For portability and ease of
access, almost all device interfaces are textual rather than binary.
Most system services (including, for example, the window system) are
  <em>file servers</em> containing special files or
directory trees representing the served resources.  By representing
all resources as files, Plan 9 turns the problem of accessing
resources on different servers into the problem of accessing files on
different servers.
</p>
<p>
  Plan 9 combined this more-Unix-than-Unix file model with a new
concept: private name spaces.  Every user (in fact, every
process) can have its own view of the system's services by creating
its own tree of file-server mounts.  Some of the file server mounts
will have been manually set up by the user, and others automatically
set up at login time.  So (as the
  <em>Plan 9 from Bell Labs</em>
  survey paper points out)
“<code>/dev/cons</code>
  always refers to your terminal
device and <code>/bin/date</code>
  to the correct version of
the date command to run, but which files those names represent depends
on circumstances such as the architecture of the machine executing
  <code>date</code>”.
</p>
<p>
  The single most important feature of Plan 9 is that all mounted
file servers export the same file-system-like interface, regardless of
the implementation behind them.  Some might correspond to local file
systems, some to remote file systems accessed over a network, some to
instances of system servers running in user space (like the window
system or an alternate network stack), and some to kernel interfaces.
To users and client programs, all these cases look alike.
</p>
<p>
  One of the examples from the Plan 9 survey paper is the way FTP
access to remote sites is implemented.  There is no
ftp(1)
command under Plan 9.  Instead there is an
  <em>ftpfs</em> fileserver, and each FTP connection
looks like a file system mount.
  <em>ftpfs</em> automatically translates open, read, and write commands on files and
directories under the mount point into FTP protocol transactions.
Thus, all ordinary file-handling tools such as
ls(1),
mv(1)
and
cp(1)
simply work, both underneath the FTP mount point and across the
boundaries with the rest of the user's view of the namespace.  The only
difference the user (or his scripts and programs) will notice is
retrieval speed.
</p>
<p>
  Plan 9 has much else to recommend it, including the reinvention
of some of the more problematic areas of the Unix system-call
interface, the elimination of superuser, and many other interesting
rethinkings. Its pedigree is impeccable, its design elegant, and it
exposes some significant errors in the design of Unix.  Unlike most
efforts at a second system, it produced an architecture that was in
many ways simpler and more elegant than its predecessor. Why didn't it
take over the world?
</p>
<p>
  One could argue for a lot of specific reasons — lack of
any serious effort to market it, scanty documentation, much confusion
and stumbling over fees and licensing.  For those unfamiliar with Plan
9, it seemed to function mainly as a device for generating interesting
papers on operating-systems research.  But Unix itself had previously
surmounted all these sorts of obstacles to attract a dedicated
following that spread it worldwide.  Why didn't Plan 9?
</p>
<p>
  The long view of history may tell a different story, but in
2003 it looks like Plan 9 failed simply because it fell short of
being a compelling enough improvement on Unix to displace its
ancestor.  Compared to Plan 9, Unix creaks and clanks and has obvious
rust spots, but it gets the job done well enough to hold its position.
There is a lesson here for ambitious system architects: the most
dangerous enemy of a better solution is an existing codebase that is
just good enough.
</p>
<p>
  Some Plan 9 ideas have been absorbed into modern Unixes,
particularly the more innovative open-source versions.  FreeBSD has a
  <code>/proc</code> file system modeled exactly on
that of Plan 9 that can be used to query or control running processes.
FreeBSD's
rfork(2)
and Linux's
clone(2)
system calls are modeled on Plan 9's
rfork(2).
Linux's
  <code>/proc</code> file system, in addition
to presenting process information, holds a variety of synthesized Plan
9-like device files used to query and control kernel internals using
predominantly textual interfaces.  Experimental 2003 versions of
Linux are implementing per-process mount points, a long step toward
Plan 9's private namespaces.  The various open-source Unixes are all
moving toward systemwide support for UTF-8, an encoding actually
invented for Plan 9.<sup><a href="#ftn.id3015486" id="id3015486">[155]</a></sup>
</p>
<p>
  It may well be that over time, much more of Plan 9 will work its
way into Unix as various portions of Unix's architecture slide into
senescence.  This is one possible line of development for Unix's 
future.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id3015199" id="ftn.id3015199">[154]</a></sup>
  The name is a
tribute to the 1958 movie that has passed into legend as “the
worst ever made”,
  <em>Plan 9 from Outer Space</em>.  (The legend is, unfortunately, incorrect, as the
few who have seen an even worse stinkeroo from 1966 called
  <em>Manos: The Hands of Fate</em> can
attest.) Documentation, including a survey paper
describing the architecture, along with complete source code and a
distribution that installs on PCs, can be readily found with a Web
search for the phrase ‘Plan 9 from Bell
Labs’.
</p>

<p><sup><a href="#id3015486" id="ftn.id3015486">[155]</a></sup>
  The tale of how UTF-8 was born
involves
  <a href="http://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt">
   Ken
Thompson, Rob Pike, a new Jersey diner, and a frenzied overnight
hack</a>.
</p>
</div>


<!-- FILE: ch20s03.html -->
<h3 id="ch20s03"><a href="#ch20s03">§</a>Problems in the Design of Unix</h3>
<p>
  Plan 9 cleans up Unix, but only really adds one new concept
(private namespaces) to its basic set of design ideas.  But are there
serious problems with those basic design ideas? In
  <a href="#philosophychapter" title="Chapter 1. Philosophy">Chapter 1</a>
  we touched on
several issues that Unix arguably got wrong.  Now that the open-source
movement has put the design future of Unix back in the hands of
programmers and technical people, these are no longer decisions we
have to live with forever.  We'll reexamine them in order to get a
better handle on how Unix might evolve in the future.
</p>
<h4 id="id3015538"><a href="#id3015538">§</a>A Unix File Is Just a Big Bag of Bytes</h4>
<p>
  A Unix file is just a big bag of bytes, with no other 
attributes.  In particular, there is no capability to store
information about the file type or a pointer to an associated
application program outside the file's actual data.
</p>
<p>
  More generally, everything is a byte stream; even hardware devices are byte streams.
This metaphor was a tremendous success of early Unix, and a real
advance over a world in which (for example) compiled programs could
not produce output that could be fed back to the compiler.
Pipes
  and shell
programming
  sprang from this metaphor.
</p>
<p>
  But Unix's byte-stream metaphor is
  <em>so</em>
  central that Unix has trouble integrating software objects with
operations that don't fit neatly into the byte stream or file
repertoire of operations (create, open, read, write, delete). This is
especially a problem for GUI objects such as icons, windows, and
‘live’ documents.  Within a classical Unix model of the
world, the only way to extend the everything-is-a-byte-stream metaphor
is through
  <code>ioctl</code> calls, a notoriously ugly
collection of back doors into kernel space.
</p>
<p>
  Fans of the Macintosh
  family of operating systems tend to be
vociferous about this.  They advocate a model in which a single
filename may have both data and resource ‘forks’, the data
fork corresponding to the Unix byte stream and the resource fork being
a collection of name/value pairs. Unix partisans prefer approaches
that make file data self-describing so that effectively the same sort
of metadata is stored within the file.
</p>
<p>
  The problem with the Unix approach is that every program
that writes the file has to know about it.  Thus, for example, if we
want the file to carry type information inside it, every tool that
touches it has to take care to either preserve the type field
unaltered or interpret and then rewrite it.  While this would be
theoretically possible to arrange, in practice it would be far too
fragile.
</p>
<p>
  On the other hand, supporting file attributes raises awkward
questions about which file operations should preserve them.  It's
clear that a copy of a named file to another name should copy
the source file's attributes as well as its data — but suppose
we
cat(1)
the file, redirecting the output of
cat(1)
to a new name?
</p>
<p>
  The answer to this question depends on whether the attributes
are actually properties of filenames or are in some magical way
bundled with the file's data as a sort of invisible preamble or
postamble.  Then the question becomes: Which operations make the
properties visible?
</p>
<p>
  Xerox PARC
  file-system designs grappled with this problem as far back as the
1970s. They had an ‘open serialized’ call that returned a
byte stream containing both attributes and content.  If applied to a
directory, it returned a serialization of the directory's attributes
plus the serialization of all the files in it.  It is not clear that
this approach has ever been bettered.
</p>
<p>
  Linux 2.5
  already supports attaching arbitrary
name/value pairs as properties of a filename, but at time of writing
 this capability is not yet much used by
applications.  Recent versions of Solaris have a roughly equivalent
feature.
</p>
<h4 id="id3015724"><a href="#id3015724">§</a>Unix Support for GUIs Is Weak</h4>
<p>
  The Unix experience proves that using a handful of metaphors as
the basis for a framework is a powerful strategy (recall the
discussion of frameworks and shared context in
  <a href="#complexitychapter" title="Chapter 13. Complexity">Chapter 13</a>).  The visual metaphor at the heart of
modern GUIs (files represented by icons, and opened by clicking which
invokes some designated handler program, typically able to create and
edit these files) has proven both successful and long-lived, exerting
a strong hold on users and interface designers ever since Xerox
PARC pioneered it in the 1970s.
</p>
<p>
  Despite considerable recent effort, in 2003 Unix still
supports this metaphor only poorly and grudgingly — there are
lots of layers, few conventions, and only weak construction utilities.
A typical reaction from a Unix old hand is to suspect that this
reflects deeper problems with the GUI metaphor itself.
</p>
 <blockquote>
  <p>
   I think part of the problem is that we still don't have the
metaphor right.  For example, on the Mac I drag a file to the
trashcan to delete it, but when I drag it to a disc it gets copied,
and can't drag it to a printer icon to print it because that's done
through the menus.  I could go on and on.  It's like files were in
OS/360, before Unix came along with its simple (but not too simple),
file idea.
  </p>
  <span>
   – Steve Johnson
  </span>
 </blockquote>
<p>
  We quoted Brian Kernighan and Mike Lesk to similar effect in
  <a href="#interfacechapter" title="Chapter 11. Interfaces">
   Chapter 11</a>.  But the inquiry can't stop with
indicting the GUI, because with all its flaws there is tremendous
demand for GUIs from end users.  Supposing we could get the metaphor
right at the level of the design of user interactions, would Unix be
capable of supporting it gracefully?
</p>
<p>
  The answer is: probably not.  We touched on this problem in
considering whether the bag-of-bytes model is adequate.
Macintosh-style file attributes may help provide the mechanism for
richer support of GUIs, but it seems very unlikely that they are the
whole answer.  Unix's object model doesn't include the right
fundamental constructs.  We need to think through what a really strong
framework for GUIs would be like — and, just as importantly,
how it can be integrated with the existing frameworks of Unix.  This
is a hard problem, demanding fundamental insights that have yet to
emerge from the noise and confusion of ordinary software engineering
or academic research.
</p>
<h4 id="id3015838"><a href="#id3015838">§</a>File Deletion Is Forever</h4>
<p>
  People with VMS
  experience, or who remember
TOPS-20
  often
miss these systems' file-versioning facilities. Opening an existing file
for write or deleting it actually renamed it in a predictable way
including a version number; only an explicit removal operation on a
version file actually erased data.
</p>
<p>
  Unix does without this, at a not inconsiderable cost in user
irritation when the wrong files get deleted through a typo or
unexpected effects of shell wildcarding.
</p>
<p>
  There does not seem to be any foreseeable prospect that this will
change at the operating system level.  Unix developers like clear, simple
operations that do what the user tells them to do, even if the user's
instructions could amount to commanding “shoot me in the
foot”.  Their instinct is to say that protecting the user
from himself should be done at the GUI or application level, not
in the operating system.
</p>
<h4 id="id3015895"><a href="#id3015895">§</a>Unix Assumes a Static File System</h4>
<p>
  Unix has, in one sense, a very static model of the world.
Programs are implicitly assumed to run only briefly, so the
background of files and directories can be assumed static during their
execution.  There is no standard, well-established way to ask the
system to notify an application if and when a specified file or
directory changes.  This becomes a significant issue when writing
long-lived user-interface software which wants to know about changes
to the background.
</p>
<p>
  Linux has file- and directory-change notification
features,<sup><a href="#ftn.id3015918" id="id3015918">[156]</a></sup>
  and some versions of BSD have copied them, but
these are not yet portable to other Unixes.
</p>
<h4 id="id3015943"><a href="#id3015943">§</a>The Design of Job Control Was Badly Botched</h4>
<p>
  Apart from the ability to suspend processes (in itself a
trivial addition to the scheduler which could be made fairly
inoffensive) what job control is about is switching a
terminal among multiple processes.  Unfortunately, it does the easiest
part — deciding where keystrokes go — and punts all the
hard parts, like saving and restoring the state of the screen, to the
application.
</p>
<p>
  A really good implementation of such a facility would be
completely invisible to user processes: no dedicated signals, no need
to save and restore terminal modes, no need for the applications to
redraw the screen at random times.  The model ought to be a virtual
keyboard that is sometimes connected to the real one (and blocks you
if you ask for input when it isn't connected) and a virtual screen
which is sometimes visible on the real one (and might or might not
block on output when it's not), with the system doing the multiplexing
in the same way it multiplexes access to the disk, the processor,
etc... and no impact on user programs at all.<sup><a href="#ftn.id3015976" id="id3015976">[157]</a></sup>
</p>
<p>
  Doing it right would have required the Unix tty driver to track
the entire current screen state rather than just maintaining a line
buffer, and to know about terminal types at kernel level (possibly
with help from a daemon process) so it could do restores properly when
a suspended process is foregrounded again.  A consequence of doing it
wrong is that the Unix kernel can't detach a session, such as an
  <em>xterm</em> or
  <em>Emacs</em> job, from one terminal and re-attach it to another (which could be of
a different type).
</p>
<p>
  As Unix usage has shifted to X displays and terminal emulators,
job control has become relatively less important, and this issue does
not have quite the force it once did.  It is still annoying that there
is no suspend/attach/detach, however; this feature could be useful for
saving the state of terminal sessions between logins.
</p>
<p>
  A common open-source program called
screen(1)
solves several of these problems.<sup><a href="#ftn.id3016047" id="id3016047">[158]</a></sup>
  However, since it has to be called explicitly by the user, its
facilities are not guaranteed to be present in every terminal session;
also, the kernel-level code that overlaps with it in function has not been
removed.
</p>
<h4 id="id3016077"><a href="#id3016077">§</a>The Unix API Doesn't Use Exceptions</h4>
<p>
  C lacks a facility for throwing named exceptions with attached
data.<sup><a href="#ftn.id3016087" id="id3016087">[159]</a></sup>
  Thus, the C functions in the Unix API
indicate errors by returning a distinguished value (usually −1 or a
NULL character pointer) and setting a global errno variable.
</p>
<p>
  In retrospect, this is the source of many subtle errors.
Programmers in a hurry often neglect to check return values.  Because
no exception is thrown, the Rule of Repair is violated; program flow
continues until the error condition manifests as some kind of failure
or data corruption later in execution.
</p>
<p>
  The absence of exceptions also means that some tasks which ought 
to be simple idioms — like aborting from a signal handler on a
version with Berkeley-style signals — have to be performed with
code that is complex, subject to portability glitches, and bug-prone.
</p>
<p>
  This problem can be (and normally is) hidden by bindings of the
Unix API in languages such as Python or Java that have exceptions.
</p>
<p>
  The lack of exceptions is actually an indicator of a problem
with larger immediate implications; C's weak type ontology
makes communication between higher-level languages implemented in
it problematic.  Most of the more modern languages, for example, have 
lists and dictionaries as primary data types — but, because
these don't have any canonical representation in the universe of C, 
attempting to pass lists between (say) Perl and Python is an unnatural
act requiring a lot of glue.
</p>
<p>
  There are technologies that address the larger problem, such as CORBA,
but they tend to involve a lot of runtime translation and be
unpleasantly heavyweight.
</p>
<h4 id="id3016155"><a href="#id3016155">§</a>ioctl(2) and fcntl(2) Are an Embarrassment</h4>
<p>
  The ioctl(2) and fcntl(2) mechanisms provide a way to write
hooks into a device driver.  The original, historical use of ioctl(2)
was to set parameters like baud rate and number of framing bits in a
serial-communications driver, thus the name (for ‘I/O
control’).  Later, ioctl calls were added for other driver
functions, and fcntl(2) was added as a hook into the
file system.
</p>
<p>
  Over the years,
  <code>ioctl</code> and
  <code>fcntl</code> calls have proliferated.  They are
often poorly documented, and often a source of portability problems as
well.  With each one comes a grubby pile of macro definitions
describing operation types and special argument values.
</p>
<p>
  The underlying problem is the same as ‘big bag of
bytes’; Unix's object model is weak, leaving no natural places
to put many auxiliary operations.  Designers have an untidy choice
among unsatisfactory alternatives;
  <code>fcntl</code> /
  <code>ioctl</code> going
through devices in
  <code>/dev</code>, new
special-purpose system calls, or hooks through special-purpose virtual
file systems that hook into the kernel (e.g.
  <code>/proc</code> under Linux and elsewhere).
</p>
<p>
  It is not clear whether or how Unix's object model will be
enriched in the future.  If MacOS-like file attributes become a common
feature of Unix, tweaking magic named attributes on device drivers may
take over the role
  <code>ioctl</code> /
  <code>fcntl</code> now have (this would at least have the
merit of not requiring piles of macro definitions before the interface
could be used).  We've already seen that Plan 9, which uses the named
file server or file system as its basic object, rather than the
file/bytestream, presents another possible path.
</p>
<h4 id="id3019078"><a href="#id3019078">§</a>The Unix Security Model May Be Too Primitive</h4>
<p>
  Perhaps root is too powerful, and Unix should have finer-grained
capabilities or ACLs (Access Control Lists) for system-administration
functions, rather than one superuser that can do anything.  People who
take this position argue that too many system programs have permanent
root privileges through the set-user-ID mechanism; if even one can be
compromised, intrusions everywhere will follow.
</p>
<p>
  This argument is weak, however.  Modern Unixes allow any given
user account to belong to multiple security groups.  Through use of
the execute-permission and set-group-ID bits on program executables,
each group can in effect function as an ACL for files or programs.
</p>
<p>
  This theoretical possibility is very little used, however,
suggesting that the demand for ACLs is much less in practice than it
is in theory.
</p>
<h4 id="id3019113"><a href="#id3019113">§</a>Unix Has Too Many Different Kinds of Names</h4>
<p>
  Unix unified files and local devices — they're all just
byte streams.  But network devices accessed through sockets have
different semantics in a different namespace.  Plan 9
  demonstrates that
files can be smoothly unified with both local and remote (network)
devices, and all of these things can be managed through a namespace
that is dynamically adjustable per-user and even per-program.
</p>
<h4 id="id3019140"><a href="#id3019140">§</a>File Systems Might Be Considered Harmful</h4>
<p>
  Was having a file system at all the wrong thing? Since the late
1970s there has been an intriguing history of research into persistent
object stores and operating systems that don't have a shared global
file system at all, but rather treat disk storage as a huge swap area
and do everything through virtualized object pointers.
</p>
<p>
  Modern efforts in this line (such as
EROS<sup><a href="#ftn.id3019167" id="id3019167">[160]</a></sup>) hint that such designs can offer large benefits including
both provable conformance to a security policy and higher
performance.  It must be noted, however, that if this is a failure of Unix,
it is equally a failure of all of its competitors; no major
production operating system has yet followed EROS's
lead.<sup><a href="#ftn.id3019184" id="id3019184">[161]</a></sup>
</p>
<h4 id="id3019193"><a href="#id3019193">§</a>Towards a Global Internet Address Space</h4>
<p>
  Perhaps URLs don't go far enough.  We'll leave the last word
on possible future directions of Unix to Unix's inventor:
</p>
 <blockquote>
  <p>
   My ideal for the future is to develop a file system remote interface
(a la Plan 9) and then have it implemented across the Internet as the
standard rather than HTML.  That would be ultimate cool.
  </p>
  <span>– Ken Thompson</span>
 </blockquote>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id3015918" id="ftn.id3015918">[156]</a></sup>
  Look for
  <code>F_NOTIFY</code> under
fcntl(2).
</p>

<p><sup><a href="#id3015976" id="ftn.id3015976">[157]</a></sup>
  This
paragraph is based on a 1984 analysis by Henry Spencer.  He went on to
note that job control was necessary and appropriate for POSIX.1 and
later Unix standards to consider precisely
  <span class="emphasis">
   <em>because</em>
  </span>
  it oozes its way into every program, and
hence has to be thought about in any application-to-system interface.
Hence, POSIX's endorsement of a mis-design, while proper solutions were
“out of scope” and hence were not even
considered.
</p>

<p><sup><a href="#id3016047" id="ftn.id3016047">[158]</a></sup>
  There is a
project site for
screen(1)
at
  <a href="http://www.math.fu-berlin.de/~guckes/screen/">
   http://www.math.fu-berlin.de/~guckes/screen/</a>.
</p>

<p><sup><a href="#id3016087" id="ftn.id3016087">[159]</a></sup>
  For nonprogrammers,
  <em>throwing an exception</em>
  is a way for a program to bail out in the middle
of a procedure. It's not quite an exit because the throw can be
intercepted by catcher code in an enclosing procedure.  Exceptions are
normally used to signal errors or unexpected conditions that mean it
would be pointless to try to continue normal
processing.
</p>

<p><sup><a href="#id3019167" id="ftn.id3019167">[160]</a></sup>
  <a href="http://www.eros-os.org/">
   http://www.eros-os.org/</a>
</p>

<p><sup><a href="#id3019184" id="ftn.id3019184">[161]</a></sup>
  The operating systems of the Apple Newton, the
AS/400 minicomputer and the Palm handheld could be considered
exceptions.
</p>
</div>


<!-- FILE: ch20s04.html -->
<h3 id="ch20s04"><a href="#ch20s04">§</a>Problems in the Environment of Unix</h3>
<p>
  The old-time Unix culture has largely reinvented itself in the 
open-source movement.  Doing so saved us from extinction, but it also
means that the problems of open source are now ours as well.
</p>
<p>
  One of these is how to make open-source development economically
sustainable.  We have reconnected with our roots in the collaborative,
open process of Unix's early days.  We have largely won the technical
argument for abandoning secrecy and proprietary control.  We have
thought of ways to cooperate with markets and managers on more equal
terms than we ever could in the 1970s and 1980s, and in many ways our
experiments have succeeded.  In 2003 the open-source Unixes, and their
core development groups, have achieved a degree of mainstream
respectability and authority that would have been unimaginable as
recently as the mid-1990s.
</p>
<p>
  We have come a long way.  But we have a long way to go yet.  We
know what business models might work in theory, and now we can even
point at a sporadic handful of successes that demonstrate that they
work in practice; now we have to show that they can be made to work
reliably over a longer term.
</p>
<p>
  It's not necessarily going to be an easy transition.  Open
source turns software into a service industry.  Service-provider firms
(think of medical and legal practices) can't be scaled up by injecting
more capital into them; those that try only scale up their fixed
costs, overshoot their revenue base, and starve to death.  The choices
come down to singing for your supper (getting paid through tips and
donations), running a corner shop (a small, low-overhead service
business), or finding a wealthy patron (some large firm that needs to
use and modify open-source software for its business purposes).
</p>
<p>
  In total, the amount of money spent to hire software developers
can be expected to rise, for the same reasons that mechanics' hourly
wages go up as the price of automobiles drops.<sup><a href="#ftn.id3019301" id="id3019301">[162]</a></sup>
  But it is going to become
more difficult for any one individual or firm to capture a lot of that
spending.  There will be many programmers who are well off, but
fewer millionaires. This is actually a sign of progress, of
inefficiencies being competed out of the system.  But it will
represent a big change in climate, and probably means that investors
will lose what little interest they have left in funding software
startups.
</p>
<p>
  One important subproblem related to the increasing difficulty
of sustaining really large software businesses is how to organize
end-user testing.  Historically, the Unix culture's concentration on
infrastructure has meant that we have not tended to build programs
that depended for their value on providing a comfortable interface for
end-users.  Now, especially in the open-source Unixes that aim to
compete directly with
Microsoft
  and
Apple, that is changing.  But end-user interfaces need to be
systematically tested with real end users — and therein lie some
challenges.
</p>
<p>
  Real end-user testing demands facilities, specialists, and a
level of monitoring that are difficult for the distributed volunteer
groups characteristic of open-source development to arrange.  It may
be, therefore, that open-source word processors, spreadsheets, and
other ‘productivity’ applications have to be left in the
hands of large corporate-sponsored efforts like OpenOffice.org that
can afford the overhead.  Open-source developers consider single
corporations to be single points of failure and worry about such
dependencies, but no better solution has yet evolved.
</p>
<p>
  These are economic problems.  We have other problems of a more
political nature, because success makes enemies.
</p>
<p>
  Some are familiar.
Microsoft's
  ambition for an unchallengeable monopoly lock on computing made the
defeat of Unix a strategic goal for the company in the mid-1980s, five
years before we knew we were in a fight.  In mid-2003, despite
having had several growth markets it was counting on largely usurped
by Linux, Microsoft is still the wealthiest and
most powerful software company in the world.  Microsoft knows very
well that it must defeat the new-school Unixes of the open-source
movement to survive.  To defeat them, it must destroy or discredit the
culture that produced them.
</p>
<p>
  Unix's comeback in the hands of the open-source community, and
its association with the freewheeling culture of the Internet, has
made it newer enemies as well.  Hollywood and Big Media feel deeply
threatened by the Internet and have launched a multipronged attack on
uncontrolled software development.  Existing legislation like the
Digital Millennium Copyright Act has already been used to prosecute
software developers who were doing things the media moguls disliked
(the most notorious cases, of course, involve the DeCSS software that
enables playing of encrypted DVDs).  Contemplated schemes like the
so-called Trusted Computing Platform Alliance and Palladium
threaten<sup><a href="#ftn.id3019418" id="id3019418">[163]</a></sup>
  to make open-source development
effectively illegal — and if open source goes down, Unix is very
likely to go down with it.
</p>
<p>
  Unix and the
hackers
  and the
Internet against
Microsoft
  and
Hollywood and Big Media.  It's a struggle we need to win for all our
traditional reasons of professionalism, allegiance to our craft, and
mutual tribal loyalty.  But there are larger reasons this struggle is
important.  The possibilities of politics are increasingly shaped by
communication technology — who can use it, who can censor it,
who can control it.  Government and corporate control of the content
of the nets, and of what people can do with their computers, is a
severe long-term threat to political freedom.  The nightmare scenario
is one in which corporate monopolism and statist power-seeking, always
natural allies, feed back into each other and create rationales for
increasing regulation, repression, and criminalization of digital
speech. In opposing this, we are the warriors of liberty —
not merely our own liberty, but everyone else's as well.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id3019301" id="ftn.id3019301">[162]</a></sup>
  For a
more complete discussion of this effect, see
  <em>The Magic Cauldron</em>
  in <sup><a href="#Raymond01" title="[Raymond01]">[Raymond01]</a></sup>.
</p>

<p><sup><a href="#id3019418" id="ftn.id3019418">[163]</a></sup>
  See the
  <a href="http://www.cl.cam.ac.uk/~rja14/tcpa-faq.html">
   TCPA FAQ</a>
  for a rather hair-raising summary of the possibilities by a noted
security specialist.
</p>
</div>


<!-- FILE: ch20s05.html -->
<h3 id="ch20s05"><a href="#ch20s05">§</a>Problems in the Culture of Unix</h3>
<p>
  Just as important as the technical problems with Unix itself and
the challenges consequent on its success are the cultural problems of
the community around it.  There are at least two serious ones: a
lesser challenge of internal transition, and a greater one of
overcoming our historical elitism.
</p>
<p>
  The lesser challenge is that of friction between the old-school
Unix gurus and the new-school open-source crowd.  The success of
Linux, in particular, is not an
entirely comfortable phenomenon for a lot of older Unix programmers.
This is partly a generational problem.  The raucous energy,
naïvete and gleeful zealotry of the Linux kids sometimes grates
on elders who have been around since the 1970s and (often rightly)
consider themselves wiser.  It's only exacerbated by the fact that the
kids are succeeding where the elders failed.
</p>
<p>
  The greater problem of psychology only became clear to me
after spending three days at a Macintosh developer conference in 2000.
It was a very enlightening experience to be immersed in a programming
culture with assumptions diametrically opposed to those of the Unix
world.
</p>
<p>
  Macintosh programmers are all about the user experience.
They're architects and decorators.  They design from the outside in,
asking first “What kind of interaction do we want to
support?” and then building the application logic behind it to
meet the demands of the user-interface design.  This leads to programs
that are very pretty and infrastructure that is weak and rickety.  In
one notorious example, as late as Release 9 the MacOS memory manager
sometimes required the user to manually deallocate memory by manually
chucking out exited but still-resident programs.  Unix people are
viscerally revolted by this kind of mal-design; they don't understand
how Macintosh people could live with it.
</p>
<p>
  By contrast, Unix people are all about infrastructure.  We are
plumbers and stonemasons.  We design from the inside out, building
mighty engines to solve abstractly defined problems (like “How
do we get reliable packet-stream delivery from point A to point B over
unreliable hardware and links?”).  We then wrap thin and often
profoundly ugly interfaces around the engines.  The commands
date(1),
find(1),
and
ed(1)
are notorious examples, but there are hundreds of others.  Macintosh
people are viscerally revolted by this kind of mal-design; they don't
understand how Unix people can live with it.
</p>
<p>
  Both design philosophies have some validity, but the two camps
have a great deal of difficulty seeing each other's points. The
typical Unix developer's reflex is to dismiss Macintosh software as
gaudy fluff, eye-candy for the ignorant, and to continue
building software that appeals to other Unix developers. If end-users
don't like it, so much the worse for the end users; they will come
around when they get a clue.
</p>
<p>
  In many ways this kind of parochialism has served us well.  We
are the keepers of the Internet and the World Wide Web.  Our software
and our traditions dominate serious computing, the applications where
24/7 reliability and minimal downtime is a must.  We really are
extremely good at building solid infrastructure; not perfect by any
means, but there is no other software technical culture that has
anywhere close to our track record, and it is one to be proud
of.
</p>
<p>
  The problem is that we increasingly face challenges that demand
a more inclusive view.  Most of the computers in the world don't live
in server rooms, but rather in the hands of those end users.  In early
Unix days, before personal computers, our culture defined itself
partly as a revolt against the priesthood of the mainframes, the
keepers of the big iron.  Later, we absorbed the power-to-the-people
idealism of the early microcomputer enthusiasts.  But today
  <em>we</em>
  are the priesthood;
  <em>we</em>
  are the people who run the networks and the big iron.  And our
implicit demand is that if you want to use our software, you must
learn to think like us.
</p>
<p>
  In 2003, there is a deep ambivalence in our attitude — a
tension between elitism and missionary populism.  We want to reach and
convert the 92% of the world for whom computing means games and
multimedia and glossy GUI interfaces and (at their most technical)
light email and word processing and spreadsheets.  We are spending
major effort on projects like GNOME and KDE designed to give Unix a
pretty face.  But we are still elitists at heart, deeply reluctant and
in many cases unable to identify with or listen to the needs of the
Aunt Tillies of the world.
</p>
<p>
  To non-technical end users, the software we build tends to be
either bewildering and incomprehensible, or clumsy and condescending,
or both at the same time.  Even when we try to do the
user-friendliness thing as earnestly as possible, we're woefully
inconsistent at it.  Many of the attitudes and reflexes we've
inherited from old-school Unix are just wrong for the job.  Even when
we want to listen to and help Aunt Tillie, we don't know how —
we project our categories and our concerns onto her and give her
‘solutions’ that she finds as daunting as her
problems.
</p>
<p>
  Our greatest challenge as a culture is whether we can outgrow
the assumptions that have served us so well — whether we can
acknowledge, not merely intellectually but in the sinew of daily
practice, that the Macintosh people have a point.  Their point is made
in more general, less Mac-specific way in
  <em>The Inmates Are Running the Asylum</em><sup><a href="#Cooper" title="[Cooper]">[Cooper]</a></sup>, an insightful and argumentative
book about what its author calls
  <em>interaction design</em>
  that (despite occasional crotchets) contains a good
deal of hard truth that every Unix programmer ought to know.
</p>
<p>
  We can turn aside from this; we can remain a priesthood
appealing to a select minority of the best and brightest, a geek
meritocracy focused on our historical role as the keepers of the
software infrastructure and the networks.  But if we do this, we will
very likely go into decline and eventually lose the dynamism that has
sustained us through decades.  Someone else will serve the people;
someone else will put themselves where the power and the money are, and
own the future of 92% of all software. The odds are, whether that
someone else is
Microsoft
  or not,
that they will do it using practices and software we don't much
like.
</p>
<p>
  Or we can truly accept the challenge.  The open-source movement
is trying hard to do so.  But the kind of sustained work and
intelligence we have brought to other problems in the past will not
alone suffice.  Our attitudes must change in a fundamental and
difficult way.
</p>
<p>
  In
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>
  we
discussed the importance of throwing away limiting assumptions and
discarding the past in solving technical problems, suggesting a
parallel with the Zen ideas of detachment and ‘beginner's
mind’.  We have a larger kind of detachment to work on now.  We
must learn humility before Aunt Tillie, and relinquish some of the
long-held prejudices that have made us so successful in the
past.
</p>
<p>
  Tellingly, the Macintosh culture has begun to converge with ours
— MacOS X has Unix underneath, and in 2003 Mac developers
are (albeit with a struggle in some cases) making the mental 
adjustment to learn the infrastructure-focused virtues of Unix.
Our challenge will be, reciprocally, to embrace the user-centered
virtues of the Macintosh.
</p>
<p>
  There are other signs that the Unix culture is shedding its
insularity as well.  One is the convergence that seems to be going on
between the Unix/open-source community and the movement called
“agile programming”.<sup><a href="#ftn.id3019774" id="id3019774">[164]</a></sup>
  We noted in
  <a href="#modularitychapter" title="Chapter 4. Modularity">
   Chapter 4</a>
  that Unix programmers have seized happily
on the concept of refactoring, one of the preoccupations of the
agile-programming thinkers.  Refactoring, and other agile concepts
like unit-testing and design around stories, seem to articulate and
sharpen practices that have heretofore been widespread but only
implicit in the Unix tradition. The Unix tradition, on the other hand,
can bring groundedness and the lessons of long experience to the
agile-programming party.  As open-source software gains market share
it is even conceivable that these cultures will fuse, much as the
old-time Internet and early Unix cultures did after 1980.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id3019774" id="ftn.id3019774">[164]</a></sup>
  For an introduction
to agile programming, see the
  <a href="http://agilemanifesto.org/">
   Agile
Manifesto</a>
</p>
</div>


<!-- FILE: ch20s06.html -->
<h3 id="ch20s06"><a href="#ch20s06">§</a>Reasons to Believe</h3>
<p>
  The future of Unix is full of difficult problems.  Would we
truly want it any other way?
</p>
<p>
  For more than thirty years we have thrived on challenges.  We
pioneered the best practices of software engineering. We created
today's Internet and Web.  We have built the largest, most complex,
and most reliable software systems ever to exist.  We outlasted the
IBM
  monopoly and we're
making a run against the
Microsoft
  monopoly
that is good enough to deeply frighten it.
</p>
<p>
  Not that everything has been triumph by any means.  In the 1980s
we nearly destroyed ourselves by acceding to the proprietary capture
of Unix.  We neglected the low end, the nontechnical end users, for
far too long and thereby left
Microsoft
  an
opening to grossly lower the quality standards of software.
Intelligent observers have pronounced our technology, our community,
and our values to be dead any number of times.
</p>
<p>
  But always we have come storming back.  We make mistakes, but we
learn from our mistakes.  We have transmitted our culture across
generations; we have absorbed much of what was best from the early
academic hackers
  and
the ARPANET experimenters and the microcomputer enthusiasts and a
number of other cultures.  The open-source movement has resurrected
the vigor and idealism of our early years, and today we are stronger
and more numerous than we have ever been.
</p>
<p>
  So far, betting against the Unix hackers has always been
short-term smart but long-term stupid.  We can prevail — if we
choose to.
</p>



<!-- FILE: apa.html -->
<h3 id="apa"><a href="#apa">§</a>Appendix A. Glossary of Abbreviations</h3>
<p>The most important abbreviations and acronyms used in the main text are defined here.</p>

<dl>
    <dt>
     API
    </dt>
    <dd>
     <p>
      <em>Application Programming Interface.</em>
      The
   set of procedure calls that communicates with a linkable procedure
   library or an operating-system kernel or the combination of
   both.
     </p>
    </dd>
    <dt>
     BSD
    </dt>
    <dd>
     <p>
	  <em>Berkeley System Distribution</em>; also <em>Berkeley Software Distribution</em>; sources are ambiguous. The
	  generic name of the Unix distributions issued by the Computer Science Research Group at the University of
	  California at Berkeley between 1976 and 1994, and of the open-source Unixes genetically descended from them.
     </p>
    </dd>
    <dt>
     CLI
    </dt>
    <dd>
     <p>
      <em>Command Line Interface.</em>
      Considered
   archaic by some, but still very useful in the Unix world.
     </p>
    </dd>
    <dt>
     CPAN
    </dt>
    <dd>
     <p>
      <em>
       Comprehensive Perl
       Archive Network.
</em>
      The
   central
      <a href="http://cpan.org/">
       Web repository</a>
      for
   Perl modules and extensions.
     </p>
    </dd>
    <dt>
     GNU
    </dt>
    <dd>
     <p>
      <em>
       GNU's Not
   Unix!
</em>
      The recursive acronym for the Free Software
   Foundation's project to produce an entire free-software clone of
   Unix.  This effort didn't completely succeed, but did produce many of
   the essential tools of modern Unix development including Emacs and
   the GNU Compiler Collection.
     </p>
    </dd>
    <dt>
     GUI
    </dt>
    <dd>
     <p>
      <em>Graphical User Interface.</em>
      The modern
   style of application interface using mice, windows, and icons
   invented at Xerox PARC during the 1970s, as opposed to the older
   CLI or roguelike styles.
     </p>
    </dd>
    <dt>
     IDE
    </dt>
    <dd>
     <p>
      <em>Integrated Development Environment.</em>
      A GUI workbench for developing code, featuring facilities like
   symbolic debugging, version control, and data-structure browsing.
   These are not commonly used under Unix, for reasons discussed in
      <a href="#toolschapter" title="Chapter 15. Tools">
       Chapter 15</a>.
     </p>
    </dd>
    <dt>
     IETF
    </dt>
    <dd>
     <p>
      <em>Internet Engineering Task Force.</em>
      The
   entity responsible for defining Internet protocols such as
   TCP/IP. A loose, collegial organization mainly of technical
   people.
     </p>
    </dd>
    <dt>
     IPC
    </dt>
    <dd>
     <p>
      <em>Inter-Process Communication.</em>
      Any
   method of passing data between processes running in separate
   address spaces.
     </p>
    </dd>
    <dt>
     MIME
    </dt>
    <dd>
     <p>
      <em>Multipurpose Internet Mail Extensions.</em>
      A
   series of RFCs that describe standards for embedding binary and
   multipart messages within RFC-822 mail.  Besides being used for
   mail transport, MIME is used as an underlevel by important
   application protocols including HTTP and BEEP.
     </p>
    </dd>
    <dt>
     OO
    </dt>
    <dd>
     <p>
      <em>Object Oriented.</em>
      A style of programming
   that tries to encapsulate data to be manipulated and the code that
   manipulates it in (theoretically) sealed containers called objects.
   By contrast, non-object-oriented programming is more casual about
   exposing the internals of the data structure and code.
     </p>
    </dd>
    <dt>
     OS
    </dt>
    <dd>
     <p>
      <em>Operating System.</em>
      The foundation software of a
   machine; that which schedules tasks, allocates storage, and presents a
   default interface to the user between applications.  The facilities an
   operating system provides and its general design philosophy exert an
   extremely strong influence on programming style and on the technical
   cultures that grow up around its host machines.
     </p>
    </dd>
    <dt>
     PDF
    </dt>
    <dd>
     <p>
      <em>Portable Document Format.</em>
      The
   PostScript language for control of printers and other imaging
   devices is designed to be streamed to printers.  PDF is a sequence
   of PostScript pages, packaged with annotations so it can
   conveniently be used as a display format.
     </p>
    </dd>
    <dt>
     PDP-11
    </dt>
    <dd>
     <p>
      <em>Programmable Data Processor 11.</em>
      Possibly
   the single most successful minicomputer design in history; first
   shipped in 1970, last shipped in 1990, and the immediate ancestor
   of the VAX.  The PDP-11 was the first major Unix platform.
     </p>
    </dd>
    <dt>
     PNG
    </dt>
    <dd>
     <p>
      <em>Portable Network Graphics.</em>
      The World
   Wide Web Consortium's standard and recommended format for bitmap
   graphics images. An elegantly designed binary graphics format
   described in
      <a href="#textualitychapter" title="Chapter 5. Textuality">
       Chapter 5</a>.
     </p>
    </dd>
    <dt>
     RFC
    </dt>
    <dd>
     <p>
      <em>Request For Comment.</em>
      An Internet
   standard.  The name arose at a time when the documents were
   regarded as proposals to be submitted to a then-nonexistent 
   but anticipated formal approval process of some sort.  The
   formal approval process never materialized.
     </p>
    </dd>
    <dt>
     RPC
    </dt>
    <dd>
     <p>
      <em>Remote Procedure Call.</em>
      Use of
   IPC methods that attempt to create the illusion that the 
   processes exchanging them are running in the same address 
   space, so they can cheaply (a) share complex structures, and (b)
   call each other like function libraries, ignoring latency and other
   performance considerations.  This illusion is notoriously
   difficult to sustain.
     </p>
    </dd>
    <dt>
     TCP/IP
    </dt>
    <dd>
     <p>
      <em>
       Transmission Control Protocol/Internet
   Protocol.
</em>
      The basic protocol of the Internet since the
   conversion from NCP (Network Control Protocol) in 1983. Provides 
   reliable transport of data streams.
     </p>
    </dd>
    <dt>
     UDP/IP
    </dt>
    <dd>
     <p>
      <em>
       Universal Datagram Protocol/Internet
   Protocol.
</em>
      Provides unreliable but low-latency transport
   for small data packets.
     </p>
    </dd>
    <dt>
     UI
    </dt>
    <dd>
     <p>
      <em>User Interface.</em>
     </p>
    </dd>
    <dt>
     VAX
    </dt>
    <dd>
     <p>
      Formally,
      <em>Virtual Address Extension</em>
      :
   the name of a classic minicomputer design developed by Digital
   Equipment Corporation (later merged with Compaq, later merged with
   Hewlett-Packard) from the PDP-11. The
   first VAX shipped in 1977.  For ten years after 1980 VAXen were
   among the most important Unix platforms.  Microprocessor
   reimplementations are still shipping today.
     </p>
    </dd>
   </dl>



<!-- FILE: apb.html -->
<h3 id="apb"><a href="#apb">§</a>Appendix B. References</h3>
<p>
	Event timelines of the
	<a href="http://snap.nlc.dcccd.edu/learn/drkelly/hst-hand.htm">Unix Industry</a>
	and of <a href="http://www.robotwisdom.com/linux/timeline.html">GNU/Linux and Unix</a>
	are available on the Web.  A timeline tree of <a href="http://www.levenez.com/unix/">Unix releases</a> is also available.
</p>

<h3 id="id3020425"><a href="#id3020425">§</a>Bibliography</h3>
<ul>
	<li id="Appleton">
		<sup>[Appleton]</sup>
		<span class="author">Randy Appleton.</span>
		<em class="title">Improving Context Switching Performance of Idle Tasks under Linux</em>.
		<span class="date">2001.</span>
		<a href="http://cs.nmu.edu/~randy/Research/Papers/Scheduler/">Available on the Web</a>.
	</li>
	<li id="Baldwin-Clark">
		<sup>[Baldwin-Clark]</sup>
		<span class="author">Carliss Baldwin and Kim Clark.</span>
		<em class="title">Design Rules, Vol 1: The Power of Modularity.</em>
		<span class="date">2000.</span>
		<span class="publisher">MIT Press.</span>
		<span class="isbn">ISBN 0-262-024667.</span>
	</li>
	<li id="Bentley">
		<sup>[Bentley]</sup>
		<span class="author">Jon Bentley.</span>
		<em class="title">Programming Pearls.</em>
		<span class="edition">2nd Edition.</span>
		<span class="date">2000.</span>
		<span class="publisher">Addison-Wesley.</span>
		<span class="isbn">ISBN 0-201-65788-0.</span>
		The third essay in this book, “Data Structures Programs”, argues a case similar to that of
		<a href="#generationchapter" title="Chapter 9. Generation"> Chapter 9</a> with
		Bentley's characteristic eloquence.  Some of the book is
		<a href="http://www.cs.bell-labs.com/cm/cs/pearls/"> available on the Web</a>.
	</li>
	<li id="BlaauwBrooks">
		<sup>[BlaauwBrooks]</sup>
		<span class="author">Gerrit A. Blaauw and Frederick P. Brooks.</span>
		<em class="title">Computer Architecture: Concepts and Evolution.</em>
		<span class="date">1997.</span>
		<span class="isbn">ISBN 0-201-10557-8.</span>
		<span class="publisher">Addison-Wesley.</span>
	</li>
	<li id="Bolinger-Bronson">
		<sup>[Bolinger-Bronson]</sup>
		<span class="author">Dan Bolinger and Tan Bronson.</span>
		<em class="title">Applying RCS and SCCS.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">1995.</span>
		<span class="isbn">ISBN 1-56592-117-8.</span>
		Not just a cookbook, this also surveys the design issues in version-control systems.
	</li>
	<li id="Brokken">
		<sup>[Brokken]</sup>
		<span class="author">Frank Brokken.</span>
		<em class="title">C++ Annotations Version.</em>
		<span class="date">2002.</span>
		<a href="http://www.icce.rug.nl/documents/cplusplus/cplusplus.html">Available on the Web</a>.
	</li>
	<li id="BrooksD">
		<sup>[BrooksD]</sup>
		<span class="author">David Brooks.</span>
		<em class="title">Converting a UNIX .COM Site to Windows.</em>
		<span class="date">2000.</span>
		<a href="http://www.securityoffice.net/mssecrets/hotmail.html#_Toc491601819">Available on the Web</a>.
	</li>
	<li id="Brooks">
		<sup>[Brooks]</sup>
		<span class="author">Frederick P. Brooks.</span>
		<em class="title">The Mythical Man-Month.</em>
		<span class="edition">20th Anniversary Edition.</span>
		<span class="publisher">Addison-Wesley.</span>
		<span class="date">1995.</span>
		<span class="isbn">ISBN 0-201-83595-9.</span>
	</li>
	<li id="Boehm">
		<sup>[Boehm]</sup>
		<span class="author">Hans Boehm.</span>
		<em class="title">Advantages and Disadvantages of Conservative Garbage Collection.</em>
		Thorough discussion of tradeoffs between garbage-collected and non-garbage-collected environments.
		<a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/issues.html">Available on the Web</a>.
	</li>
	<li id="Cameron">
		<sup>[Cameron]</sup>
		<span class="author">Debra Cameron, Bill Rosenblatt, and Eric Raymond.</span>
		<em class="title">Learning GNU Emacs.</em>
		<span class="edition">2nd Edition.</span>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">1996.</span>
		<span class="isbn">ISBN 1-56592-152-6.</span>
	</li>
	<li id="Cannon">
		<sup>[Cannon]</sup>
		<span class="author">L. W. Cannon, R. A. Elliot, L. W. Kirchhoff, J. A. Miller, J. M. Milner, R. W. Mitzw, E. P. Schan, N. O. Whittington, Henry Spencer, David Keppel, and Mark Brader.</span>
		<em class="title">Recommended C Style and Coding Standards.</em>
		<span class="date">1990.</span>
		An updated version of the <em>Indian Hill C Style and Coding Standards</em> paper, with modifications by the last
		three authors. It describes a recommended coding standard for C programs.
		<a href="http://www.apocalypse.org/pub/u/paul/docs/cstyle/cstyle.htm">Available on the Web</a>.
	</li>
	<li id="Christensen">
		<sup>[Christensen]</sup>
		<span class="author">Clayton Christensen.</span>
		<em class="title">The Innovator's Dilemma.</em>
		<span class="publisher">HarperBusiness.</span>
		<span class="date">2000.</span>
		<span class="isbn">ISBN 0-066-62069-4.</span>
		The book that introduced the term “disruptive technology”.  A fascinating and lucid examination of how and why
		technology companies doing everything right get mugged by upstarts.  A business book technical people should read.
	</li>
	<li id="Comer">
		<sup>[Comer]</sup>
		<span class="biblioset">
		<em>Unix Review</em>.
		</span>
		<span class="biblioset">
		<span class="author">Douglas Comer.</span>
		“Pervasive Unix: Cause for Celebration”.
		<span class="date">October 1985.</span>
		<span class="pagenums">
		p. 42.
		</span>
		</span>
	</li>
	<li id="Cooper">
		<sup>[Cooper]</sup>
		<span class="author">Alan Cooper.</span>
		<em class="title">The Inmates Are Running the Asylum.</em>
		<span class="publisher">Sams.</span>
		<span class="date">1999.</span>
		<span class="isbn">ISBN 0-672-31649-8.</span>
		Despite some occasional quirks and crotchets, this 
		book is a trenchant and brilliant analysis of what's wrong with 
		software interface designs, and how to put it right.
	</li>
	<li id="Coram-Lee">
		<sup>[Coram-Lee]</sup>
		<span class="author">Tod Coram and Ji Lee.</span>
		<em class="title">Experiences — A Pattern Language for User Interface Design.</em>
		<span class="date">1996.</span>
		<a href="http://www.maplefish.com/todd/papers/Experiences.html">Available on the Web</a>.
	</li>
	<li id="DuBois">
		<sup>[DuBois]</sup>
		<span class="author">Paul DuBois.</span>
		<em class="title">Software Portability with Imake.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">1993.</span>
		<span class="isbn">ISBN 1-56592-055-4.</span>
	</li>
	<li id="Eckel">
		<sup>[Eckel]</sup>
		<span class="author">Bruce Eckel.</span>
		<em class="title">Thinking in Java.</em>
		<span class="edition">3rd Edition.</span>
		<span class="publisher">Prentice-Hall.</span>
		<span class="date">2003.</span>
		<span class="isbn">ISBN 0-13-100287-2.</span>
		<a href="http://www.mindview.net/Books/TIJ/">Available on the Web</a>.
	</li>
	<li id="Feller-Fitzgerald">
		<sup>[Feller-Fitzgerald]</sup>
		<span class="author">Joseph Feller and Brian Fitzgerald.</span>
		<em class="title">Understanding Open Source Software.</em>
		<span class="date">2002.</span>
		<span class="isbn">ISBN 0-201-73496-6.</span>
		<span class="publisher">Addison-Wesley.</span>
	</li>
	<li id="FlanaganJava">
		<sup>[FlanaganJava]</sup>
		<span class="author">David Flanagan.</span>
		<em class="title">Java in a Nutshell.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">1997.</span>
		<span class="isbn">ISBN 1-56592-262-X.</span>
	</li>
	<li id="FlanaganJavaScript">
		<sup>[FlanaganJavaScript]</sup>
		<span class="author">David Flanagan.</span>
		<em class="title">JavaScript: The Definitive Guide.</em>
		<span class="edition">4th Edition.</span>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">2002.</span>
		<span class="isbn">ISBN 1-596-00048-0.</span>
	</li>
	<li id="Fowler">
		<sup>[Fowler]</sup>
		<span class="author">Martin Fowler.</span>
		<em class="title">Refactoring.</em>
		<span class="publisher">Addison-Wesley.</span>
		<span class="date">1999.</span>
		<span class="isbn">ISBN 0-201-48567-2.</span>
	</li>
	<li id="Friedl">
		<sup>[Friedl]</sup>
		<span class="author">Jeffrey Friedl.</span>
		<em class="title">Mastering Regular Expressions.</em>
		<span class="edition">2nd Edition.</span>
		<span class="date">2002.</span>
		<span class="isbn">ISBN  0-596-00289-0.</span>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="pagenums">
		484pp..
		</span>
	</li>
	<li id="Fuzz">
		<sup>[Fuzz]</sup>
		<span class="author">Barton Miller, David Koski, Cjin Pheow Lee, Vivekananda Maganty, Ravi Murthy, Ajitkumar Natarajan, and Jeff Steidl.</span>
		<em class="title">Fuzz Revisited: A Re-examination of the Reliability of Unix Utilities and Services.</em>
		<span class="date">2000.</span>
		<a href="http://www.opensource.org/advocacy/fuzz-revisited.pdf">Available on the Web</a>.
	</li>
	<li id="Gabriel">
		<sup>[Gabriel]</sup>
		<span class="author">Richard Gabriel.</span>
		<em class="title">Good News, Bad News, and How to Win Big.</em>
		<span class="date">1990.</span>
		<a href="http://www.dreamsongs.com/WorseIsBetter.html">Available on the Web</a>.
	</li>
	<li id="Gancarz">
		<sup>[Gancarz]</sup>
		<span class="author">Mike Gancarz.</span>
		<em class="title">The Unix Philosophy.</em>
		<span class="publisher">Digital Press.</span>
		<span class="date">1995.</span>
		<span class="isbn">ISBN 1-55558-123-4.</span>
	</li>
	<li id="GangOfFour">
		<sup>[GangOfFour]</sup>
		<span class="author">Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.</span>
		<em class="title">Design Patterns: Elements of Reusable Object-Oriented Software.</em>
		<span class="publisher">Addison-Wesley.</span>
		<span class="date">1997.</span>
		<span class="isbn">ISBN 0-201-63361-2.</span>
	</li>
	<li id="Garfinkel">
		<sup>[Garfinkel]</sup>
		<span class="author">Simson Garfinkel, Daniel Weise, and Steve Strassman.</span>
		<em class="title">The Unix Hater's Handbook.</em>
		<span class="publisher">IDG Books.</span>
		<span class="date">1994.</span>
		<span class="isbn">ISBN 1-56884-203-1.</span>
		<a href="http://research.microsoft.com/~daniel/unix-haters.html">Available on the Web</a>.
	</li>
	<li id="Gentner-Nielsen">
		<sup>[Gentner-Nielsen]</sup>
		<span class="biblioset">
		<em>Communications of the ACM</em>.
		<span class="publisher">Association for Computing Machinery.</span>
		</span>
		<span class="biblioset">
		<span class="author">Don Gentner and Jacob Nielsen.</span>
		“The Anti-Mac Interface”.
		<span class="date">August 1996.</span>
		<a href="http://www.acm.org/cacm/AUG96/antimac.htm">Available on the Web</a>.
		</span>
	</li>
	<li id="Gettys">
		<sup>[Gettys]</sup>
		<span class="author">Jim Gettys.</span>
		<em class="title">The Two-Edged Sword.</em>
		<span class="date">1998.</span>
		<a href="http://freshmeat.net/articles/view/122/">
		Available on the Web</a>.
	</li>
	<li id="Glickstein">
		<sup>[Glickstein]</sup>
		<span class="author">Bob Glickstein.</span>
		<em class="title">Writing GNU Emacs Extensions.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">1997.</span>
		<span class="isbn">ISBN 1-56592-261-1.</span>
	</li>
	<li id="Graham">
		<sup>[Graham]</sup>
		<span class="author">Paul Graham.</span>
		<em class="title">A Plan for Spam.</em>
		<a href="http://www.paulgraham.com/spam.html">Available on the Web</a>.
	</li>
	<li id="Harold-Means">
		<sup>[Harold-Means]</sup>
		<span class="author">Elliotte Rusty Harold and W. Scott Means.</span>
		<em class="title">XML in a Nutshell.</em>
		<span class="edition">2nd Edition.</span>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">2002.</span>
		<span class="isbn">ISBN 0-596-00292-0.</span>
	</li>
	<li id="Hatton97">
		<sup>[Hatton97]</sup>
		<span class="biblioset">
		<em>IEEE Software</em>.
		</span>
		<span class="biblioset">
		<span class="author">Les Hatton.</span>
		“Re-examining the Defect-Density versus Component Size Distribution”.
		<span class="date">March/April 1997.</span>
		<a href="http://www.cs.ukc.ac.uk/people/staff/lh8/pubs/pubis697/Ubend_IS697.pdf.gz">
			Available
		on the Web</a>.
		</span>
	</li>
	<li id="Hatton98">
		<sup>[Hatton98]</sup>
		<span class="biblioset">
		<em>IEEE Software</em>.
		</span>
		<span class="biblioset">
		<span class="author">Les Hatton.</span>
		“Does OO Sync with the Way We Think?”.
		<span class="volumenum">
		15.
		</span>
		<span class="issuenum">
		(3).
		</span>
		<a href="http://www.cs.ukc.ac.uk/people/staff/lh8/pubs/pubis698/OO_IS698.pdf.gz">
			Available
		on the Web</a>.
		</span>
	</li>
	<li id="Hauben">
		<sup>[Hauben]</sup>
		<span class="author">Ronda Hauben.</span>
		<em class="title">History of UNIX.</em>
		<a href="http://www.dei.isep.ipp.pt/docs/unix.html">
		Available on the Web</a>.
	</li>
	<li id="Heller">
		<sup>[Heller]</sup>
		<span class="author">Steve Heller.</span>
		<em class="title">C++: A Dialog.</em>
		<span class="subtitle">
		Programming with the C++ Standard Library.
		</span>
		<span class="publisher">Prentice-Hall.</span>
		<span class="date">2003.</span>
		<span class="isbn">ISBN 0-13-009402-1.</span>
	</li>
	<li id="Hunt-Thomas">
		<sup>[Hunt-Thomas]</sup>
		<span class="author">Andrew Hunt and David Thomas.</span>
		<em class="title">The Pragmatic Programmer: From Journeyman to Master.</em>
		<span class="publisher">Addison-Wesley.</span>
		<span class="date">2000.</span>
		<span class="isbn">ISBN 0-201-61622-X.</span>
	</li>
	<li id="Kernighan95">
		<sup>[Kernighan95]</sup>
		<span class="author">Brian Kernighan.</span>
		<em class="title">Experience with Tcl/Tk for Scientific and Engineering Visualization.</em>
		<span class="publisher">USENIX Association Tcl/Tk Workshop Proceedings.</span>
		<span class="date">1995.</span>
		<a href="http://www.usenix.org/publications/library/proceedings/tcl95/full_papers/kernighan.txt">
		Available
		on the Web</a>.
	</li>
	<li id="Kernighan-Pike84">
		<sup>[Kernighan-Pike84]</sup>
		<span class="author">Brian Kernighan and Rob Pike.</span>
		<em class="title">The Unix Programming Environment.</em>
		<span class="publisher">Prentice-Hall.</span>
		<span class="date">1984.</span>
		<span class="isbn">ISBN 0-13-937681-X.</span>
	</li>
	<li id="Kernighan-Pike99">
		<sup>[Kernighan-Pike99]</sup>
		<span class="author">Brian Kernighan and Rob Pike.</span>
		<em class="title">The Practice of Programming.</em>
		<span class="date">1999.</span>
		<span class="isbn">ISBN 0-201-61586-X.</span>
		<span class="publisher">Addison-Wesley.</span>
		An excellent treatise on writing high-quality programs,
		surely destined to become a classic of the field.
	</li>
	<li id="Kernighan-Plauger">
		<sup>[Kernighan-Plauger]</sup>
		<span class="author">Brian Kernighan and P. J. Plauger.</span>
		<em class="title">Software Tools.</em>
		<span class="publisher">Addison-Wesley.</span>
		<span class="date">1976.</span>
		<span class="isbn">ISBN 201-03669-X.</span>
	</li>
	<li id="Kernighan-Ritchie">
		<sup>[Kernighan-Ritchie]</sup>
		<span class="author">Brian Kernighan and Dennis Ritchie.</span>
		<em class="title">The C Programming Language.</em>
		<span class="edition">2nd Edition.</span>
		<span class="publisher">Prentice-Hall Software Series.</span>
		<span class="date">1988.</span>
		<span class="isbn">ISBN 0-13-110362-8.</span>
	</li>
	<li id="Lampson">
		<sup>[Lampson]</sup>
		<span class="biblioset">
		<em>ACM Operating Systems Review</em>.
		<span class="publisher">Association for Computing Machinery.</span>
		</span>
		<span class="biblioset">
		<span class="author">Butler Lampson.</span>
		“Hints for Computer System Design”.
		<span class="date">October 1983.</span>
		<a href="http://research.microsoft.com/~lampson/33-Hints/WebPage.html">
			Available
		on the Web</a>.
		</span>
	</li>
	<li id="Lapin">
		<sup>[Lapin]</sup>
		<span class="author">J. E. Lapin.</span>
		<em class="title">Portable C and Unix Systems Programming.</em>
		<span class="publisher">Prentice-Hall.</span>
		<span class="date">1987.</span>
		<span class="isbn">ISBN 0-13-686494-5.</span>
	</li>
	<li id="Leonard">
		<sup>[Leonard]</sup>
		<span class="author">Andrew Leonard.</span>
		<em class="title">BSD Unix: Power to the People, from the Code.</em>
		<span class="date">2000.</span>
		<a href="http://dir.salon.com/tech/fsp/2000/05/16/chapter_2_part_one/index.html">
		Available on the Web</a>.
	</li>
	<li id="Levy">
		<sup>[Levy]</sup>
		<span class="author">Steven Levy.</span>
		<em class="title">Hackers: Heroes of the Computer Revolution.</em>
		<span class="publisher">Anchor/Doubleday.</span>
		<span class="date">1984.</span>
		<span class="isbn">ISBN 0-385-19195-2.</span>
		<a href="http://www.stanford.edu/group/mmdd/SiliconValley/Levy/Hackers.1984.book/contents.html">
		Available on the Web</a>.
	</li>
	<li id="Lewine">
		<sup>[Lewine]</sup>
		<span class="author">Donald Lewine.</span>
		<em class="title">POSIX Programmer's Guide: Writing Portable Unix Programs.</em>
		<span class="date">1992.</span>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="isbn">ISBN 0-937175-73-0.</span>
		<span class="pagenums">
		607pp..
		</span>
	</li>
	<li id="Libes-Ressler">
		<sup>[Libes-Ressler]</sup>
		<span class="author">Don Libes and Sandy Ressler.</span>
		<em class="title">Life with Unix.</em>
		<span class="date">1989.</span>
		<span class="isbn">ISBN 0-13-536657-7.</span>
		<span class="publisher">Prentice-Hall.</span>
		This book gives a more detailed version of Unix's
		early history. It's particularly strong for the period
		1979–1986.
	</li>
	<li id="Lions">
		<sup>[Lions]</sup>
		<span class="author">John Lions.</span>
		<em class="title">Lions's Commentary on Unix 6th Edition.</em>
		<span class="date">1996.</span>
		<span class="isbn">1-57398-013-7.</span>
		<span class="publisher">Peer-To-Peer Communications.</span>
		PostScript rendering of Lions's original floats around 
		the Web.
		<a href="http://www.upl.cs.wisc.edu/~epaulson/lionc.ps">
		This URL may
		be unstable</a>.
	</li>
	<li id="Loukides-Oram">
		<sup>[Loukides-Oram]</sup>
		<span class="author">Mike Loukides and Andy Oram.</span>
		<em class="title">Programming with GNU Software.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">1996.</span>
		<span class="isbn">ISBN 1-56592-112-7.</span>
	</li>
	<li id="Lutz">
		<sup>[Lutz]</sup>
		<span class="author">Mark Lutz.</span>
		<em class="title">Programming Python.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">1996.</span>
		<span class="isbn">ISBN 1-56592-197-6.</span>
	</li>
	<li id="McIlroy78">
		<sup>[McIlroy78]</sup>
		<span class="biblioset">
		<em>The Bell System Technical Journal</em>.
		<span class="publisher">Bell Laboratories.</span>
		</span>
		<span class="biblioset">
		<span class="author">M. D. McIlroy, E. N. Pinson, and B. A. Tague.</span>
		“Unix Time-Sharing System Forward”.
		<span class="date">1978.</span>
		<span class="issuenum">
		57 (6, part 2).
		</span>
		<span class="pagenums">
		p. 1902.
		</span>
		</span>
	</li>
	<li id="McIlroy91">
		<sup>[McIlroy91]</sup>
		<span class="biblioset">
		<em>Proc. Virginia Computer Users Conference</em>.
		<span class="volumenum">
		Volume 21.
		</span>
		</span>
		<span class="biblioset">
		<span class="author">M. D. McIlroy.</span>
		“Unix on My Mind”.
		<span class="pagenums">
		p. 1-6.
		</span>
		</span>
	</li>
	<li id="Miller">
		<sup>[Miller]</sup>
		<span class="biblioset">
		<em>The Psychological Review</em>.
		</span>
		<span class="biblioset">
		<span class="author">George Miller.</span>
		“The Magical Number Seven, Plus or Minus Two”.
		<span class="subtitle">
		Some limits on our capacity for processing information.
		</span>
		<span class="date">1956.</span>
		<span class="issuenum">
		63.
		</span>
		<span class="pagenums">
		pp. 81-97.
		</span>
		<a href="http://www.well.com/user/smalin/miller.html">
			Available on the
		Web</a>.
		</span>
	</li>
	<li id="Mumon">
		<sup>[Mumon]</sup>
		<span class="author">Mumon.</span>
		<em class="title">The Gateless Gate.</em>
		<a href="http://www.ibiblio.org/zen/cgi-bin/koan-index.pl">
		A good modern translation is available on the Web</a>.
	</li>
	<li id="OpenSources">
		<sup>[OpenSources]</sup>
		<span class="author">Sam Ockman and Chris DiBona.</span>
		<em class="title">Open Sources: Voices from the Open Source Revolution.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">1999.</span>
		<span class="isbn">ISBN 1-56592-582-3.</span>
		<span class="pagenums">
		280pp..
		</span>
		<a href="http://www.oreilly.com/catalog/opensources/book/toc.html">
		Available on the Web</a>.
	</li>
	<li id="Oram-Talbot">
		<sup>[Oram-Talbot]</sup>
		<span class="author">Andrew Oram and Steve Talbot.</span>
		<em class="title">Managing Projects with Make.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">1991.</span>
		<span class="isbn">ISBN 0-937175-90-0.</span>
	</li>
	<li id="Ousterhout94">
		<sup>[Ousterhout94]</sup>
		<span class="author">John Ousterhout.</span>
		<em class="title">Tcl and the Tk Toolkit.</em>
		<span class="publisher">Addison-Wesley.</span>
		<span class="date">1994.</span>
		<span class="isbn">ISBN 0-201-63337-X.</span>
	</li>
	<li id="Ousterhout96">
		<sup>[Ousterhout96]</sup>
		<span class="author">John Ousterhout.</span>
		<em class="title">Why Threads Are a Bad Idea (for most purposes).</em>
		<span class="date">1996.</span>
		An invited talk at USENIX 1996. There is no written paper
		that corresponds to it, but the slide presentation is
		<a href="http://home.pacbell.net/ouster/threads.pdf">
		available on
		the Web</a>.
	</li>
	<li id="Padlipsky">
		<sup>[Padlipsky]</sup>
		<span class="author">Michael Padlipsky.</span>
		<em class="title">The Elements of Networking Style.</em>
		<span class="publisher">iUniverse.com.</span>
		<span class="date">2000.</span>
		<span class="isbn">ISBN 0-595-08879-1.</span>
	</li>
	<li id="Parnas">
		<sup>[Parnas]</sup>
		<span class="biblioset">
		<em>Communications of the ACM</em>.
		</span>
		<span class="biblioset">
		<span class="author">Parnas L. David.</span>
		“On the Criteria to Be Used in Decomposing Systems into Modules”.
		Available on the Web at the
		<a href="http://www.acm.org/classics/may96/">
			ACM Classics
		page</a>.
		</span>
	</li>
	<li id="Pike">
		<sup>[Pike]</sup>
		<span class="author">Rob Pike.</span>
		<em class="title">Notes on Programming in C.</em>
		This
		document is popular on the Web; a title search is sure to find
		several copies.
		<a href="http://www.lysator.liu.se/c/pikestyle.html">
		Here is one</a>.
	</li>
	<li id="Prechelt">
		<sup>[Prechelt]</sup>
		<span class="author">Lutz Prechelt.</span>
		<em class="title"><a href="http://www.ubka.uni-karlsruhe.de/cgi-bin/psview?document=ira/2000/5"> An Empirical Comparison of C, C++, Java, Perl, Python, Rexx, and Tcl for a Search/String-Processing Program </a>.</em>
	</li>
	<li id="Raskin">
		<sup>[Raskin]</sup>
		<span class="author">Jef Raskin.</span>
		<em class="title">The Humane Interface.</em>
		<span class="publisher">Addison-Wesley.</span>
		<span class="date">2000.</span>
		<span class="isbn">ISBN 0-201-37937-6.</span>
		A summary is
		<a href="http://humane.sourceforge.net/humane_interface/summary_of_thi.html">
		available
		on the Web</a>.
	</li>
	<li id="Ravenbrook">
		<sup>[Ravenbrook]</sup>
		<em class="title">The Memory Management Reference.</em>
		<a href="http://www.memorymanagement.org/">
		Available on
		the Web</a>.
	</li>
	<li id="Raymond96">
		<sup>[Raymond96]</sup>
		<span class="editor">
		Eric S. Raymond.
		</span>
		<em class="title">The New Hacker's Dictionary.</em>
		<span class="edition">3rd Edition.</span>
		<span class="date">1996.</span>
		<span class="isbn">ISBN 0-262-68092-0.</span>
		<span class="publisher">MIT Press.</span>
		<span class="pagenums">
		547pp..
		</span>
		Available on the Web at
		<a href="http://www.catb.org/~esr/jargon">
		Jargon File
		Resource Page</a>.
	</li>
	<li id="Raymond01">
		<sup>[Raymond01]</sup>
		<span class="author">Eric S. Raymond.</span>
		<em class="title">The Cathedral and the Bazaar.</em>
		<span class="edition">2nd Edition.</span>
		<span class="date">1999.</span>
		<span class="isbn">ISBN 0-596-00131-2.</span>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="pagenums">
		240pp..
		</span>
	</li>
	<li id="Reps-Senzaki">
		<sup>[Reps-Senzaki]</sup>
		<span class="author">Paul Reps and Nyogen Senzaki.</span>
		<em class="title">Zen Flesh, Zen Bones.</em>
		<span class="date">1994.</span>
		<span class="publisher">Shambhala Publications.</span>
		<span class="isbn">ISBN 1-570-62063-6.</span>
		<span class="pagenums">
		285pp..
		</span>
		A superb anthology of Zen primary sources, presented just as
		they are.
	</li>
	<li id="Ritchie79">
		<sup>[Ritchie79]</sup>
		<span class="author">Dennis M. Ritchie.</span>
		<em class="title">The Evolution of the Unix Time-Sharing System.</em>
		<span class="date">1979.</span>
		<a href="http://cm.bell-labs.com/cm/cs/who/dmr/hist.html">
		Available on the Web</a>.
	</li>
	<li id="Ritchie93">
		<sup>[Ritchie93]</sup>
		<span class="author">Dennis M. Ritchie.</span>
		<em class="title">The Development of the C Language.</em>
		<span class="date">1993.</span>
		<a href="http://cm.bell-labs.com/cm/cs/who/dmr/chist.html">
		Available on the Web</a>.
	</li>
	<li id="RitchieQED">
		<sup>[RitchieQED]</sup>
		<span class="author">Dennis M. Ritchie.</span>
		<em class="title">An Incomplete History of the QED Text Editor.</em>
		<span class="date">2003.</span>
		<a href="http://cm.bell-labs.com/cm/cs/who/dmr/qed.html">
		Available on the Web</a>.
	</li>
	<li id="Ritchie-Thompson">
		<sup>[Ritchie-Thompson]</sup>
		<em class="title">The Unix Time-Sharing System.</em>
		<span class="author">Dennis M. Ritchie and Ken Thompson.</span>
		<a href="http://cm.bell-labs.com/cm/cs/who/dmr/cacm.html">
		Available on the Web</a>.
	</li>
	<li id="Saltzer">
		<sup>[Saltzer]</sup>
		<span class="biblioset">
		<em>ACM Transactions on Computer Systems</em>.
		<span class="publisher">Association for Computing Machinery.</span>
		</span>
		<span class="biblioset">
		<span class="author">James. H. Saltzer, David P. Reed, and David D. Clark.</span>
		“End-to-End Arguments in System Design”.
		<span class="date">November 1984.</span>
		<a href="http://web.mit.edu/Saltzer/www/publications/endtoend/endtoend.pdf">
			Available on the Web</a>.
		</span>
	</li>
	<li id="Salus">
		<sup>[Salus]</sup>
		<span class="author">Peter H. Salus.</span>
		<em class="title">A Quarter-Century of Unix.</em>
		<span class="publisher">Addison-Wesley.</span>
		<span class="date">1994.</span>
		<span class="isbn">ISBN 0-201-54777-5.</span>
		An excellent overview of Unix history, explaining many of the
		design decisions in the words of the people who made them.
	</li>
	<li id="Schaffer-Wolf">
		<sup>[Schaffer-Wolf]</sup>
		<span class="author">Evan Schaffer and Mike Wolf.</span>
		<em class="title">The Unix Shell as a Fourth-Generation Language.</em>
		<span class="date">1991.</span>
		<a href="http://www.rdb.com/lib/4gl.pdf">
		Available on the Web</a>.  An open-source implementation,
		<em>NoSQL</em>, is available and readily turned up
	by a Web search.
	</li>
	<li id="Schwartz-Christiansen">
		<sup>[Schwartz-Christiansen]</sup>
		<span class="author">Randal Schwartz and Tom Phoenix.</span>
		<em class="title">Learning Perl.</em>
		<span class="edition">3rd Edition.</span>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">2001.</span>
		<span class="isbn">ISBN 0-596-00132-0.</span>
	</li>
	<li id="Spinellis">
		<sup>[Spinellis]</sup>
		<span class="biblioset">
		<em>Journal of Systems and Software</em>.
		</span>
		<span class="biblioset">
		<span class="author">Diomidis Spinellis.</span>
		“Notable Design Patterns for Domain-Specific Languages”.
		<span class="volumenum">
		56.
		</span>
		<span class="issuenum">
		(1).
		</span>
		<span class="date">February 2001.</span>
		<span class="pagenums">
		p. 91-99.
		</span>
		</span>
	</li>
	<li id="Stallman">
		<sup>[Stallman]</sup>
		<span class="author">Richard M. Stallman.</span>
		<em class="title">The GNU Manifesto.</em>
		<a href="http://www.gnu.org/gnu/manifesto.html">
		Available on
		the Web</a>.
	</li>
	<li id="Stephenson">
		<sup>[Stephenson]</sup>
		<span class="author">Neal Stephenson.</span>
		<em class="title">In the Beginning Was the Command Line.</em>
		<span class="date">1999.</span>
		<a href="http://www.cryptonomicon.com/beginning.html">
		Available on the Web</a>,
		and also as a trade paperback from Avon Books.
	</li>
	<li id="Stevens90">
		<sup>[Stevens90]</sup>
		<span class="author">W. Richard Stevens.</span>
		<em class="title">Unix Network Programming.</em>
		<span class="publisher">Prentice-Hall.</span>
		<span class="date">1990.</span>
		<span class="isbn">ISBN 0-13-949876-1.</span>
		The classic on this topic. Note: Some later editions of this
		book omit coverage of the Version 6 networking facilities like
		<em>mx()</em>.
	</li>
	<li id="Stevens92">
		<sup>[Stevens92]</sup>
		<span class="author">W. Richard Stevens.</span>
		<em class="title">Advanced Programming in the Unix Environment.</em>
		<span class="date">1992.</span>
		<span class="isbn">ISBN 0-201-56317-7.</span>
		<span class="publisher">Addison-Wesley.</span>
		Stevens's comprehensive guide to the Unix API.  A feast for
		the experienced programmer or the bright novice, and a worthy 
		companion to
		<em>Unix Network Programming</em>.
	</li>
	<li id="Stroustrup">
		<sup>[Stroustrup]</sup>
		<span class="author">Bjarne Stroustrup.</span>
		<em class="title">The C++ Programming Language.</em>
		<span class="publisher">Addison-Wesley.</span>
		<span class="date">1991.</span>
		<span class="isbn">ISBN 0-201-53992-6.</span>
	</li>
	<li id="Tanenbaum-VanRenesse">
		<sup>[Tanenbaum-VanRenesse]</sup>
		<span class="author">Andrew S. Tanenbaum and Robbert van Renesse.</span>
		<em class="title">A Critique of the Remote Procedure Call Paradigm.</em>
		<span class="publisher">EUTECO'88 Proceedings, Participants Edition.</span>
		<span class="date">1988.</span>
		<span class="pagenums">
		pp. 775-783.
		</span>
	</li>
	<li id="Tidwell">
		<sup>[Tidwell]</sup>
		<span class="author">Doug Tidwell.</span>
		<em class="title">XSLT: Mastering XML Transformations.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">2001.</span>
		<span class="isbn">ISBN 1-596-00053-7.</span>
	</li>
	<li id="Torvalds">
		<sup>[Torvalds]</sup>
		<span class="author">Linus Torvalds and David Diamond.</span>
		<em class="title">Just for Fun.</em>
		<span class="subtitle">
		The Story of an Accidental Revolutionary.
		</span>
		<span class="publisher">HarperBusiness.</span>
		<span class="date">2001.</span>
		<span class="isbn">ISBN 0-06-662072-4.</span>
	</li>
	<li id="Vaughan">
		<sup>[Vaughan]</sup>
		<span class="author">Gary V. Vaughan, Tom Tromey, and Ian Lance Taylor.</span>
		<em class="title">GNU Autoconf, Automake, and Libtool.</em>
		<span class="publisher">New Riders Publishing.</span>
		<span class="date">2000.</span>
		<span class="pagenums">
		390 p..
		</span>
		<span class="isbn">ISBN 1-578-70190-2.</span>
		A user's guide to the GNU autoconfiguration tools.
		<a href="http://sources.redhat.com/autobook/">
		Available on the Web</a>.
	</li>
	<li id="Vo">
		<sup>[Vo]</sup>
		<span class="biblioset">
		<em>Software Practice &amp; Experience</em>.
		</span>
		<span class="biblioset">
		<span class="author">Kiem-Phong Vo.</span>
		“The Discipline and Method Architecture for Reusable Libraries”.
		<span class="date">2000.</span>
		<span class="volumenum">
		30.
		</span>
		<span class="pagenums">
		p. 107-128.
		</span>
		<a href="http://www.research.att.com/sw/tools/vcodex/dm-spe.ps">
			Available
		on the Web</a>.
		</span>
	</li>
	<li id="Wall2000">
		<sup>[Wall2000]</sup>
		<span class="author">Larry Wall, Tom Christiansen, and Jon Orwant.</span>
		<em class="title">Programming Perl.</em>
		<span class="edition">3rd Edition.</span>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">2000.</span>
		<span class="isbn">ISBN  0-596-00027-8.</span>
	</li>
	<li id="Welch">
		<sup>[Welch]</sup>
		<span class="author">Brent Welch.</span>
		<em class="title">Practical Programming in Tcl and Tk.</em>
		<span class="publisher">Prentice-Hall.</span>
		<span class="date">1999.</span>
		<span class="isbn">ISBN 0-13-022028-0.</span>
	</li>
	<li id="Williams">
		<sup>[Williams]</sup>
		<span class="author">Sam Williams.</span>
		<em class="title">Free as in Freedom.</em>
		<span class="publisher">O'Reilly &amp; Associates.</span>
		<span class="date">2002.</span>
		<span class="isbn">ISBN 0-596-00287-4.</span>
		<a href="http://www.oreilly.com/openbook/freedom/index.html">
		Available
		on the Web</a>.
	</li>
	<li id="Yourdon">
		<sup>[Yourdon]</sup>
		<span class="author">Edward Yourdon.</span>
		<em class="title">Death March.</em>
		<span class="subtitle">
		The Complete Software Developer's Guide to Surviving “Mission Impossible” Projects.
		</span>
		<span class="publisher">Prentice-Hall.</span>
		<span class="date">1997.</span>
		<span class="isbn">ISBN 0-137-48310-4.</span>
	</li>
</ul>


<!-- FILE: apc.html -->
<h3 id="apc"><a href="#apc">§</a>Appendix C. Contributors</h3>
<blockquote class="epigraph">
	<p>Anyone who has attended a USENIX conference in a fancy hotel can tell you that a sentence like “You're one of
	those computer people, aren't you?” is roughly equivalent to “Look, another amazingly mobile form of slime mold!” in
	the mouth of a hotel cocktail waitress.</p>
	<span>– Elizabeth Zwicky</span>
</blockquote>

  <p>
   <em>Ken Arnold</em>
   was part of the group that created the 4BSD Unix releases.  He wrote the original curses(3) library and was one of
   the authors of the original rogue(6) game. He is a co-author of the <em>Java Reference Manual</em>, and one of the
   leading experts on Java and OO techniques.
  </p>
  <p>
   <em>Steven M. Bellovin</em> created Usenet (with Tom Truscott and Jim Ellis) while at University of North Carolina in
   1979. In 1982 he joined AT&amp;T Bell Laboratories, where he has done pioneering research in security, cryptography,
   and networking on Unix systems and elsewhere.  He is an active member of the Internet Engineering Task Force, and a
   member of the National Academy of Engineering.
  </p>
  <p>
   <em>Stuart Feldman</em> was a member of the Bell Labs Unix development group.  He wrote make(1) and f77(1). He is now
   the vice-president in charge of computing research at IBM.
  </p>
  <p>
   <em>Jim Gettys</em> was, with Bob Scheifler and Keith Packard, one of the principal architects of the X windowing
   system in the late 1980s.  He wrote much of the X library, the X license, and articulated the “mechanism, not policy”
   central credo of the X design.
  </p>
  <p>
   <em>Steve Johnson</em> wrote yacc(1) and then used it to write the Portable C Compiler, which replaced the original DMR C and became the ancestor of most later Unix C compilers.
  </p>
  <p>
   <em>Brian Kernighan</em> has been the Unix community's single most articulate exponent of good style.  He has
   authored or coauthored several books that are indispensable classics of the tradition, including <em>The Practice of
   Programming</em>, <em>The C Programming Language</em>, <em>The Unix Programming Environment</em>.  While at Bell
   Labs, he coauthored the awk(1) language and had a major hand in the development of the troff family of tools,
   including eqn(1) (co-written with Lorinda Cherry), pic(1), and grap(1) (Jon Bentley).
  </p>
  <p>
   <em>David Korn</em> wrote the Korn shell, the stylistic ancestor of almost all modern Unix shell designs.  He created
   UWIN, a UNIX emulator for those that are forced to use Windows.  David has also done research in the design of file
   systems and tools for source-code portability.
  </p>
  <p>
   <em>Mike Lesk</em> was part of the original Unix crew at Bell Labs.  Among other contributions, he wrote the
   <em>ms</em> macro package, the tbl(1) and refer(1) tools for word processing, the lex(1) lexical-analyzer generator,
   and <em>UUCP</em> (Unix-to-Unix copy program).
  </p>
  <p>
   <em>Doug McIlroy</em> headed the research group at Bell Labs where Unix was born and invented the Unix pipe.  He
   wrote spell(1), diff(1), sort(1), join(1), tr(1), and other classic Unix tools, and helped define the traditional
   style of Unix documentation.  He has also done pioneering work in storage-allocation algorithms, computer security,
   and theorem-proving.
  </p>
  <p>
   <em>Marshall Kirk McKusick</em> implemented the 4.2BSD fast file system and was the Research Computer Scientist at the Berkeley Computer Systems Research Group (CSRG) overseeing the development and release of 4.3BSD and 4.4BSD.
  </p>
  <p>
   <em>Keith Packard</em> was a major contributor to the original X11 code.  During a second phase of involvement
   beginning in 1999, Keith rewrote the X rendering code, producing a more powerful but dramatically smaller
   implementation suitable for handheld computers and PDAs.
  </p>
  <p>
   <em>Eric S. Raymond</em> has been writing Unix software since 1982. In 1991 he edited <em>The New Hacker's
   Dictionary</em>, and has since been studying the Unix community and the Internet hacker culture from a historical and
   anthropological perspective.  In 1997 that study produced <em>The Cathedral and the Bazaar</em>, that helped
   (re)define and energize the open-source movement.  He presently maintains more than thirty open-source software
   projects and about a dozen key FAQ documents.
  </p>
  <p>
   <em>Henry Spencer</em> was a leader among the first wave of programmers to embrace Unix when it escaped from Bell
   Labs in the mid-1970s.  His contributions included the public-domain getopt(3), the first open-source string library,
   and an open-source regular-expression engine which found use in 4.4BSD and as the reference for the POSIX standard.
   He is also a noted expert on the arcana of C. He was a coauthor of C News, and has for many years been a voice of
   reason on Usenet and one of its most respected regulars.
  </p>
  <p>
   <em>Ken Thompson</em> invented Unix.
  </p>

<!-- FILE: none -->
<h2 id="revhistory"><a href="#revhistory">§</a>Revision History</h2>
<strong>Revision 1.1</strong> – 15 January 2019 – Martin Tournoij &lt;martin@arp242.net&gt;<br>
Reformat as single HTML docment with more modern styling.<br>
<strong>Revision 1.0</strong> – 19 September 2003 – esr<br>
This is the content that went to Addison-Wesley's printers.<br>
<strong>Revision 0.4</strong> – 5 February 2003 – esr<br>
Release for public review.<br>
<strong>Revision 0.3</strong> – 22 January 2003 – esr<br>
First eighteen-chapter draft. Manuscript walkthrough at Chapter 12. Limited release for early reviewers.<br>
<strong>Revision 0.2</strong> – 2 January 2003 – esr<br>
First manuscript walkthrough at Chapter 7. Released to Dmitry Kirsanov at AW production.<br>
<strong>Revision 0.1</strong> – 16 November 2002 – esr<br>
First DocBook draft, fifteen chapters. Languages rewritten to incorporate lots of feedback. Transparency, Shipped to Mark Taub at AW.<br>
<strong>Revision 0.0</strong> – 1999 – esr<br>
Public HTML draft, first four chapters only.<br>


<!-- FILE: unix_koans.html -->
<h3 id="unix_koans"><a href="#unix_koans">§</a>Appendix D. Rootless Root</h3>
<div class="center">
	<img alt src="data:image/png;base64,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"/>
</div>



<!-- FILE: introduction.html -->
<h3 id="introduction"><a href="#introduction">§</a>Editor's Introduction</h3>
<p>
  The discovery of the collection of koans known as the <em>Rootless Root</em>, apparently preserved for decades in the
  dry upper air of the Western Mountains, has ignited great controversy in scholarly circles.  Are these authentic
  documents shedding new light on the teaching of the early Unix patriarchs?  Or are they clever pastiches from a later
  age, commanding the authority of semi-mythical figures such as the Patriarchs Thompson, Ritchie and McIlroy for
  doctrines which evolved closer to our own era?
</p>
<p>
  It is impossible to say for certain.  All sides in the dispute
have made much of an alleged similarity to that venerable classic,
  <em>The Tao of Programming</em>.<sup><a href="#ftn.id3033994" id="id3033994">[165]</a></sup>
  But
  <em>Rootless Root</em> is
quite different in tone and style from the loose, poetic anecdotes of
the James translation, focused as it is on the remarkable and
enigmatic figure of Master Foo.
</p>
<p>
  It would be more apposite to seek parallels in the
  <em>AI Koans</em>;<sup><a href="#ftn.id3034026" id="id3034026">[166]</a></sup>
  indeed,
there are textual clues that the author of the
  <em>Rootless Root</em>
  may have redacted certain versions of the
  <em>AI Koans</em>. We are also on much firmer ground in
seeking connections with the Loginataka;<sup><a href="#ftn.id3034054" id="id3034054">[167]</a></sup>
  indeed, it is
quite possible that the unknown authors of
  <em>Rootless Root</em>
  and of
  <em>Loginataka</em> were one and
the same person, possibly a student of Master Foo himself.
</p>
<p>
  Mention should also be made of the
  <em>Tales of Zen Master Greg</em>,<sup><a href="#ftn.id3034091" id="id3034091">[168]</a></sup>
  though
the Nine Inch Nails references have cast some doubt on their antiquity
and it is thus unlikely that they influenced
  <em>Rootless Root</em>.
</p>
<p>
  That the title of the work was intended as a reference to the
Zen classic
  <em>Gateless Gate</em> <sup><a href="#ftn.id3034123" id="id3034123">[169]</a></sup>
  of Mumon, we can say with fair confidence.  There are echoes of Mumon
in several of the koans.
</p>
<p>
  There is considerable dispute over whether Master Foo should 
be assigned to the Eastern (New Jersey) School, or the Western
School that grew out of the Patriarch Thompson's epochal early journey
to Berkeley.  If this question has not been settled, it is perhaps
because we cannot even establish that Master Foo ever existed!  He
might merely be a composite of a group of teachers, or of an entire dharma 
lineage.
</p>
<p>
  Even supposing the legend of Master Foo accreted around the
teaching of some a single person, what of his favored student
Nubi?  Nubi has all the earmarks of a stock figure, the perfect
disciple.  One is reminded of the tales surrounding the Buddha's 
favorite follower Ananda.  It seems likely that there was a
historical Ananda, but no trace of his actual personality has
survived the euhemerizing process by which the life of the Buddha
was polished into timeless myth.
</p>
<p>
  In the end, all we can do is take these teaching stories on
their own terms, and extract what kernels of wisdom may be found
there.
</p>
<p>
  The redaction of the
  <em>Rootless Root</em> is a
work in progress, as the source materials present many difficulties 
in reconstruction and interpretation. Future versions may include 
more stories as these difficulties are overcome.
</p>

<div class="footnotes"><strong>Footnotes</strong>
<p><sup><a href="#id3033994" id="ftn.id3033994">[165]</a></sup>
  <em>The Tao of Programming</em>
  is available
  <a href="http://www.canonical.org/~kragen/tao-of-programming.html">
   on the Web</a>.
</p>

<p><sup><a href="#id3034026" id="ftn.id3034026">[166]</a></sup>
  The
  <em>AI Koans</em> are available
  <a href="http://www.catb.org/~esr/jargon/html/Some-AI-Koans.html">
   on the Web</a>.
</p>

<p><sup><a href="#id3034054" id="ftn.id3034054">[167]</a></sup>
  The
  <em>Loginataka</em> is available
  <a href="http://www.catb.org/~esr/faqs/loginataka.html">
   on the Web</a>.
</p>

<p><sup><a href="#id3034091" id="ftn.id3034091">[168]</a></sup>
  The
  <em>Tales of Zen Master Greg</em>
  are available
  <a href="http://www.gu.uwa.edu.au/users/greg/">
   on the Web</a>.
</p>

<p><sup><a href="#id3034123" id="ftn.id3034123">[169]</a></sup>
  The
  <em>Gateless Gate</em> is available
  <a href="http://www.ibiblio.org/zen/cgi-bin/koan-index.pl">
   on the Web</a>.
</p>
</div>


<!-- FILE: ten-thousand.html -->
<h3 id="ten-thousand"><a href="#ten-thousand">§</a>Master Foo and the Ten Thousand Lines</h3>
<p>
  Master Foo once said to a visiting programmer: “There is
more Unix-nature in one line of shell script than there is in ten thousand
lines of C”.
</p>
<p>
  The programmer, who was very proud of his mastery of C, said:
“How can this be?  C is the language in which the very kernel of
Unix is implemented!”
</p>
<p>
  Master Foo replied: “That is so. Nevertheless, there is
more Unix-nature in one line of shell script than there is in ten thousand
lines of C”.
</p>
<p>
  The programmer grew distressed.  “But through the C
language we experience the enlightenment of the Patriarch Ritchie!  We
become as one with the operating system and the machine, reaping
matchless performance!”
</p>
<p>
  Master Foo replied: “All that you say is true. But there
is still more Unix-nature in one line of shell script than there is in ten
thousand lines of C”.
</p>
<p>
  The programmer scoffed at Master Foo and rose to depart.  But
Master Foo nodded to his student Nubi, who wrote a line of shell
script on a nearby whiteboard, and said: “Master programmer,
consider this pipeline.  Implemented in pure C, would it not span ten
thousand lines?”
</p>
<p>
  The programmer muttered through his beard, contemplating what
Nubi had written.  Finally he agreed that it was so.
</p>
<p>
  “And how many hours would you require to implement and
debug that C program?” asked Nubi.
</p>
<p>
  “Many”, admitted the visiting programmer.
“But only a fool would spend the time to do that when so many
more worthy tasks await him”.
</p>
<p>
  “And who better understands the Unix-nature?”
Master Foo asked. “Is it he who writes the ten thousand
lines, or he who, perceiving the emptiness of the task, gains merit by
not coding?”
</p>
<p>
  Upon hearing this, the programmer was enlightened.
</p>



<!-- FILE: script-kiddie.html -->
<h3 id="script-kiddie"><a href="#script-kiddie">§</a>Master Foo and the Script Kiddie</h3>
<p>
  A stranger from the land of Woot came to Master Foo as he was
eating the morning meal with his students.
</p>
<p>
  “I hear y00 are very l33t”, he said.
“Pl33z teach m3 all y00 know”.
</p>
<p>
  Master Foo's students looked at each other, confused by the
stranger's barbarous language. Master Foo just smiled and replied:
“You wish to learn the Way of Unix?”
</p>
<p>
  “I want to b3 a wizard hax0r”, the stranger
replied, “and 0wn ever3one's b0xen”.
</p>
<p>
  “I do not teach that Way”, replied Master Foo.
</p>
<p>
  The stranger grew agitated.  “D00d, y00 r nothing but a
p0ser”, he said.  “If y00 n00 anything, y00 wud t33ch
m3”.
</p>
<p>
  “There is a path”, said Master Foo, “that
might bring you to wisdom”.  The master scribbled an IP address on
a piece of paper.  “Cracking this box should pose you little
difficulty, as its guardians are incompetent.  Return and tell me 
what you find”.
</p>
<p>
  The stranger bowed and left. Master Foo finished his meal.
</p>
<p>
  Days passed, then months.  The stranger was forgotten.
</p>
<p>
  Years later, the stranger from the land of Woot returned.
</p>
<p>
  “Damn you!” he said, “I cracked that box, and
it was easy like you said.  But I got busted by the FBI and thrown
in jail”.
</p>
<p>
  “Good”, said Master Foo.  “You are ready for
the next lesson”.  He scribbled an IP address on another piece
of paper and handed it to the stranger.
</p>
<p>
  “Are you
  <em>crazy</em>
  ?” the stranger
yelled. “After what I've been through, I'm never going to break
into a computer again!”
</p>
<p>
  Master Foo smiled.  “Here”, he said, “is the
beginning of wisdom”.
</p>
<p>
  On hearing this, the stranger was enlightened.
</p>



<!-- FILE: two_paths.html -->
<h3 id="two_paths"><a href="#two_paths">§</a>Master Foo Discourses on the Two Paths</h3>
<p>
  Master Foo instructed his students:
</p>
<p>
  “There is a line of dharma teaching, exemplified by the
Patriarch McIlroy's mantra ‘Do one thing well’, which
emphasizes that software partakes of the Unix way when it has simple
and consistent behavior, with properties that can be readily modeled by
the mind of the user and used by other programs”.
</p>
<p>
  “But there is another line of dharma teaching, exemplified by the
Patriarch Thompson's great mantra ‘When in doubt, use brute
force’, and various sutras on the value of getting 90% of cases
right
  <em>now</em>, rather than 100%
  <em>later</em>, which emphasizes robustness and simplicity of
implementation”.
</p>
<p>
  “Now tell me: which programs have the Unix nature?”
</p>
<p>
  After a silence, Nubi observed:
</p>
<p>
  “Master, these teachings may conflict”.
</p>
<p>
  “A simple implementation is likely to lack logic for edge
cases, such as resource exhaustion, or failure to close a race window,
or a timeout during an uncompleted transaction”.
</p>
<p>
  “When such edge cases occur, the behavior of the software
will become irregular and difficult.  Surely this is not the Way of
Unix?”
</p>
<p>
  Master Foo nodded in agreement.
</p>
<p>
  “On the other hand, it is well known that fancy algorithms
are brittle.  Further, each attempt to cover an edge case tends to
interact with both the program's central algorithms and the code
covering other edge cases”.
</p>
<p>
  “Thus, attempts to cover all edge cases in advance, guaranteeing
‘simplicity of description’, may in fact produce code that is
overcomplicated and brittle or which, plagued by bugs, never ships at all.
Surely this is not the Way of Unix?”
</p>
<p>
  Master Foo nodded in agreement.
</p>
<p>
  “What, then, is the proper dharma path?” asked Nubi.
</p>
<p>
  The master spoke:
</p>
<p>
  “When the eagle flies, does it forget that its feet have
touched the ground?  When the tiger lands upon its prey, does it
forget its moment in the air? Three pounds of VAX!”
</p>
<p>
  On hearing this, Nubi was enlightened.
</p>



<!-- FILE: methodology-consultant.html -->
<h3 id="methodology-consultant"><a href="#methodology-consultant">§</a>Master Foo and theMethodologist</h3>
<p>
  When Master Foo and his student Nubi journeyed among the sacred
sites, it was the Master's custom in the evenings to offer public
instruction to Unix neophytes of the towns and villages in which they
stopped for the night.
</p>
<p>
  On one such occasion, a methodologist was among those
who gathered to listen.
</p>
<p>
  “If you do not repeatedly profile your code for hot spots
while tuning, you will be like a fisherman who casts his net in an
empty lake”, said Master Foo.
</p>
<p>
  “Is it not, then, also true”, said the methodology
consultant, “that if you do not continually measure your
productivity while managing resources, you will be like a fisherman who
casts his net in an empty lake?”
</p>
<p>
  “I once came upon a fisherman who just at that moment let
his net fall in the lake on which his boat was floating”, said
Master Foo.  “He scrabbled around in the bottom of his boat for
quite a while looking for it”.
</p>
<p>
  “But”, said the methodologist, “if
he had dropped his net in the lake, why was he looking in the
boat?”
</p>
<p>
  “Because he could not swim”, replied Master Foo.
</p>
<p>
  Upon hearing this, the methodologist was enlightened.
</p>



<!-- FILE: gui-programmer.html -->
<h3 id="gui-programmer"><a href="#gui-programmer">§</a>Master Foo Discourses on theGraphical User Interface</h3>
<p>
  One evening, Master Foo and Nubi attended a gathering of
programmers who had met to learn from each other.  One of the
programmers asked Nubi to what school he and his master belonged. Upon
being told they were followers of the Great Way of Unix, the
programmer grew scornful.
</p>
<p>
  “The command-line tools of Unix are crude and
backward”, he scoffed.  “Modern, properly designed
operating systems do everything through a graphical user
interface”.
</p>
<p>
  Master Foo said nothing, but pointed at the moon.  A nearby
dog began to bark at the master's hand.
</p>
<p>
  “I don't understand you!” said the programmer.
</p>
<p>
  Master Foo remained silent, and pointed at an image of the Buddha.
Then he pointed at a window.
</p>
<p>
  “What are you trying to tell me?” asked the
programmer.
</p>
<p>
  Master Foo pointed at the programmer's head.
Then he pointed at a rock.
</p>
<p>
  “Why can't you make yourself clear?” demanded the
programmer.
</p>
<p>
  Master Foo frowned thoughtfully, tapped the the programmer
twice on the nose, and dropped him in a nearby trashcan.
</p>
<p>
  As the programmer was attempting to extricate himself from
the garbage, the dog wandered over and piddled on him.
</p>
<p>
  At that moment, the programmer achieved enlightenment.
</p>



<!-- FILE: zealot.html -->
<h3 id="zealot"><a href="#zealot">§</a>Master Foo and the Unix Zealot</h3>
<p>
  A Unix zealot, having heard that Master Foo was wise in the
Great Way, came to him for instruction.  Master Foo said to him:
</p>
<p>
  “When the Patriarch Thompson invented Unix, he did not
understand it.  Then he gained in understanding, and no longer invented
it”.
</p>
<p>
  “When the Patriarch McIlroy invented the pipe, he knew
that it would transform software, but did not know that it would 
transform mind”.
</p>
<p>
  “When the Patriarch Ritchie invented C, he condemned 
programmers to a thousand hells of buffer overruns, heap corruption,
and stale-pointer bugs”.
</p>
<p>
  “Truly, the Patriarchs were blind and foolish!”
</p>
<p>
  The zealot was greatly angered by the Master's words.
</p>
<p>
  “These enlightened ones”, he protested. “gave
us the Great Way of Unix.  Surely, if we mock them we will lose merit
and be reborn as beasts or MCSEs”.
</p>
<p>
  “Is your code ever completely without stain and
flaw?” demanded Master Foo.
</p>
<p>
  “No”, admitted the zealot, “no man's
is”.
</p>
<p>
  “The wisdom of the Patriarchs”, said Master Foo,
“was that they
  <em>knew</em>
  they were
fools”.
</p>
<p>
  Upon hearing this, the zealot was enlightened.
</p>



<!-- FILE: unix-nature.html -->
<h3 id="unix-nature"><a href="#unix-nature">§</a>Master Foo Discourses on the Unix-Nature</h3>
<p>
  A student said to Master Foo: “We are told that the firm
called SCO holds true dominion over Unix”.
</p>
<p>
  Master Foo nodded.
</p>
<p>
  The student continued, “Yet we are also told that the firm
called OpenGroup also holds true dominion over Unix”.
</p>
<p>
  Master Foo nodded.
</p>
<p>
  “How can this be?” asked the student.
</p>
<p>
  Master Foo replied:
</p>
<p>
  “SCO indeed has dominion over the code of Unix, but the
code of Unix is not Unix.  OpenGroup indeed has dominion over the name
of Unix, but the name of Unix is not Unix”.
</p>
<p>
  “What, then, is the Unix-nature?” asked the student.
</p>
<p>
  Master Foo replied:
</p>
<p>
  “Not code.  Not name.  Not mind.  Not things.  Always changing,
yet never changing”.
</p>
<p>
  “The Unix-nature is simple and empty.  Because it is
simple and empty, it is more powerful than a typhoon”.
</p>
<p>
  “Moving in accordance with the law of nature, it unfolds
inexorably in the minds of programmers, assimilating designs to its
own nature. All software that would compete with it must become
like to it; empty, empty, profoundly empty, perfectly void,
hail!”
</p>
<p>
  Upon hearing this, the student was enlightened.
</p>



<!-- FILE: end-user.html -->
<h3 id="end-user"><a href="#end-user">§</a>Master Foo and the End User</h3>
<p>
  On another occasion when Master Foo gave public instruction, an
end user, having heard tales of the Master's wisdom, came to him for
guidance.
</p>
<p>
  He bowed three times to Master Foo. “I wish to learn the
Great Way of Unix”, he said “but the command line
confuses me”.
</p>
<p>
  Some of the onlooking neophytes began to mock the end user,
calling him “clueless” and saying that the Way of
Unix is only for those of discipline and intelligence.
</p>
<p>
  The Master held up a hand for silence, and called the most
obstreperous of the neophytes who had mocked forward, to where
he and the end user sat.
</p>
<p>
  “Tell me”, he asked the neophyte, “of the
code you have written and the works of design you have
uttered”.
</p>
<p>
  The neophyte began to stammer out a reply, but fell silent.
</p>
<p>
  Master Foo turned to the end-user. “Tell me”, he
inquired, “why do you seek the Way?”
</p>
<p>
  “I am discontent with the software I see around
me”, the end user replied. “It neither performs reliably
nor pleases the eye and hand.  Having heard that the Unix way, though
difficult, is superior, I seek to cast aside all snares and
delusions”.
</p>
<p>
  “And what do you do in the world”, asked Master Foo,
“that you must strive with software?”
</p>
<p>
  “I am a builder”, the end user replied, “Many
of the houses of this town were made under my chop”.
</p>
<p>
  Master Foo turned back to the neophyte.  “The housecat may
mock the tiger”, said the master, “but doing so will not
make his purr into a roar”.
</p>
<p>
  Upon hearing this, the neophyte was enlightened.
</p>




	<script>
		document.addEventListener('DOMContentLoaded', function() { 
			var toc = document.getElementById('toc'),
				btn = document.getElementById('toc-button');

			toc.className = 'toc-fixed toc-collapsed';

			btn.addEventListener('click', function(e) {
				e.preventDefault();
				if (toc.className.indexOf('toc-collapsed') === -1) {
					btn.innerHTML = '»';
					toc.className = 'toc-fixed toc-collapsed';
				}
				else {
					btn.innerHTML = '«';
					toc.className = 'toc-fixed';
				}
			}, false);

			document.body.addEventListener('keydown', function(e) {
				if (e.keyCode !== 27) {
					return;
				}
				e.preventDefault();
				btn.click();
			}, false);

			// Get list of all headers.
			var headers = [];
			for (var i = 0; i<=1; i++) {
				var h = document.getElementsByTagName(['h3', 'h2'][i]);
				for (var j = 0; j < h.length; j++) {
					if (h[j].id !== '' ) {
						headers.push(h[j]);
					}
				}
			}
			// TODO: this is fairly slow.
			headers.sort(function(a, b) { return a.offsetTop > b.offsetTop; });

			var links = toc.getElementsByTagName('a'),
				active = null;

			window.headers = headers;
			var scroll = function(e) {
				// Don't run this too often.
				window.removeEventListener('scroll', scroll);
				setTimeout(function() {
					window.addEventListener('scroll', scroll, false)
				}, 100);

				console.log(e);
				for (var i=0; i<headers.length; i++) {
					if (headers[i].offsetTop >= window.scrollY) {
						for (var j=0; j<links.length; j++) {
							if (links[j].hash === '#' + headers[i].id) {
								if (active) {
									active.className = '';
								}
								active = links[j];
								links[j].className = 'active';
								break
							}
						}
						break;
					}
				}
			};
			window.addEventListener('scroll', scroll, false)
		}, false);
	</script>
</body>
</html>
